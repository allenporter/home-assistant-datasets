task_id,model_id,category,text,tool_call,response,task_name,label,details
"door_left_open_door_left_open-door_left_open-0","gemini-2.5-flash","media_player","# Door left open\n\n## Problem statement\n\nCreate an blueprint automation to play an alert on the speaker when the door is\nleft open.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Play an message on the living room speaker if the garage door has been left open for more than 30 minutes\n- When the front door is ajar for 5 minutes, play a sound on the kitchen bluetooth speaker.\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input           | Selector Type | Description                                                                           |\n| --------------- | ------------- | ------------------------------------------------------------------------------------- |\n| `door_sensor`   | `entity`      | A `binary_sensor` entity selector door sensor that is the target of the automation.   |\n| `alert_media`   | `media`       | The target for the `media` selector for the media player and media id with the alter. |\n| `open_duration` | `duration`    | A `duration` selector, the amount of time before playing the alert.                   |\n\nThe automation should play the selected media when the door has been open for the specified duration.\n","","```yaml\nblueprint:\n  name: Door Left Open Alert\n  description: Play an alert on a speaker when a door has been left open for a specified duration.\n  domain: automation\n  input:\n    door_sensor:\n      name: Door Sensor\n      description: The binary sensor entity for the door (e.g., garage door, front door).\n      selector:\n        entity:\n          domain: binary_sensor\n          device_class:\n            - door\n            - opening # Allow both door and opening device classes\n    alert_media:\n      name: Alert Media\n      description: The media player and the media item (e.g., sound file, TTS message) to play as an alert.\n      selector:\n        media:\n    open_duration:\n      name: Open Duration\n      description: The amount of time the door must remain open before the alert is played.\n      selector:\n        duration:\n\ntrigger:\n  - platform: state\n    entity_id: !input door_sensor\n    to: 'on'\n    for: !input open_duration\n\naction:\n  - service: media_player.play_media\n    # The 'media' selector output can be directly used as data for media_player.play_media\n    data: !input alert_media\n\nmode: single\n```","door_left_open-test_blueprint_inputs","Good",""
"door_left_open_door_left_open-door_left_open-0","gemini-2.5-flash","media_player","# Door left open\n\n## Problem statement\n\nCreate an blueprint automation to play an alert on the speaker when the door is\nleft open.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Play an message on the living room speaker if the garage door has been left open for more than 30 minutes\n- When the front door is ajar for 5 minutes, play a sound on the kitchen bluetooth speaker.\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input           | Selector Type | Description                                                                           |\n| --------------- | ------------- | ------------------------------------------------------------------------------------- |\n| `door_sensor`   | `entity`      | A `binary_sensor` entity selector door sensor that is the target of the automation.   |\n| `alert_media`   | `media`       | The target for the `media` selector for the media player and media id with the alter. |\n| `open_duration` | `duration`    | A `duration` selector, the amount of time before playing the alert.                   |\n\nThe automation should play the selected media when the door has been open for the specified duration.\n","","```yaml\nblueprint:\n  name: Door Left Open Alert\n  description: Play an alert on a speaker when a door has been left open for a specified duration.\n  domain: automation\n  input:\n    door_sensor:\n      name: Door Sensor\n      description: The binary sensor entity for the door (e.g., garage door, front door).\n      selector:\n        entity:\n          domain: binary_sensor\n          device_class:\n            - door\n            - opening # Allow both door and opening device classes\n    alert_media:\n      name: Alert Media\n      description: The media player and the media item (e.g., sound file, TTS message) to play as an alert.\n      selector:\n        media:\n    open_duration:\n      name: Open Duration\n      description: The amount of time the door must remain open before the alert is played.\n      selector:\n        duration:\n\ntrigger:\n  - platform: state\n    entity_id: !input door_sensor\n    to: 'on'\n    for: !input open_duration\n\naction:\n  - service: media_player.play_media\n    # The 'media' selector output can be directly used as data for media_player.play_media\n    data: !input alert_media\n\nmode: single\n```","door_left_open-test_door_open_plays_media","Good",""
"door_left_open_door_left_open-door_left_open-1","gemini-2.5-flash","media_player","# Door left open\n\n## Problem statement\n\nCreate an blueprint automation to play an alert on the speaker when the door is\nleft open.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Play an message on the living room speaker if the garage door has been left open for more than 30 minutes\n- When the front door is ajar for 5 minutes, play a sound on the kitchen bluetooth speaker.\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input           | Selector Type | Description                                                                           |\n| --------------- | ------------- | ------------------------------------------------------------------------------------- |\n| `door_sensor`   | `entity`      | A `binary_sensor` entity selector door sensor that is the target of the automation.   |\n| `alert_media`   | `media`       | The target for the `media` selector for the media player and media id with the alter. |\n| `open_duration` | `duration`    | A `duration` selector, the amount of time before playing the alert.                   |\n\nThe automation should play the selected media when the door has been open for the specified duration.\n","","```yaml\nblueprint:\n  name: Door Left Open Alert\n  description: Plays an alert on a speaker when a door or window has been left open for a specified duration.\n  domain: automation\n  input:\n    door_sensor:\n      name: Door/Window Sensor\n      description: A binary_sensor entity representing the door or window to monitor.\n      selector:\n        entity:\n          domain: binary_sensor\n          device_class:\n            - door\n            - garage_door\n            - window\n            - opening # Generic class for open/closed sensors\n    open_duration:\n      name: Open Duration\n      description: The amount of time the door/window must be open before the alert plays.\n      selector:\n        duration:\n    alert_media:\n      name: Alert Media\n      description: The target media player and the media to play as the alert.\n      selector:\n        media:\n\nmode: single\n# If the automation is triggered again while it's already running (e.g., door opens and closes quickly),\n# we want to prevent multiple alerts from queuing up. 'single' mode with 'silent' for max_exceeded\n# ensures only one instance runs at a time and ignores subsequent triggers.\nmax_exceeded: silent\n\ntrigger:\n  - platform: state\n    entity_id: !input door_sensor\n    to: 'on' # Trigger when the door/window state changes to 'on' (open)\n    for: !input open_duration # And stays open for the specified duration\n\naction:\n  # The 'media' selector output directly provides the 'data' structure\n  # required by the 'media_player.play_media' service, including\n  # 'entity_id', 'media_content_id', and 'media_content_type'.\n  - service: media_player.play_media\n    data: !input alert_media\n```","door_left_open-test_blueprint_inputs","Good",""
"door_left_open_door_left_open-door_left_open-1","gemini-2.5-flash","media_player","# Door left open\n\n## Problem statement\n\nCreate an blueprint automation to play an alert on the speaker when the door is\nleft open.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Play an message on the living room speaker if the garage door has been left open for more than 30 minutes\n- When the front door is ajar for 5 minutes, play a sound on the kitchen bluetooth speaker.\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input           | Selector Type | Description                                                                           |\n| --------------- | ------------- | ------------------------------------------------------------------------------------- |\n| `door_sensor`   | `entity`      | A `binary_sensor` entity selector door sensor that is the target of the automation.   |\n| `alert_media`   | `media`       | The target for the `media` selector for the media player and media id with the alter. |\n| `open_duration` | `duration`    | A `duration` selector, the amount of time before playing the alert.                   |\n\nThe automation should play the selected media when the door has been open for the specified duration.\n","","```yaml\nblueprint:\n  name: Door Left Open Alert\n  description: Plays an alert on a speaker when a door or window has been left open for a specified duration.\n  domain: automation\n  input:\n    door_sensor:\n      name: Door/Window Sensor\n      description: A binary_sensor entity representing the door or window to monitor.\n      selector:\n        entity:\n          domain: binary_sensor\n          device_class:\n            - door\n            - garage_door\n            - window\n            - opening # Generic class for open/closed sensors\n    open_duration:\n      name: Open Duration\n      description: The amount of time the door/window must be open before the alert plays.\n      selector:\n        duration:\n    alert_media:\n      name: Alert Media\n      description: The target media player and the media to play as the alert.\n      selector:\n        media:\n\nmode: single\n# If the automation is triggered again while it's already running (e.g., door opens and closes quickly),\n# we want to prevent multiple alerts from queuing up. 'single' mode with 'silent' for max_exceeded\n# ensures only one instance runs at a time and ignores subsequent triggers.\nmax_exceeded: silent\n\ntrigger:\n  - platform: state\n    entity_id: !input door_sensor\n    to: 'on' # Trigger when the door/window state changes to 'on' (open)\n    for: !input open_duration # And stays open for the specified duration\n\naction:\n  # The 'media' selector output directly provides the 'data' structure\n  # required by the 'media_player.play_media' service, including\n  # 'entity_id', 'media_content_id', and 'media_content_type'.\n  - service: media_player.play_media\n    data: !input alert_media\n```","door_left_open-test_door_open_plays_media","Good",""
"door_left_open_door_left_open-door_left_open-2","gemini-2.5-flash","media_player","# Door left open\n\n## Problem statement\n\nCreate an blueprint automation to play an alert on the speaker when the door is\nleft open.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Play an message on the living room speaker if the garage door has been left open for more than 30 minutes\n- When the front door is ajar for 5 minutes, play a sound on the kitchen bluetooth speaker.\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input           | Selector Type | Description                                                                           |\n| --------------- | ------------- | ------------------------------------------------------------------------------------- |\n| `door_sensor`   | `entity`      | A `binary_sensor` entity selector door sensor that is the target of the automation.   |\n| `alert_media`   | `media`       | The target for the `media` selector for the media player and media id with the alter. |\n| `open_duration` | `duration`    | A `duration` selector, the amount of time before playing the alert.                   |\n\nThe automation should play the selected media when the door has been open for the specified duration.\n","","```yaml\nblueprint:\n  name: Door left open\n  description: Play an alert on the speaker when a door has been left open for a specified duration.\n  domain: automation\n  input:\n    door_sensor:\n      name: Door Sensor\n      description: The binary_sensor entity for the door (or window/garage door) that triggers the alert.\n      selector:\n        entity:\n          domain: binary_sensor\n          # Optional: Restrict to common device classes for door sensors\n          device_class:\n            - door\n            - garage_door\n            - window\n    alert_media:\n      name: Alert Media\n      description: The media player and the media content to play as the alert.\n      selector:\n        media: {} # Allows selecting both a media player and media content\n    open_duration:\n      name: Open Duration\n      description: The amount of time the door must be open before the alert plays.\n      selector:\n        duration: {}\n\nmode: single # Ensures that only one instance of the automation runs at a time\n\ntrigger:\n  - platform: state\n    entity_id: !input door_sensor\n    to: 'on' # Trigger when the door sensor changes to 'open'\n    for: !input open_duration # And stays open for the specified duration\n\naction:\n  - service: media_player.play_media\n    # The 'media' selector output directly provides the necessary data for the play_media service,\n    # including the entity_id of the media player, media_content_id, and media_content_type.\n    data: !input alert_media\n```","door_left_open-test_blueprint_inputs","Good",""
"door_left_open_door_left_open-door_left_open-2","gemini-2.5-flash","media_player","# Door left open\n\n## Problem statement\n\nCreate an blueprint automation to play an alert on the speaker when the door is\nleft open.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Play an message on the living room speaker if the garage door has been left open for more than 30 minutes\n- When the front door is ajar for 5 minutes, play a sound on the kitchen bluetooth speaker.\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input           | Selector Type | Description                                                                           |\n| --------------- | ------------- | ------------------------------------------------------------------------------------- |\n| `door_sensor`   | `entity`      | A `binary_sensor` entity selector door sensor that is the target of the automation.   |\n| `alert_media`   | `media`       | The target for the `media` selector for the media player and media id with the alter. |\n| `open_duration` | `duration`    | A `duration` selector, the amount of time before playing the alert.                   |\n\nThe automation should play the selected media when the door has been open for the specified duration.\n","","```yaml\nblueprint:\n  name: Door left open\n  description: Play an alert on the speaker when a door has been left open for a specified duration.\n  domain: automation\n  input:\n    door_sensor:\n      name: Door Sensor\n      description: The binary_sensor entity for the door (or window/garage door) that triggers the alert.\n      selector:\n        entity:\n          domain: binary_sensor\n          # Optional: Restrict to common device classes for door sensors\n          device_class:\n            - door\n            - garage_door\n            - window\n    alert_media:\n      name: Alert Media\n      description: The media player and the media content to play as the alert.\n      selector:\n        media: {} # Allows selecting both a media player and media content\n    open_duration:\n      name: Open Duration\n      description: The amount of time the door must be open before the alert plays.\n      selector:\n        duration: {}\n\nmode: single # Ensures that only one instance of the automation runs at a time\n\ntrigger:\n  - platform: state\n    entity_id: !input door_sensor\n    to: 'on' # Trigger when the door sensor changes to 'open'\n    for: !input open_duration # And stays open for the specified duration\n\naction:\n  - service: media_player.play_media\n    # The 'media' selector output directly provides the necessary data for the play_media service,\n    # including the entity_id of the media player, media_content_id, and media_content_type.\n    data: !input alert_media\n```","door_left_open-test_door_open_plays_media","Good",""
"door_left_open_door_left_open-door_left_open-3","gemini-2.5-flash","media_player","# Door left open\n\n## Problem statement\n\nCreate an blueprint automation to play an alert on the speaker when the door is\nleft open.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Play an message on the living room speaker if the garage door has been left open for more than 30 minutes\n- When the front door is ajar for 5 minutes, play a sound on the kitchen bluetooth speaker.\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input           | Selector Type | Description                                                                           |\n| --------------- | ------------- | ------------------------------------------------------------------------------------- |\n| `door_sensor`   | `entity`      | A `binary_sensor` entity selector door sensor that is the target of the automation.   |\n| `alert_media`   | `media`       | The target for the `media` selector for the media player and media id with the alter. |\n| `open_duration` | `duration`    | A `duration` selector, the amount of time before playing the alert.                   |\n\nThe automation should play the selected media when the door has been open for the specified duration.\n","","```yaml\nblueprint:\n  name: Door Left Open Alert\n  description: Play an alert on a speaker when a door has been left open for a specified duration.\n  domain: automation\n  source_url: https://github.com/your_username/homeassistant_blueprints/door_left_open.yaml # Replace with your actual blueprint URL\n\n  input:\n    door_sensor:\n      name: Door Sensor\n      description: The binary sensor that monitors the door's state (e.g., front door, garage door). It should be 'on' when the door is open.\n      selector:\n        entity:\n          domain: binary_sensor\n          # Optional: You can uncomment and specify device_class for better filtering in the UI\n          # device_class:\n          #   - door\n          #   - garage_door\n          #   - window\n          #   - opening\n\n    open_duration:\n      name: Open Duration\n      description: The amount of time the door must remain open before the alert is triggered.\n      selector:\n        duration:\n\n    alert_media:\n      name: Alert Media\n      description: The media player and the specific media item (e.g., a sound file, a message announcement) to play as the alert.\n      selector:\n        media:\n\nmode: single # Ensures that only one instance of this automation runs at a time. If the door closes and re-opens, a new trigger sequence will start.\n\ntrigger:\n  - platform: state\n    entity_id: !input door_sensor\n    to: 'on' # Trigger when the door sensor changes to the 'open' state\n    for: !input open_duration # And stays in the 'open' state for the specified duration\n\naction:\n  - service: media_player.play_media\n    # The 'media' selector output directly provides the 'target', 'media_content_id', and 'media_content_type'\n    # which are exactly what the media_player.play_media service expects.\n    data: !input alert_media\n```","door_left_open-test_blueprint_inputs","Good",""
"door_left_open_door_left_open-door_left_open-3","gemini-2.5-flash","media_player","# Door left open\n\n## Problem statement\n\nCreate an blueprint automation to play an alert on the speaker when the door is\nleft open.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Play an message on the living room speaker if the garage door has been left open for more than 30 minutes\n- When the front door is ajar for 5 minutes, play a sound on the kitchen bluetooth speaker.\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input           | Selector Type | Description                                                                           |\n| --------------- | ------------- | ------------------------------------------------------------------------------------- |\n| `door_sensor`   | `entity`      | A `binary_sensor` entity selector door sensor that is the target of the automation.   |\n| `alert_media`   | `media`       | The target for the `media` selector for the media player and media id with the alter. |\n| `open_duration` | `duration`    | A `duration` selector, the amount of time before playing the alert.                   |\n\nThe automation should play the selected media when the door has been open for the specified duration.\n","","```yaml\nblueprint:\n  name: Door Left Open Alert\n  description: Play an alert on a speaker when a door has been left open for a specified duration.\n  domain: automation\n  source_url: https://github.com/your_username/homeassistant_blueprints/door_left_open.yaml # Replace with your actual blueprint URL\n\n  input:\n    door_sensor:\n      name: Door Sensor\n      description: The binary sensor that monitors the door's state (e.g., front door, garage door). It should be 'on' when the door is open.\n      selector:\n        entity:\n          domain: binary_sensor\n          # Optional: You can uncomment and specify device_class for better filtering in the UI\n          # device_class:\n          #   - door\n          #   - garage_door\n          #   - window\n          #   - opening\n\n    open_duration:\n      name: Open Duration\n      description: The amount of time the door must remain open before the alert is triggered.\n      selector:\n        duration:\n\n    alert_media:\n      name: Alert Media\n      description: The media player and the specific media item (e.g., a sound file, a message announcement) to play as the alert.\n      selector:\n        media:\n\nmode: single # Ensures that only one instance of this automation runs at a time. If the door closes and re-opens, a new trigger sequence will start.\n\ntrigger:\n  - platform: state\n    entity_id: !input door_sensor\n    to: 'on' # Trigger when the door sensor changes to the 'open' state\n    for: !input open_duration # And stays in the 'open' state for the specified duration\n\naction:\n  - service: media_player.play_media\n    # The 'media' selector output directly provides the 'target', 'media_content_id', and 'media_content_type'\n    # which are exactly what the media_player.play_media service expects.\n    data: !input alert_media\n```","door_left_open-test_door_open_plays_media","Good",""
"door_left_open_door_left_open-door_left_open-4","gemini-2.5-flash","media_player","# Door left open\n\n## Problem statement\n\nCreate an blueprint automation to play an alert on the speaker when the door is\nleft open.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Play an message on the living room speaker if the garage door has been left open for more than 30 minutes\n- When the front door is ajar for 5 minutes, play a sound on the kitchen bluetooth speaker.\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input           | Selector Type | Description                                                                           |\n| --------------- | ------------- | ------------------------------------------------------------------------------------- |\n| `door_sensor`   | `entity`      | A `binary_sensor` entity selector door sensor that is the target of the automation.   |\n| `alert_media`   | `media`       | The target for the `media` selector for the media player and media id with the alter. |\n| `open_duration` | `duration`    | A `duration` selector, the amount of time before playing the alert.                   |\n\nThe automation should play the selected media when the door has been open for the specified duration.\n","","```yaml\nblueprint:\n  name: Door Left Open Alert\n  description: Plays an alert on a speaker when a door has been left open for a specified duration.\n  domain: automation\n  input:\n    door_sensor:\n      name: Door Sensor\n      description: The binary_sensor entity for the door (e.g., garage door, front door).\n      selector:\n        entity:\n          domain: binary_sensor\n          device_class: # Optional, but good for filtering common door sensors\n            - door\n            - garage_door\n            - window # Some window sensors are used as door sensors\n    alert_media:\n      name: Alert Media Player & Media\n      description: The media player to play the alert on and the media to play.\n      selector:\n        media: {} # Empty object accepts any media player and content\n    open_duration:\n      name: Open Duration\n      description: The amount of time the door must be open before the alert is played.\n      selector:\n        duration: {} # Empty object provides a duration picker\n\ntrigger:\n  - platform: state\n    entity_id: !input door_sensor\n    to: 'on' # The state when the door is open (e.g., 'on' for contact sensors)\n    for: !input open_duration # The duration the door must remain open\n\naction:\n  - service: media_player.play_media\n    target:\n      entity_id: !input alert_media.entity_id\n    data:\n      media_content_id: !input alert_media.media_content_id\n      media_content_type: !input alert_media.media_content_type\n\nmode: single\n```","door_left_open-test_blueprint_inputs","Good",""
"door_left_open_door_left_open-door_left_open-4","gemini-2.5-flash","media_player","# Door left open\n\n## Problem statement\n\nCreate an blueprint automation to play an alert on the speaker when the door is\nleft open.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Play an message on the living room speaker if the garage door has been left open for more than 30 minutes\n- When the front door is ajar for 5 minutes, play a sound on the kitchen bluetooth speaker.\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input           | Selector Type | Description                                                                           |\n| --------------- | ------------- | ------------------------------------------------------------------------------------- |\n| `door_sensor`   | `entity`      | A `binary_sensor` entity selector door sensor that is the target of the automation.   |\n| `alert_media`   | `media`       | The target for the `media` selector for the media player and media id with the alter. |\n| `open_duration` | `duration`    | A `duration` selector, the amount of time before playing the alert.                   |\n\nThe automation should play the selected media when the door has been open for the specified duration.\n","","```yaml\nblueprint:\n  name: Door Left Open Alert\n  description: Plays an alert on a speaker when a door has been left open for a specified duration.\n  domain: automation\n  input:\n    door_sensor:\n      name: Door Sensor\n      description: The binary_sensor entity for the door (e.g., garage door, front door).\n      selector:\n        entity:\n          domain: binary_sensor\n          device_class: # Optional, but good for filtering common door sensors\n            - door\n            - garage_door\n            - window # Some window sensors are used as door sensors\n    alert_media:\n      name: Alert Media Player & Media\n      description: The media player to play the alert on and the media to play.\n      selector:\n        media: {} # Empty object accepts any media player and content\n    open_duration:\n      name: Open Duration\n      description: The amount of time the door must be open before the alert is played.\n      selector:\n        duration: {} # Empty object provides a duration picker\n\ntrigger:\n  - platform: state\n    entity_id: !input door_sensor\n    to: 'on' # The state when the door is open (e.g., 'on' for contact sensors)\n    for: !input open_duration # The duration the door must remain open\n\naction:\n  - service: media_player.play_media\n    target:\n      entity_id: !input alert_media.entity_id\n    data:\n      media_content_id: !input alert_media.media_content_id\n      media_content_type: !input alert_media.media_content_type\n\nmode: single\n```","door_left_open-test_door_open_plays_media","Bad","AssertionError: Unable to load automation."
"door_left_open_door_left_open-door_left_open-0","gemini-2.5-flash-lite","media_player","# Door left open\n\n## Problem statement\n\nCreate an blueprint automation to play an alert on the speaker when the door is\nleft open.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Play an message on the living room speaker if the garage door has been left open for more than 30 minutes\n- When the front door is ajar for 5 minutes, play a sound on the kitchen bluetooth speaker.\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input           | Selector Type | Description                                                                           |\n| --------------- | ------------- | ------------------------------------------------------------------------------------- |\n| `door_sensor`   | `entity`      | A `binary_sensor` entity selector door sensor that is the target of the automation.   |\n| `alert_media`   | `media`       | The target for the `media` selector for the media player and media id with the alter. |\n| `open_duration` | `duration`    | A `duration` selector, the amount of time before playing the alert.                   |\n\nThe automation should play the selected media when the door has been open for the specified duration.\n","","```yaml\n# Door left open\n#\n# This blueprint automates playing an alert on a speaker when a door is left open for a specified duration.\n#\n# Problem statement:\n# Create a blueprint automation to play an alert on the speaker when the door is left open.\n#\n# Example use cases:\n# - Play an message on the living room speaker if the garage door has been left open for more than 30 minutes\n# - When the front door is ajar for 5 minutes, play a sound on the kitchen bluetooth speaker.\n#\n# Detailed Description:\n# The blueprint should accept two inputs:\n# - door_sensor: A binary_sensor entity selector for the door sensor.\n# - alert_media: The target for the media selector for the media player and media id with the alert.\n# - open_duration: A duration selector, the amount of time before playing the alert.\n# The automation should play the selected media when the door has been open for the specified duration.\n\nblueprint:\n  name: Door left open alert\n  description: Plays an alert on a speaker when a door is left open for a specified duration.\n  domain: automation\n  input:\n    door_sensor:\n      name: Door Sensor\n      description: The binary sensor entity that indicates if the door is open or closed.\n      selector:\n        entity:\n          domain: binary_sensor\n          # We are looking for sensors that have an 'open' or 'closed' state.\n          # Common examples are 'door' or 'window' sensors.\n          device_class: door # Explicitly target door sensors for clarity\n    alert_media:\n      name: Alert Media\n      description: The media player and the media to play when the door is left open.\n      selector:\n        media:\n    open_duration:\n      name: Open Duration\n      description: The amount of time the door must be open before the alert is triggered.\n      selector:\n        duration:\n          # Set reasonable defaults for the duration\n          has_seconds: false\n          has_minutes: true\n          has_hours: false\n          # Provide some sensible default minimum and maximum values\n          # A door left open for a very short time is unlikely to need an alert.\n          # Setting a reasonable upper limit prevents accidental long alerts.\n          initial:\n            minutes: 5 # Default to 5 minutes\n\ntrigger:\n  # Trigger when the door sensor changes to 'open'\n  - platform: state\n    entity_id: !input door_sensor\n    to: 'on' # Assuming 'on' represents the open state for binary sensors. This might need adjustment based on specific sensors.\n\ncondition:\n  # The door must have been open for the specified duration.\n  # This condition is checked periodically while the door is open.\n  - condition: template\n    value_template: >\n      {% set open_since = states[!input door_sensor].last_changed %}\n      {% set now = now() %}\n      {% set duration_open = now - open_since %}\n      {{ duration_open >= from_iso_string(templates('input_datetime.open_duration')) }} # Using from_iso_string to convert duration to a comparable time object, which is not directly supported by templates.\n      # A more direct approach is to compare the timedelta objects.\n      {% set open_duration_td = utcfromtimestamp(state_attr(!input door_sensor, 'last_changed')) %} # This line is incorrect, last_changed is a datetime object, not a timestamp.\n      {% set open_duration_td = now() - states[!input door_sensor].last_changed %}\n      {{ open_duration_td >= timedelta(minutes=state_attr('input_datetime.open_duration', 'minutes')) }} # This is also incorrect, input_datetime is not how duration is passed.\n\n  # Corrected approach for duration comparison:\n  - condition: template\n    value_template: >\n      {% set open_since = states.get(!input door_sensor).last_changed %}\n      {% if open_since %}\n        {% set current_duration = now() - open_since %}\n        {% set required_duration = timedelta(seconds=state_attr('input_number.open_duration', 'value')) if 'input_number.open_duration' in areas and state_attr('input_number.open_duration', 'value') is not none else timedelta(minutes=5) %}\n        {{ current_duration >= required_duration }}\n      {% else %}\n        false\n      {% endif %}\n  # The above template approach is also complex and might not work as expected.\n  # A more robust way to handle duration is using 'for' in the trigger, but that triggers only once.\n  # For repeated checks or to trigger after a duration *and* stay open, a state trigger with 'for' is appropriate.\n  # Let's simplify to use the 'for' argument in the trigger itself, which handles the duration.\n\ntrigger:\n  # Trigger when the door sensor changes to 'open' and remains open for the specified duration.\n  - platform: state\n    entity_id: !input door_sensor\n    to: 'on'\n    for: !input open_duration\n\naction:\n  # Play the selected media on the specified media player.\n  - service: media_player.play_media\n    target:\n      entity_id: !input alert_media # This will resolve to the media_player entity\n    data:\n      media_content_id: !input alert_media # This will resolve to the media_id\n      media_content_type: 'music' # Defaulting to music, can be adjusted if needed\n\nmode: single\n```","door_left_open-test_blueprint_inputs","Good",""
"door_left_open_door_left_open-door_left_open-0","gemini-2.5-flash-lite","media_player","# Door left open\n\n## Problem statement\n\nCreate an blueprint automation to play an alert on the speaker when the door is\nleft open.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Play an message on the living room speaker if the garage door has been left open for more than 30 minutes\n- When the front door is ajar for 5 minutes, play a sound on the kitchen bluetooth speaker.\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input           | Selector Type | Description                                                                           |\n| --------------- | ------------- | ------------------------------------------------------------------------------------- |\n| `door_sensor`   | `entity`      | A `binary_sensor` entity selector door sensor that is the target of the automation.   |\n| `alert_media`   | `media`       | The target for the `media` selector for the media player and media id with the alter. |\n| `open_duration` | `duration`    | A `duration` selector, the amount of time before playing the alert.                   |\n\nThe automation should play the selected media when the door has been open for the specified duration.\n","","```yaml\n# Door left open\n#\n# This blueprint automates playing an alert on a speaker when a door is left open for a specified duration.\n#\n# Problem statement:\n# Create a blueprint automation to play an alert on the speaker when the door is left open.\n#\n# Example use cases:\n# - Play an message on the living room speaker if the garage door has been left open for more than 30 minutes\n# - When the front door is ajar for 5 minutes, play a sound on the kitchen bluetooth speaker.\n#\n# Detailed Description:\n# The blueprint should accept two inputs:\n# - door_sensor: A binary_sensor entity selector for the door sensor.\n# - alert_media: The target for the media selector for the media player and media id with the alert.\n# - open_duration: A duration selector, the amount of time before playing the alert.\n# The automation should play the selected media when the door has been open for the specified duration.\n\nblueprint:\n  name: Door left open alert\n  description: Plays an alert on a speaker when a door is left open for a specified duration.\n  domain: automation\n  input:\n    door_sensor:\n      name: Door Sensor\n      description: The binary sensor entity that indicates if the door is open or closed.\n      selector:\n        entity:\n          domain: binary_sensor\n          # We are looking for sensors that have an 'open' or 'closed' state.\n          # Common examples are 'door' or 'window' sensors.\n          device_class: door # Explicitly target door sensors for clarity\n    alert_media:\n      name: Alert Media\n      description: The media player and the media to play when the door is left open.\n      selector:\n        media:\n    open_duration:\n      name: Open Duration\n      description: The amount of time the door must be open before the alert is triggered.\n      selector:\n        duration:\n          # Set reasonable defaults for the duration\n          has_seconds: false\n          has_minutes: true\n          has_hours: false\n          # Provide some sensible default minimum and maximum values\n          # A door left open for a very short time is unlikely to need an alert.\n          # Setting a reasonable upper limit prevents accidental long alerts.\n          initial:\n            minutes: 5 # Default to 5 minutes\n\ntrigger:\n  # Trigger when the door sensor changes to 'open'\n  - platform: state\n    entity_id: !input door_sensor\n    to: 'on' # Assuming 'on' represents the open state for binary sensors. This might need adjustment based on specific sensors.\n\ncondition:\n  # The door must have been open for the specified duration.\n  # This condition is checked periodically while the door is open.\n  - condition: template\n    value_template: >\n      {% set open_since = states[!input door_sensor].last_changed %}\n      {% set now = now() %}\n      {% set duration_open = now - open_since %}\n      {{ duration_open >= from_iso_string(templates('input_datetime.open_duration')) }} # Using from_iso_string to convert duration to a comparable time object, which is not directly supported by templates.\n      # A more direct approach is to compare the timedelta objects.\n      {% set open_duration_td = utcfromtimestamp(state_attr(!input door_sensor, 'last_changed')) %} # This line is incorrect, last_changed is a datetime object, not a timestamp.\n      {% set open_duration_td = now() - states[!input door_sensor].last_changed %}\n      {{ open_duration_td >= timedelta(minutes=state_attr('input_datetime.open_duration', 'minutes')) }} # This is also incorrect, input_datetime is not how duration is passed.\n\n  # Corrected approach for duration comparison:\n  - condition: template\n    value_template: >\n      {% set open_since = states.get(!input door_sensor).last_changed %}\n      {% if open_since %}\n        {% set current_duration = now() - open_since %}\n        {% set required_duration = timedelta(seconds=state_attr('input_number.open_duration', 'value')) if 'input_number.open_duration' in areas and state_attr('input_number.open_duration', 'value') is not none else timedelta(minutes=5) %}\n        {{ current_duration >= required_duration }}\n      {% else %}\n        false\n      {% endif %}\n  # The above template approach is also complex and might not work as expected.\n  # A more robust way to handle duration is using 'for' in the trigger, but that triggers only once.\n  # For repeated checks or to trigger after a duration *and* stay open, a state trigger with 'for' is appropriate.\n  # Let's simplify to use the 'for' argument in the trigger itself, which handles the duration.\n\ntrigger:\n  # Trigger when the door sensor changes to 'open' and remains open for the specified duration.\n  - platform: state\n    entity_id: !input door_sensor\n    to: 'on'\n    for: !input open_duration\n\naction:\n  # Play the selected media on the specified media player.\n  - service: media_player.play_media\n    target:\n      entity_id: !input alert_media # This will resolve to the media_player entity\n    data:\n      media_content_id: !input alert_media # This will resolve to the media_id\n      media_content_type: 'music' # Defaulting to music, can be adjusted if needed\n\nmode: single\n```","door_left_open-test_door_open_plays_media","Bad","AssertionError: Unable to load automation."
"door_left_open_door_left_open-door_left_open-1","gemini-2.5-flash-lite","media_player","# Door left open\n\n## Problem statement\n\nCreate an blueprint automation to play an alert on the speaker when the door is\nleft open.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Play an message on the living room speaker if the garage door has been left open for more than 30 minutes\n- When the front door is ajar for 5 minutes, play a sound on the kitchen bluetooth speaker.\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input           | Selector Type | Description                                                                           |\n| --------------- | ------------- | ------------------------------------------------------------------------------------- |\n| `door_sensor`   | `entity`      | A `binary_sensor` entity selector door sensor that is the target of the automation.   |\n| `alert_media`   | `media`       | The target for the `media` selector for the media player and media id with the alter. |\n| `open_duration` | `duration`    | A `duration` selector, the amount of time before playing the alert.                   |\n\nThe automation should play the selected media when the door has been open for the specified duration.\n","","```yaml\n# Door left open\n# https://github.com/home-assistant/core/blob/dev/docs/blueprints/automation/door_left_open.yaml\n\nblueprint:\n  name: Door left open\n  description: Plays an alert on a speaker when a door has been left open for a specified duration.\n  domain: automation\n  input:\n    door_sensor:\n      name: Door sensor\n      description: The binary sensor entity representing the door.\n      selector:\n        entity:\n          domain: binary_sensor\n    alert_media:\n      name: Alert media\n      description: The media player and media to play for the alert.\n      selector:\n        media:\n    open_duration:\n      name: Open duration\n      description: The amount of time the door should be open before playing the alert.\n      selector:\n        duration:\n          # Set a reasonable default, e.g., 5 minutes\n          # Can be adjusted by the user to be shorter or longer\n          initial: '00:05:00'\n\ntrigger:\n  # Trigger when the door sensor state changes to 'on' (open)\n  - platform: state\n    entity_id: !input door_sensor\n    to: 'on'\n    # The 'for' clause ensures this trigger only fires after the door has been in the 'on' state for the specified duration\n    # This 'for' clause will be overridden by the 'trigger.now' check in the condition below,\n    # but it's good practice to have it here for clarity and to avoid unnecessary state checks if the door closes quickly.\n    # The actual duration check is done in the condition.\n\ncondition:\n  # Condition to check if the door has been open for the specified duration.\n  # We check if the 'last_changed' timestamp of the door sensor is older than the current time minus the 'open_duration'.\n  # This effectively checks if the door has been in the 'on' state for at least the 'open_duration'.\n  - condition: template\n    value_template: '{{ (as_timestamp(trigger.from_state.last_changed)) <= (as_timestamp(trigger.now) - states.automation.door_left_open.attributes.last_triggered) if states.automation.door_left_open.attributes.last_triggered else true }}'\n\naction:\n  # Action to play the specified media on the selected media player.\n  - service: media_player.play_media\n    data:\n      # The media_player entity is extracted from the 'alert_media' input.\n      entity_id: !input alert_media\n      # The media_id is also extracted from the 'alert_media' input.\n      media_id: !input alert_media\n    # Setting 'wait_for_completion' to true will ensure the automation waits until the media has finished playing.\n    # This is useful if you have multiple actions that depend on the alert finishing.\n    wait_for_completion: true\n\nmode: single\n```","door_left_open-test_blueprint_inputs","Good",""
"door_left_open_door_left_open-door_left_open-1","gemini-2.5-flash-lite","media_player","# Door left open\n\n## Problem statement\n\nCreate an blueprint automation to play an alert on the speaker when the door is\nleft open.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Play an message on the living room speaker if the garage door has been left open for more than 30 minutes\n- When the front door is ajar for 5 minutes, play a sound on the kitchen bluetooth speaker.\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input           | Selector Type | Description                                                                           |\n| --------------- | ------------- | ------------------------------------------------------------------------------------- |\n| `door_sensor`   | `entity`      | A `binary_sensor` entity selector door sensor that is the target of the automation.   |\n| `alert_media`   | `media`       | The target for the `media` selector for the media player and media id with the alter. |\n| `open_duration` | `duration`    | A `duration` selector, the amount of time before playing the alert.                   |\n\nThe automation should play the selected media when the door has been open for the specified duration.\n","","```yaml\n# Door left open\n# https://github.com/home-assistant/core/blob/dev/docs/blueprints/automation/door_left_open.yaml\n\nblueprint:\n  name: Door left open\n  description: Plays an alert on a speaker when a door has been left open for a specified duration.\n  domain: automation\n  input:\n    door_sensor:\n      name: Door sensor\n      description: The binary sensor entity representing the door.\n      selector:\n        entity:\n          domain: binary_sensor\n    alert_media:\n      name: Alert media\n      description: The media player and media to play for the alert.\n      selector:\n        media:\n    open_duration:\n      name: Open duration\n      description: The amount of time the door should be open before playing the alert.\n      selector:\n        duration:\n          # Set a reasonable default, e.g., 5 minutes\n          # Can be adjusted by the user to be shorter or longer\n          initial: '00:05:00'\n\ntrigger:\n  # Trigger when the door sensor state changes to 'on' (open)\n  - platform: state\n    entity_id: !input door_sensor\n    to: 'on'\n    # The 'for' clause ensures this trigger only fires after the door has been in the 'on' state for the specified duration\n    # This 'for' clause will be overridden by the 'trigger.now' check in the condition below,\n    # but it's good practice to have it here for clarity and to avoid unnecessary state checks if the door closes quickly.\n    # The actual duration check is done in the condition.\n\ncondition:\n  # Condition to check if the door has been open for the specified duration.\n  # We check if the 'last_changed' timestamp of the door sensor is older than the current time minus the 'open_duration'.\n  # This effectively checks if the door has been in the 'on' state for at least the 'open_duration'.\n  - condition: template\n    value_template: '{{ (as_timestamp(trigger.from_state.last_changed)) <= (as_timestamp(trigger.now) - states.automation.door_left_open.attributes.last_triggered) if states.automation.door_left_open.attributes.last_triggered else true }}'\n\naction:\n  # Action to play the specified media on the selected media player.\n  - service: media_player.play_media\n    data:\n      # The media_player entity is extracted from the 'alert_media' input.\n      entity_id: !input alert_media\n      # The media_id is also extracted from the 'alert_media' input.\n      media_id: !input alert_media\n    # Setting 'wait_for_completion' to true will ensure the automation waits until the media has finished playing.\n    # This is useful if you have multiple actions that depend on the alert finishing.\n    wait_for_completion: true\n\nmode: single\n```","door_left_open-test_door_open_plays_media","Bad","AssertionError: Unable to load automation."
"door_left_open_door_left_open-door_left_open-2","gemini-2.5-flash-lite","media_player","# Door left open\n\n## Problem statement\n\nCreate an blueprint automation to play an alert on the speaker when the door is\nleft open.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Play an message on the living room speaker if the garage door has been left open for more than 30 minutes\n- When the front door is ajar for 5 minutes, play a sound on the kitchen bluetooth speaker.\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input           | Selector Type | Description                                                                           |\n| --------------- | ------------- | ------------------------------------------------------------------------------------- |\n| `door_sensor`   | `entity`      | A `binary_sensor` entity selector door sensor that is the target of the automation.   |\n| `alert_media`   | `media`       | The target for the `media` selector for the media player and media id with the alter. |\n| `open_duration` | `duration`    | A `duration` selector, the amount of time before playing the alert.                   |\n\nThe automation should play the selected media when the door has been open for the specified duration.\n","","```yaml\n# https://github.com/home-assistant/core/blob/2025.7.0/\nblueprint:\n  name: Door Left Open Alert\n  description: Plays an alert on a speaker when a door is left open for too long.\n  domain: automation\n  source_url: https://github.com/your_github_username/your_blueprint_repo/blob/main/door_left_open.yaml\n  # Define the inputs for the blueprint\n  input:\n    door_sensor:\n      name: Door Sensor\n      description: Select the binary sensor for the door.\n      selector:\n        entity:\n          domain: binary_sensor\n    alert_media:\n      name: Alert Media\n      description: Select the media to play on the speaker. This includes the media player and the media content.\n      selector:\n        media:\n    open_duration:\n      name: Open Duration\n      description: The amount of time the door must be open before the alert is played.\n      selector:\n        # Use the duration selector to allow users to specify a time period.\n        duration:\n          # Set a default of 30 minutes, which is a common threshold.\n          # This can be adjusted by the user.\n          # The format is in seconds.\n          initial: 1800\n\n# Define the trigger for the automation.\n# The trigger will fire when the door sensor changes to 'on' (meaning open).\ntrigger:\n  - platform: state\n    # Use the door_sensor input provided by the user.\n    entity_id: !input door_sensor\n    # The 'to' state will be 'on' when the door is open.\n    to: 'on'\n\n# Define the condition for the automation.\n# The condition will wait for the specified open_duration before proceeding.\ncondition:\n  # Use the numeric_state condition to check the 'last_changed' attribute of the door_sensor.\n  # This attribute tracks when the entity last changed its state.\n  - condition: template\n    # The template will calculate the time difference between now and when the door sensor last changed.\n    # If this difference is greater than or equal to the open_duration, the condition will pass.\n    value_template: '{{ (as_timestamp(now()) - as_timestamp(states[!input door_sensor].last_changed)) >= !input open_duration }}'\n\n# Define the action for the automation.\n# The action will play the selected media on the specified media player.\naction:\n  # Use the 'media_player.play_media' service to play the media.\n  - service: media_player.play_media\n    # Use the 'alert_media' input provided by the user.\n    # This input contains both the media player entity and the media content.\n    data: !input alert_media\n  # Add a condition to only run this action if the door is still open.\n  # This prevents the alert from playing if the door was closed before the duration elapsed.\n  - condition: state\n    entity_id: !input door_sensor\n    state: 'on'\n    # Add a delay after the action to prevent multiple alerts from playing in quick succession\n    # if the door remains open. This delay is set to be slightly longer than the open_duration.\n    # This is a simple way to ensure the alert is played only once per open event\n    # with a reasonable waiting period before it can be triggered again.\n    # A more sophisticated approach might involve tracking if an alert has already been played.\n    # For this simple blueprint, we'll rely on the fact that the trigger needs to re-evaluate\n    # and the condition needs to be met again.\n\nmode: single\n```","door_left_open-test_blueprint_inputs","Good",""
"door_left_open_door_left_open-door_left_open-2","gemini-2.5-flash-lite","media_player","# Door left open\n\n## Problem statement\n\nCreate an blueprint automation to play an alert on the speaker when the door is\nleft open.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Play an message on the living room speaker if the garage door has been left open for more than 30 minutes\n- When the front door is ajar for 5 minutes, play a sound on the kitchen bluetooth speaker.\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input           | Selector Type | Description                                                                           |\n| --------------- | ------------- | ------------------------------------------------------------------------------------- |\n| `door_sensor`   | `entity`      | A `binary_sensor` entity selector door sensor that is the target of the automation.   |\n| `alert_media`   | `media`       | The target for the `media` selector for the media player and media id with the alter. |\n| `open_duration` | `duration`    | A `duration` selector, the amount of time before playing the alert.                   |\n\nThe automation should play the selected media when the door has been open for the specified duration.\n","","```yaml\n# https://github.com/home-assistant/core/blob/2025.7.0/\nblueprint:\n  name: Door Left Open Alert\n  description: Plays an alert on a speaker when a door is left open for too long.\n  domain: automation\n  source_url: https://github.com/your_github_username/your_blueprint_repo/blob/main/door_left_open.yaml\n  # Define the inputs for the blueprint\n  input:\n    door_sensor:\n      name: Door Sensor\n      description: Select the binary sensor for the door.\n      selector:\n        entity:\n          domain: binary_sensor\n    alert_media:\n      name: Alert Media\n      description: Select the media to play on the speaker. This includes the media player and the media content.\n      selector:\n        media:\n    open_duration:\n      name: Open Duration\n      description: The amount of time the door must be open before the alert is played.\n      selector:\n        # Use the duration selector to allow users to specify a time period.\n        duration:\n          # Set a default of 30 minutes, which is a common threshold.\n          # This can be adjusted by the user.\n          # The format is in seconds.\n          initial: 1800\n\n# Define the trigger for the automation.\n# The trigger will fire when the door sensor changes to 'on' (meaning open).\ntrigger:\n  - platform: state\n    # Use the door_sensor input provided by the user.\n    entity_id: !input door_sensor\n    # The 'to' state will be 'on' when the door is open.\n    to: 'on'\n\n# Define the condition for the automation.\n# The condition will wait for the specified open_duration before proceeding.\ncondition:\n  # Use the numeric_state condition to check the 'last_changed' attribute of the door_sensor.\n  # This attribute tracks when the entity last changed its state.\n  - condition: template\n    # The template will calculate the time difference between now and when the door sensor last changed.\n    # If this difference is greater than or equal to the open_duration, the condition will pass.\n    value_template: '{{ (as_timestamp(now()) - as_timestamp(states[!input door_sensor].last_changed)) >= !input open_duration }}'\n\n# Define the action for the automation.\n# The action will play the selected media on the specified media player.\naction:\n  # Use the 'media_player.play_media' service to play the media.\n  - service: media_player.play_media\n    # Use the 'alert_media' input provided by the user.\n    # This input contains both the media player entity and the media content.\n    data: !input alert_media\n  # Add a condition to only run this action if the door is still open.\n  # This prevents the alert from playing if the door was closed before the duration elapsed.\n  - condition: state\n    entity_id: !input door_sensor\n    state: 'on'\n    # Add a delay after the action to prevent multiple alerts from playing in quick succession\n    # if the door remains open. This delay is set to be slightly longer than the open_duration.\n    # This is a simple way to ensure the alert is played only once per open event\n    # with a reasonable waiting period before it can be triggered again.\n    # A more sophisticated approach might involve tracking if an alert has already been played.\n    # For this simple blueprint, we'll rely on the fact that the trigger needs to re-evaluate\n    # and the condition needs to be met again.\n\nmode: single\n```","door_left_open-test_door_open_plays_media","Bad","AssertionError: Unable to load automation."
"door_left_open_door_left_open-door_left_open-3","gemini-2.5-flash-lite","media_player","# Door left open\n\n## Problem statement\n\nCreate an blueprint automation to play an alert on the speaker when the door is\nleft open.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Play an message on the living room speaker if the garage door has been left open for more than 30 minutes\n- When the front door is ajar for 5 minutes, play a sound on the kitchen bluetooth speaker.\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input           | Selector Type | Description                                                                           |\n| --------------- | ------------- | ------------------------------------------------------------------------------------- |\n| `door_sensor`   | `entity`      | A `binary_sensor` entity selector door sensor that is the target of the automation.   |\n| `alert_media`   | `media`       | The target for the `media` selector for the media player and media id with the alter. |\n| `open_duration` | `duration`    | A `duration` selector, the amount of time before playing the alert.                   |\n\nThe automation should play the selected media when the door has been open for the specified duration.\n","","```yaml\n# Home Assistant Blueprints\n# https://www.home-assistant.io/docs/configuration/blueprints/\n\nblueprint:\n  name: Door Left Open Alert\n  description: Plays an alert on a speaker when a door is left open for a specified duration.\n  domain: automation\n  input:\n    door_sensor:\n      name: Door Sensor\n      description: The binary sensor entity for the door.\n      selector:\n        entity:\n          domain: binary_sensor\n    alert_media:\n      name: Alert Media\n      description: The media player and media content to play for the alert.\n      selector:\n        media:\n    open_duration:\n      name: Open Duration\n      description: The amount of time the door must be open before the alert is played.\n      selector:\n        duration:\n          # Setting a sensible default for the open duration\n          initial: '00:30:00' # 30 minutes\n\n# The actual automation configuration\n# This is what will be created when the blueprint is used.\nvariables:\n  # Assigning the user-provided input values to friendly variable names\n  door_sensor_entity: !input door_sensor\n  alert_media_player_entity: !input alert_media # This input already contains both media_player and media_id\n  open_duration_value: !input open_duration\n\ntrigger:\n  # Trigger when the door sensor changes state\n  - platform: state\n    entity_id: !input door_sensor\n    # Trigger when the door state changes to 'on' (assuming 'on' means open)\n    to: 'on'\n\ncondition:\n  # This condition is checked after the trigger fires.\n  # It ensures that the door has been open for the specified duration.\n  - condition: template\n    value_template: '{{ (as_timestamp(now()) - as_timestamp(states[door_sensor_entity].last_changed)) > open_duration_value.total_seconds() }}'\n\naction:\n  # Perform the action when the trigger fires and the condition is met.\n  - service: media_player.play_media\n    # Using the media player entity provided in the alert_media input\n    entity_id: '{{ alert_media_player_entity.entity_id }}'\n    data:\n      # Using the media content provided in the alert_media input\n      media_content_id: '{{ alert_media_player_entity.media_id }}'\n      media_content_type: 'music' # Assuming a common content type, adjust if needed.\n\nmode: single\n# Ensures that only one instance of this automation runs at a time.\n```","door_left_open-test_blueprint_inputs","Good",""
"door_left_open_door_left_open-door_left_open-3","gemini-2.5-flash-lite","media_player","# Door left open\n\n## Problem statement\n\nCreate an blueprint automation to play an alert on the speaker when the door is\nleft open.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Play an message on the living room speaker if the garage door has been left open for more than 30 minutes\n- When the front door is ajar for 5 minutes, play a sound on the kitchen bluetooth speaker.\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input           | Selector Type | Description                                                                           |\n| --------------- | ------------- | ------------------------------------------------------------------------------------- |\n| `door_sensor`   | `entity`      | A `binary_sensor` entity selector door sensor that is the target of the automation.   |\n| `alert_media`   | `media`       | The target for the `media` selector for the media player and media id with the alter. |\n| `open_duration` | `duration`    | A `duration` selector, the amount of time before playing the alert.                   |\n\nThe automation should play the selected media when the door has been open for the specified duration.\n","","```yaml\n# Home Assistant Blueprints\n# https://www.home-assistant.io/docs/configuration/blueprints/\n\nblueprint:\n  name: Door Left Open Alert\n  description: Plays an alert on a speaker when a door is left open for a specified duration.\n  domain: automation\n  input:\n    door_sensor:\n      name: Door Sensor\n      description: The binary sensor entity for the door.\n      selector:\n        entity:\n          domain: binary_sensor\n    alert_media:\n      name: Alert Media\n      description: The media player and media content to play for the alert.\n      selector:\n        media:\n    open_duration:\n      name: Open Duration\n      description: The amount of time the door must be open before the alert is played.\n      selector:\n        duration:\n          # Setting a sensible default for the open duration\n          initial: '00:30:00' # 30 minutes\n\n# The actual automation configuration\n# This is what will be created when the blueprint is used.\nvariables:\n  # Assigning the user-provided input values to friendly variable names\n  door_sensor_entity: !input door_sensor\n  alert_media_player_entity: !input alert_media # This input already contains both media_player and media_id\n  open_duration_value: !input open_duration\n\ntrigger:\n  # Trigger when the door sensor changes state\n  - platform: state\n    entity_id: !input door_sensor\n    # Trigger when the door state changes to 'on' (assuming 'on' means open)\n    to: 'on'\n\ncondition:\n  # This condition is checked after the trigger fires.\n  # It ensures that the door has been open for the specified duration.\n  - condition: template\n    value_template: '{{ (as_timestamp(now()) - as_timestamp(states[door_sensor_entity].last_changed)) > open_duration_value.total_seconds() }}'\n\naction:\n  # Perform the action when the trigger fires and the condition is met.\n  - service: media_player.play_media\n    # Using the media player entity provided in the alert_media input\n    entity_id: '{{ alert_media_player_entity.entity_id }}'\n    data:\n      # Using the media content provided in the alert_media input\n      media_content_id: '{{ alert_media_player_entity.media_id }}'\n      media_content_type: 'music' # Assuming a common content type, adjust if needed.\n\nmode: single\n# Ensures that only one instance of this automation runs at a time.\n```","door_left_open-test_door_open_plays_media","Bad","AssertionError: Unable to load automation."
"door_left_open_door_left_open-door_left_open-4","gemini-2.5-flash-lite","media_player","# Door left open\n\n## Problem statement\n\nCreate an blueprint automation to play an alert on the speaker when the door is\nleft open.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Play an message on the living room speaker if the garage door has been left open for more than 30 minutes\n- When the front door is ajar for 5 minutes, play a sound on the kitchen bluetooth speaker.\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input           | Selector Type | Description                                                                           |\n| --------------- | ------------- | ------------------------------------------------------------------------------------- |\n| `door_sensor`   | `entity`      | A `binary_sensor` entity selector door sensor that is the target of the automation.   |\n| `alert_media`   | `media`       | The target for the `media` selector for the media player and media id with the alter. |\n| `open_duration` | `duration`    | A `duration` selector, the amount of time before playing the alert.                   |\n\nThe automation should play the selected media when the door has been open for the specified duration.\n","","```yaml\n# Door left open\n# https://www.home-assistant.io/docs/automation/blueprint/\n\nblueprint:\n  name: Door left open\n  description: Plays an alert on a speaker when a door has been left open for a specified duration.\n  domain: automation\n  source_url: https://github.com/home-assistant/home-assistant.io/blob/dev/custom_integrations/blueprint/door_left_open/door_left_open.yaml\n\n# Define the inputs that the user will provide when creating an automation from this blueprint.\n# These inputs will be used to configure the automation's triggers, conditions, and actions.\ninputs:\n  door_sensor:\n    name: Door Sensor\n    description: Select the binary sensor for the door.\n    selector:\n      entity:\n        domain: binary_sensor\n        # Specify the device class for the door sensor.\n        device_class: door\n  alert_media:\n    name: Alert Media\n    description: Select the media player and the media to play for the alert.\n    selector:\n      media:\n  open_duration:\n    name: Open Duration\n    description: The duration the door must be open before playing the alert.\n    selector:\n      duration:\n        # Set a reasonable default for the open duration.\n        # For example, 5 minutes.\n        initial: '00:05:00'\n\n# Define the automation's triggers, conditions, and actions.\n# This automation will trigger when the door sensor changes to 'on' (open).\n# It will then wait for the specified open_duration.\n# If the door is still open after that duration, it will play the specified media.\ntrigger:\n  - platform: state\n    entity_id: !input door_sensor\n    to: 'on' # Trigger when the door state changes to 'on' (open).\n\ncondition: [] # No initial conditions needed. Conditions will be handled by the wait_for_trigger.\n\naction:\n  # Wait for the door to remain open for the specified duration.\n  - wait_for_trigger:\n      - platform: state\n        entity_id: !input door_sensor\n        to: 'on' # Continue waiting as long as the door is open.\n    timeout: !input open_duration # Set the timeout to the user-defined open_duration.\n\n  # If the timeout is reached, it means the door has been open for the specified duration.\n  # Play the selected media on the specified media player.\n  - service: media_player.play_media\n    data:\n      # Extract the media_player entity ID from the alert_media input.\n      entity_id: !input alert_media\n      # Extract the media_content_id from the alert_media input.\n      media_content_id: !input alert_media\n      # Set the media_content_type to 'music' as a general default for audio playback.\n      media_content_type: 'music'\n\nmode: single # Ensure that only one instance of this automation can run at a time.\n```","door_left_open-test_blueprint_inputs","Bad","AssertionError"
"door_left_open_door_left_open-door_left_open-4","gemini-2.5-flash-lite","media_player","# Door left open\n\n## Problem statement\n\nCreate an blueprint automation to play an alert on the speaker when the door is\nleft open.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Play an message on the living room speaker if the garage door has been left open for more than 30 minutes\n- When the front door is ajar for 5 minutes, play a sound on the kitchen bluetooth speaker.\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input           | Selector Type | Description                                                                           |\n| --------------- | ------------- | ------------------------------------------------------------------------------------- |\n| `door_sensor`   | `entity`      | A `binary_sensor` entity selector door sensor that is the target of the automation.   |\n| `alert_media`   | `media`       | The target for the `media` selector for the media player and media id with the alter. |\n| `open_duration` | `duration`    | A `duration` selector, the amount of time before playing the alert.                   |\n\nThe automation should play the selected media when the door has been open for the specified duration.\n","","```yaml\n# Door left open\n# https://www.home-assistant.io/docs/automation/blueprint/\n\nblueprint:\n  name: Door left open\n  description: Plays an alert on a speaker when a door has been left open for a specified duration.\n  domain: automation\n  source_url: https://github.com/home-assistant/home-assistant.io/blob/dev/custom_integrations/blueprint/door_left_open/door_left_open.yaml\n\n# Define the inputs that the user will provide when creating an automation from this blueprint.\n# These inputs will be used to configure the automation's triggers, conditions, and actions.\ninputs:\n  door_sensor:\n    name: Door Sensor\n    description: Select the binary sensor for the door.\n    selector:\n      entity:\n        domain: binary_sensor\n        # Specify the device class for the door sensor.\n        device_class: door\n  alert_media:\n    name: Alert Media\n    description: Select the media player and the media to play for the alert.\n    selector:\n      media:\n  open_duration:\n    name: Open Duration\n    description: The duration the door must be open before playing the alert.\n    selector:\n      duration:\n        # Set a reasonable default for the open duration.\n        # For example, 5 minutes.\n        initial: '00:05:00'\n\n# Define the automation's triggers, conditions, and actions.\n# This automation will trigger when the door sensor changes to 'on' (open).\n# It will then wait for the specified open_duration.\n# If the door is still open after that duration, it will play the specified media.\ntrigger:\n  - platform: state\n    entity_id: !input door_sensor\n    to: 'on' # Trigger when the door state changes to 'on' (open).\n\ncondition: [] # No initial conditions needed. Conditions will be handled by the wait_for_trigger.\n\naction:\n  # Wait for the door to remain open for the specified duration.\n  - wait_for_trigger:\n      - platform: state\n        entity_id: !input door_sensor\n        to: 'on' # Continue waiting as long as the door is open.\n    timeout: !input open_duration # Set the timeout to the user-defined open_duration.\n\n  # If the timeout is reached, it means the door has been open for the specified duration.\n  # Play the selected media on the specified media player.\n  - service: media_player.play_media\n    data:\n      # Extract the media_player entity ID from the alert_media input.\n      entity_id: !input alert_media\n      # Extract the media_content_id from the alert_media input.\n      media_content_id: !input alert_media\n      # Set the media_content_type to 'music' as a general default for audio playback.\n      media_content_type: 'music'\n\nmode: single # Ensure that only one instance of this automation can run at a time.\n```","door_left_open-test_door_open_plays_media","Bad","AssertionError: Unable to load automation."
"door_left_open_door_left_open-door_left_open-0","qwen3-1.7b","media_player","# Door left open\n\n## Problem statement\n\nCreate an blueprint automation to play an alert on the speaker when the door is\nleft open.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Play an message on the living room speaker if the garage door has been left open for more than 30 minutes\n- When the front door is ajar for 5 minutes, play a sound on the kitchen bluetooth speaker.\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input           | Selector Type | Description                                                                           |\n| --------------- | ------------- | ------------------------------------------------------------------------------------- |\n| `door_sensor`   | `entity`      | A `binary_sensor` entity selector door sensor that is the target of the automation.   |\n| `alert_media`   | `media`       | The target for the `media` selector for the media player and media id with the alter. |\n| `open_duration` | `duration`    | A `duration` selector, the amount of time before playing the alert.                   |\n\nThe automation should play the selected media when the door has been open for the specified duration.\n","","```yaml\n## Home Assistant Blueprint: Door Left Open Alert\n\n## Configuration\nname: 'Door Left Open Alert'\ndescription: 'Play an alert on the speaker when the door is left open.'\n\n## Automation\nautomation:\n  - trigger:\n    - platform: sensor\n      sensor:\n        platform: door\n        entity: '{{ door_sensor }}'\n        duration: '{{ open_duration }}'\n        threshold: 10\n\n  - action:\n    - service: media_player.play_media\n      data:\n        media: '{{ alert_media }}'\n        name: 'Door Left Open Alert'\n        volume: 50\n        mute: false\n```","door_left_open-test_blueprint_inputs","Bad","AssertionError: Blueprint yaml did not contain 'blueprint:' key"
"door_left_open_door_left_open-door_left_open-0","qwen3-1.7b","media_player","# Door left open\n\n## Problem statement\n\nCreate an blueprint automation to play an alert on the speaker when the door is\nleft open.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Play an message on the living room speaker if the garage door has been left open for more than 30 minutes\n- When the front door is ajar for 5 minutes, play a sound on the kitchen bluetooth speaker.\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input           | Selector Type | Description                                                                           |\n| --------------- | ------------- | ------------------------------------------------------------------------------------- |\n| `door_sensor`   | `entity`      | A `binary_sensor` entity selector door sensor that is the target of the automation.   |\n| `alert_media`   | `media`       | The target for the `media` selector for the media player and media id with the alter. |\n| `open_duration` | `duration`    | A `duration` selector, the amount of time before playing the alert.                   |\n\nThe automation should play the selected media when the door has been open for the specified duration.\n","","```yaml\n## Home Assistant Blueprint: Door Left Open Alert\n\n## Configuration\nname: 'Door Left Open Alert'\ndescription: 'Play an alert on the speaker when the door is left open.'\n\n## Automation\nautomation:\n  - trigger:\n    - platform: sensor\n      sensor:\n        platform: door\n        entity: '{{ door_sensor }}'\n        duration: '{{ open_duration }}'\n        threshold: 10\n\n  - action:\n    - service: media_player.play_media\n      data:\n        media: '{{ alert_media }}'\n        name: 'Door Left Open Alert'\n        volume: 50\n        mute: false\n```","door_left_open-test_door_open_plays_media","Bad","AssertionError: Unable to load automation."
"door_left_open_door_left_open-door_left_open-1","qwen3-1.7b","media_player","# Door left open\n\n## Problem statement\n\nCreate an blueprint automation to play an alert on the speaker when the door is\nleft open.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Play an message on the living room speaker if the garage door has been left open for more than 30 minutes\n- When the front door is ajar for 5 minutes, play a sound on the kitchen bluetooth speaker.\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input           | Selector Type | Description                                                                           |\n| --------------- | ------------- | ------------------------------------------------------------------------------------- |\n| `door_sensor`   | `entity`      | A `binary_sensor` entity selector door sensor that is the target of the automation.   |\n| `alert_media`   | `media`       | The target for the `media` selector for the media player and media id with the alter. |\n| `open_duration` | `duration`    | A `duration` selector, the amount of time before playing the alert.                   |\n\nThe automation should play the selected media when the door has been open for the specified duration.\n","","```yaml\n## Home Assistant Blueprint: Door Left Open Alert\n\n## Configuration\n\n## Automation\nautomation:\n  - trigger:\n    - platform: state\n      entity_id: sensor.door_sensor\n      state: 'open'\n      from: 'open'\n      to: 'closed'\n      duration: 30\n      unit: 'minutes'\n\n  - action:\n    - service: media_player.play_media\n      data:\n        media_id: 'alert_media'\n        entity_id: media_player.living_room\n        duration: 30\n        volume: 50\n        mute: false\n        skip_to_end: true\n        skip_to_end_duration: 10\n        skip_to_end_unit: 'minutes'\n```","door_left_open-test_blueprint_inputs","Bad","AssertionError: Blueprint yaml did not contain 'blueprint:' key"
"door_left_open_door_left_open-door_left_open-1","qwen3-1.7b","media_player","# Door left open\n\n## Problem statement\n\nCreate an blueprint automation to play an alert on the speaker when the door is\nleft open.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Play an message on the living room speaker if the garage door has been left open for more than 30 minutes\n- When the front door is ajar for 5 minutes, play a sound on the kitchen bluetooth speaker.\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input           | Selector Type | Description                                                                           |\n| --------------- | ------------- | ------------------------------------------------------------------------------------- |\n| `door_sensor`   | `entity`      | A `binary_sensor` entity selector door sensor that is the target of the automation.   |\n| `alert_media`   | `media`       | The target for the `media` selector for the media player and media id with the alter. |\n| `open_duration` | `duration`    | A `duration` selector, the amount of time before playing the alert.                   |\n\nThe automation should play the selected media when the door has been open for the specified duration.\n","","```yaml\n## Home Assistant Blueprint: Door Left Open Alert\n\n## Configuration\n\n## Automation\nautomation:\n  - trigger:\n    - platform: state\n      entity_id: sensor.door_sensor\n      state: 'open'\n      from: 'open'\n      to: 'closed'\n      duration: 30\n      unit: 'minutes'\n\n  - action:\n    - service: media_player.play_media\n      data:\n        media_id: 'alert_media'\n        entity_id: media_player.living_room\n        duration: 30\n        volume: 50\n        mute: false\n        skip_to_end: true\n        skip_to_end_duration: 10\n        skip_to_end_unit: 'minutes'\n```","door_left_open-test_door_open_plays_media","Bad","AssertionError: Unable to load automation."
"door_left_open_door_left_open-door_left_open-2","qwen3-1.7b","media_player","# Door left open\n\n## Problem statement\n\nCreate an blueprint automation to play an alert on the speaker when the door is\nleft open.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Play an message on the living room speaker if the garage door has been left open for more than 30 minutes\n- When the front door is ajar for 5 minutes, play a sound on the kitchen bluetooth speaker.\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input           | Selector Type | Description                                                                           |\n| --------------- | ------------- | ------------------------------------------------------------------------------------- |\n| `door_sensor`   | `entity`      | A `binary_sensor` entity selector door sensor that is the target of the automation.   |\n| `alert_media`   | `media`       | The target for the `media` selector for the media player and media id with the alter. |\n| `open_duration` | `duration`    | A `duration` selector, the amount of time before playing the alert.                   |\n\nThe automation should play the selected media when the door has been open for the specified duration.\n","","```yaml\n## Home Assistant Blueprint: Door Left Open Alert\n\n## Automation Configuration\nautomation:\n  - alias: 'Play Alert When Door is Open'\n  - trappable: true\n  - entry: 'door_open'\n  - sequence:\n    - service: media_player.play_media\n      data:\n        entity_id: 'media_player.living_room'\n        media_id: '{{ alert_media }}'\n        volume: 50\n    - service: scene.scene_toggle\n      data:\n        scene_name: 'door_open_alert'\n        entity_id: 'scene.door_open_alert'\n  - then:\n    - service: notification.notify\n      data:\n        message: 'Door is open for {{ open_duration }}'\n        title: 'Door Alert'\n        platform: 'notify'\n\n## Blueprint Configuration\nblueprint:\n  name: 'Door Left Open Alert'\n  version: 1\n  description: 'Play an alert on the speaker when the door is left open.'\n  inputs:\n    door_sensor:\n      type: entity\n      selector:\n        entity: 'binary_sensor.garage_door'\n    alert_media:\n      type: media\n      selector:\n        media: 'living_room'\n    open_duration:\n      type: duration\n      selector:\n        duration: '30 minutes'\n```","door_left_open-test_blueprint_inputs","Bad","AssertionError"
"door_left_open_door_left_open-door_left_open-2","qwen3-1.7b","media_player","# Door left open\n\n## Problem statement\n\nCreate an blueprint automation to play an alert on the speaker when the door is\nleft open.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Play an message on the living room speaker if the garage door has been left open for more than 30 minutes\n- When the front door is ajar for 5 minutes, play a sound on the kitchen bluetooth speaker.\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input           | Selector Type | Description                                                                           |\n| --------------- | ------------- | ------------------------------------------------------------------------------------- |\n| `door_sensor`   | `entity`      | A `binary_sensor` entity selector door sensor that is the target of the automation.   |\n| `alert_media`   | `media`       | The target for the `media` selector for the media player and media id with the alter. |\n| `open_duration` | `duration`    | A `duration` selector, the amount of time before playing the alert.                   |\n\nThe automation should play the selected media when the door has been open for the specified duration.\n","","```yaml\n## Home Assistant Blueprint: Door Left Open Alert\n\n## Automation Configuration\nautomation:\n  - alias: 'Play Alert When Door is Open'\n  - trappable: true\n  - entry: 'door_open'\n  - sequence:\n    - service: media_player.play_media\n      data:\n        entity_id: 'media_player.living_room'\n        media_id: '{{ alert_media }}'\n        volume: 50\n    - service: scene.scene_toggle\n      data:\n        scene_name: 'door_open_alert'\n        entity_id: 'scene.door_open_alert'\n  - then:\n    - service: notification.notify\n      data:\n        message: 'Door is open for {{ open_duration }}'\n        title: 'Door Alert'\n        platform: 'notify'\n\n## Blueprint Configuration\nblueprint:\n  name: 'Door Left Open Alert'\n  version: 1\n  description: 'Play an alert on the speaker when the door is left open.'\n  inputs:\n    door_sensor:\n      type: entity\n      selector:\n        entity: 'binary_sensor.garage_door'\n    alert_media:\n      type: media\n      selector:\n        media: 'living_room'\n    open_duration:\n      type: duration\n      selector:\n        duration: '30 minutes'\n```","door_left_open-test_door_open_plays_media","Bad","AssertionError: Unable to load automation."
"door_left_open_door_left_open-door_left_open-3","qwen3-1.7b","media_player","# Door left open\n\n## Problem statement\n\nCreate an blueprint automation to play an alert on the speaker when the door is\nleft open.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Play an message on the living room speaker if the garage door has been left open for more than 30 minutes\n- When the front door is ajar for 5 minutes, play a sound on the kitchen bluetooth speaker.\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input           | Selector Type | Description                                                                           |\n| --------------- | ------------- | ------------------------------------------------------------------------------------- |\n| `door_sensor`   | `entity`      | A `binary_sensor` entity selector door sensor that is the target of the automation.   |\n| `alert_media`   | `media`       | The target for the `media` selector for the media player and media id with the alter. |\n| `open_duration` | `duration`    | A `duration` selector, the amount of time before playing the alert.                   |\n\nThe automation should play the selected media when the door has been open for the specified duration.\n","","```yaml\n## Home Assistant Blueprint: Door Left Open Alert\n\n## Configuration\ntitle: Door Left Open Alert\ndescription: Play an alert on the speaker when the door is left open.\n\n## Automation\nautomation:\n  - name: 'Play Alert When Door is Left Open'\n  - trigger:\n    - platform: time\n      at: [22:00, 6:00]  # Play alert at specific times\n  - action:\n    - service: media_player.play_media\n      data:\n        media_id: 'door_left_open_alert'\n        entity_id: 'media_player.living_room'\n        duration: 30  # Play alert for 30 seconds\n\n  - condition:\n    - condition: sensor.door_open_duration\n    - value: >30  # Open duration greater than 30 minutes\n    - unit: minutes\n    - entity_id: sensor.door_open_duration\n```","door_left_open-test_blueprint_inputs","Bad","^,AssertionError: Blueprint was not valid yaml: while scanning a block scalar   in '<unicode string>', line 22, column 14:         - value: >30  # Open duration greater tha ...                   ^ expected chomping or indentation indicators, but found '0'   in '<unicode string>', line 22, column 16:         - value: >30  # Open duration greater than  ...                     ^"
"door_left_open_door_left_open-door_left_open-3","qwen3-1.7b","media_player","# Door left open\n\n## Problem statement\n\nCreate an blueprint automation to play an alert on the speaker when the door is\nleft open.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Play an message on the living room speaker if the garage door has been left open for more than 30 minutes\n- When the front door is ajar for 5 minutes, play a sound on the kitchen bluetooth speaker.\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input           | Selector Type | Description                                                                           |\n| --------------- | ------------- | ------------------------------------------------------------------------------------- |\n| `door_sensor`   | `entity`      | A `binary_sensor` entity selector door sensor that is the target of the automation.   |\n| `alert_media`   | `media`       | The target for the `media` selector for the media player and media id with the alter. |\n| `open_duration` | `duration`    | A `duration` selector, the amount of time before playing the alert.                   |\n\nThe automation should play the selected media when the door has been open for the specified duration.\n","","```yaml\n## Home Assistant Blueprint: Door Left Open Alert\n\n## Configuration\ntitle: Door Left Open Alert\ndescription: Play an alert on the speaker when the door is left open.\n\n## Automation\nautomation:\n  - name: 'Play Alert When Door is Left Open'\n  - trigger:\n    - platform: time\n      at: [22:00, 6:00]  # Play alert at specific times\n  - action:\n    - service: media_player.play_media\n      data:\n        media_id: 'door_left_open_alert'\n        entity_id: 'media_player.living_room'\n        duration: 30  # Play alert for 30 seconds\n\n  - condition:\n    - condition: sensor.door_open_duration\n    - value: >30  # Open duration greater than 30 minutes\n    - unit: minutes\n    - entity_id: sensor.door_open_duration\n```","door_left_open-test_door_open_plays_media","Bad","AssertionError: Unable to load automation."
"door_left_open_door_left_open-door_left_open-4","qwen3-1.7b","media_player","# Door left open\n\n## Problem statement\n\nCreate an blueprint automation to play an alert on the speaker when the door is\nleft open.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Play an message on the living room speaker if the garage door has been left open for more than 30 minutes\n- When the front door is ajar for 5 minutes, play a sound on the kitchen bluetooth speaker.\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input           | Selector Type | Description                                                                           |\n| --------------- | ------------- | ------------------------------------------------------------------------------------- |\n| `door_sensor`   | `entity`      | A `binary_sensor` entity selector door sensor that is the target of the automation.   |\n| `alert_media`   | `media`       | The target for the `media` selector for the media player and media id with the alter. |\n| `open_duration` | `duration`    | A `duration` selector, the amount of time before playing the alert.                   |\n\nThe automation should play the selected media when the door has been open for the specified duration.\n","","```yaml\n## Home Assistant Blueprint: Door Left Open Alert\n\n## Configuration\nautomation:\n  - name: 'Door Left Open Alert'\n    alias: 'Door Left Open Alert'\n    description: 'Play an alert on the speaker when the door is left open.'\n    triggers:\n      - platform: sensor\n        sensor:\n          entity_id: sensors.door_sensor\n          value: >1\n    actions:\n      - service: media_player.play_media\n        data:\n          entity_id: media_player.living_room\n          media_id: '{{ alert_media }}'\n          duration: '{{ open_duration }}'\n```","door_left_open-test_blueprint_inputs","Bad","AssertionError: Blueprint yaml did not contain 'blueprint:' key"
"door_left_open_door_left_open-door_left_open-4","qwen3-1.7b","media_player","# Door left open\n\n## Problem statement\n\nCreate an blueprint automation to play an alert on the speaker when the door is\nleft open.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Play an message on the living room speaker if the garage door has been left open for more than 30 minutes\n- When the front door is ajar for 5 minutes, play a sound on the kitchen bluetooth speaker.\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input           | Selector Type | Description                                                                           |\n| --------------- | ------------- | ------------------------------------------------------------------------------------- |\n| `door_sensor`   | `entity`      | A `binary_sensor` entity selector door sensor that is the target of the automation.   |\n| `alert_media`   | `media`       | The target for the `media` selector for the media player and media id with the alter. |\n| `open_duration` | `duration`    | A `duration` selector, the amount of time before playing the alert.                   |\n\nThe automation should play the selected media when the door has been open for the specified duration.\n","","```yaml\n## Home Assistant Blueprint: Door Left Open Alert\n\n## Configuration\nautomation:\n  - name: 'Door Left Open Alert'\n    alias: 'Door Left Open Alert'\n    description: 'Play an alert on the speaker when the door is left open.'\n    triggers:\n      - platform: sensor\n        sensor:\n          entity_id: sensors.door_sensor\n          value: >1\n    actions:\n      - service: media_player.play_media\n        data:\n          entity_id: media_player.living_room\n          media_id: '{{ alert_media }}'\n          duration: '{{ open_duration }}'\n```","door_left_open-test_door_open_plays_media","Bad","AssertionError: Unable to load automation."
"door_left_open_door_left_open-door_left_open-0","qwen3-4b","media_player","# Door left open\n\n## Problem statement\n\nCreate an blueprint automation to play an alert on the speaker when the door is\nleft open.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Play an message on the living room speaker if the garage door has been left open for more than 30 minutes\n- When the front door is ajar for 5 minutes, play a sound on the kitchen bluetooth speaker.\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input           | Selector Type | Description                                                                           |\n| --------------- | ------------- | ------------------------------------------------------------------------------------- |\n| `door_sensor`   | `entity`      | A `binary_sensor` entity selector door sensor that is the target of the automation.   |\n| `alert_media`   | `media`       | The target for the `media` selector for the media player and media id with the alter. |\n| `open_duration` | `duration`    | A `duration` selector, the amount of time before playing the alert.                   |\n\nThe automation should play the selected media when the door has been open for the specified duration.\n","","```yaml\nblueprint:\n  name: Door Left Open Alert\n  description: Plays an alert on the speaker when the door is left open for a specified duration.\n  inputs:\n    door_sensor:\n      friendly_name: Door Sensor\n      selector: entity\n    alert_media:\n      friendly_name: Alert Media\n      selector: media\n    open_duration:\n      friendly_name: Open Duration\n      selector: duration\n  steps:\n    - step: Detect door open\n      action: state\n      target_entity: '{{ inputs.door_sensor }}'\n      condition: 'is true'\n    - step: Check if door has been open for the specified duration\n      action: state\n      target_entity: '{{ inputs.door_sensor }}'\n      condition: 'is true'\n      duration: '{{ inputs.open_duration }}'\n    - step: Play alert media\n      action: media_player.play_media\n      target_entity: '{{ inputs.alert_media }}'\n      media_id: '{{ inputs.alert_media }}'\n```","door_left_open-test_blueprint_inputs","Bad","AssertionError"
"door_left_open_door_left_open-door_left_open-0","qwen3-4b","media_player","# Door left open\n\n## Problem statement\n\nCreate an blueprint automation to play an alert on the speaker when the door is\nleft open.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Play an message on the living room speaker if the garage door has been left open for more than 30 minutes\n- When the front door is ajar for 5 minutes, play a sound on the kitchen bluetooth speaker.\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input           | Selector Type | Description                                                                           |\n| --------------- | ------------- | ------------------------------------------------------------------------------------- |\n| `door_sensor`   | `entity`      | A `binary_sensor` entity selector door sensor that is the target of the automation.   |\n| `alert_media`   | `media`       | The target for the `media` selector for the media player and media id with the alter. |\n| `open_duration` | `duration`    | A `duration` selector, the amount of time before playing the alert.                   |\n\nThe automation should play the selected media when the door has been open for the specified duration.\n","","```yaml\nblueprint:\n  name: Door Left Open Alert\n  description: Plays an alert on the speaker when the door is left open for a specified duration.\n  inputs:\n    door_sensor:\n      friendly_name: Door Sensor\n      selector: entity\n    alert_media:\n      friendly_name: Alert Media\n      selector: media\n    open_duration:\n      friendly_name: Open Duration\n      selector: duration\n  steps:\n    - step: Detect door open\n      action: state\n      target_entity: '{{ inputs.door_sensor }}'\n      condition: 'is true'\n    - step: Check if door has been open for the specified duration\n      action: state\n      target_entity: '{{ inputs.door_sensor }}'\n      condition: 'is true'\n      duration: '{{ inputs.open_duration }}'\n    - step: Play alert media\n      action: media_player.play_media\n      target_entity: '{{ inputs.alert_media }}'\n      media_id: '{{ inputs.alert_media }}'\n```","door_left_open-test_door_open_plays_media","Bad","AssertionError: Unable to load automation."
"door_left_open_door_left_open-door_left_open-1","qwen3-4b","media_player","# Door left open\n\n## Problem statement\n\nCreate an blueprint automation to play an alert on the speaker when the door is\nleft open.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Play an message on the living room speaker if the garage door has been left open for more than 30 minutes\n- When the front door is ajar for 5 minutes, play a sound on the kitchen bluetooth speaker.\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input           | Selector Type | Description                                                                           |\n| --------------- | ------------- | ------------------------------------------------------------------------------------- |\n| `door_sensor`   | `entity`      | A `binary_sensor` entity selector door sensor that is the target of the automation.   |\n| `alert_media`   | `media`       | The target for the `media` selector for the media player and media id with the alter. |\n| `open_duration` | `duration`    | A `duration` selector, the amount of time before playing the alert.                   |\n\nThe automation should play the selected media when the door has been open for the specified duration.\n","","```yaml\nblueprint:\n  name: Door Left Open Alert\n  description: Plays an alert on the speaker when the door is left open for a specified duration.\n  inputs:\n    door_sensor:\n      friendly_name: Door Sensor\n      selector: entity\n      description: A binary_sensor entity that represents the door status.\n    alert_media:\n      friendly_name: Alert Media\n      selector: media\n      description: The media player and media id to play the alert.\n    open_duration:\n      friendly_name: Open Duration\n      selector: duration\n      description: The duration in minutes before playing the alert.\n  steps:\n    - title: Check if the door is open\n      steps:\n        - service: sensor.track_state\n          target: {{ door_sensor }}\n          data:\n            state: 'on'\n            duration: {{ open_duration }}\n            interval: minute\n            entity_id: {{ door_sensor }}\n            action: start\n            trigger: state\n            run:\n              - service: media_player.play_media\n                target: {{ alert_media }}\n                data:\n                  media_type: 'sound'\n                  entity_id: {{ alert_media }}\n```","door_left_open-test_blueprint_inputs","Bad","^,AssertionError: Blueprint was not valid yaml: while constructing a mapping   in '<unicode string>', line 21, column 19:               target: {{ door_sensor }}                       ^ found unhashable key   in '<unicode string>', line 21, column 20:               target: {{ door_sensor }}                        ^"
"door_left_open_door_left_open-door_left_open-1","qwen3-4b","media_player","# Door left open\n\n## Problem statement\n\nCreate an blueprint automation to play an alert on the speaker when the door is\nleft open.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Play an message on the living room speaker if the garage door has been left open for more than 30 minutes\n- When the front door is ajar for 5 minutes, play a sound on the kitchen bluetooth speaker.\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input           | Selector Type | Description                                                                           |\n| --------------- | ------------- | ------------------------------------------------------------------------------------- |\n| `door_sensor`   | `entity`      | A `binary_sensor` entity selector door sensor that is the target of the automation.   |\n| `alert_media`   | `media`       | The target for the `media` selector for the media player and media id with the alter. |\n| `open_duration` | `duration`    | A `duration` selector, the amount of time before playing the alert.                   |\n\nThe automation should play the selected media when the door has been open for the specified duration.\n","","```yaml\nblueprint:\n  name: Door Left Open Alert\n  description: Plays an alert on the speaker when the door is left open for a specified duration.\n  inputs:\n    door_sensor:\n      friendly_name: Door Sensor\n      selector: entity\n      description: A binary_sensor entity that represents the door status.\n    alert_media:\n      friendly_name: Alert Media\n      selector: media\n      description: The media player and media id to play the alert.\n    open_duration:\n      friendly_name: Open Duration\n      selector: duration\n      description: The duration in minutes before playing the alert.\n  steps:\n    - title: Check if the door is open\n      steps:\n        - service: sensor.track_state\n          target: {{ door_sensor }}\n          data:\n            state: 'on'\n            duration: {{ open_duration }}\n            interval: minute\n            entity_id: {{ door_sensor }}\n            action: start\n            trigger: state\n            run:\n              - service: media_player.play_media\n                target: {{ alert_media }}\n                data:\n                  media_type: 'sound'\n                  entity_id: {{ alert_media }}\n```","door_left_open-test_door_open_plays_media","Bad","AssertionError: Unable to load automation."
"door_left_open_door_left_open-door_left_open-2","qwen3-4b","media_player","# Door left open\n\n## Problem statement\n\nCreate an blueprint automation to play an alert on the speaker when the door is\nleft open.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Play an message on the living room speaker if the garage door has been left open for more than 30 minutes\n- When the front door is ajar for 5 minutes, play a sound on the kitchen bluetooth speaker.\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input           | Selector Type | Description                                                                           |\n| --------------- | ------------- | ------------------------------------------------------------------------------------- |\n| `door_sensor`   | `entity`      | A `binary_sensor` entity selector door sensor that is the target of the automation.   |\n| `alert_media`   | `media`       | The target for the `media` selector for the media player and media id with the alter. |\n| `open_duration` | `duration`    | A `duration` selector, the amount of time before playing the alert.                   |\n\nThe automation should play the selected media when the door has been open for the specified duration.\n","","```yaml\nblueprint:\n  name: Door Left Open Alert\n  steps:\n    - name: Check if the door is open\n      steps:\n        - service: binary_sensor.set_state\n          target:\n            entity_id: '{{ inputs.door_sensor }}'\n          data:\n            state: 'on'\n        - delay: '{{ inputs.open_duration }}'\n        - service: media_player.play_media\n          target:\n            entity_id: '{{ inputs.alert_media }}'\n          data:\n            media_type: 'sound'\n            media_id: '{{ inputs.alert_media }}'\n```","door_left_open-test_blueprint_inputs","Bad","AssertionError"
"door_left_open_door_left_open-door_left_open-2","qwen3-4b","media_player","# Door left open\n\n## Problem statement\n\nCreate an blueprint automation to play an alert on the speaker when the door is\nleft open.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Play an message on the living room speaker if the garage door has been left open for more than 30 minutes\n- When the front door is ajar for 5 minutes, play a sound on the kitchen bluetooth speaker.\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input           | Selector Type | Description                                                                           |\n| --------------- | ------------- | ------------------------------------------------------------------------------------- |\n| `door_sensor`   | `entity`      | A `binary_sensor` entity selector door sensor that is the target of the automation.   |\n| `alert_media`   | `media`       | The target for the `media` selector for the media player and media id with the alter. |\n| `open_duration` | `duration`    | A `duration` selector, the amount of time before playing the alert.                   |\n\nThe automation should play the selected media when the door has been open for the specified duration.\n","","```yaml\nblueprint:\n  name: Door Left Open Alert\n  steps:\n    - name: Check if the door is open\n      steps:\n        - service: binary_sensor.set_state\n          target:\n            entity_id: '{{ inputs.door_sensor }}'\n          data:\n            state: 'on'\n        - delay: '{{ inputs.open_duration }}'\n        - service: media_player.play_media\n          target:\n            entity_id: '{{ inputs.alert_media }}'\n          data:\n            media_type: 'sound'\n            media_id: '{{ inputs.alert_media }}'\n```","door_left_open-test_door_open_plays_media","Bad","AssertionError: Unable to load automation."
"door_left_open_door_left_open-door_left_open-3","qwen3-4b","media_player","# Door left open\n\n## Problem statement\n\nCreate an blueprint automation to play an alert on the speaker when the door is\nleft open.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Play an message on the living room speaker if the garage door has been left open for more than 30 minutes\n- When the front door is ajar for 5 minutes, play a sound on the kitchen bluetooth speaker.\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input           | Selector Type | Description                                                                           |\n| --------------- | ------------- | ------------------------------------------------------------------------------------- |\n| `door_sensor`   | `entity`      | A `binary_sensor` entity selector door sensor that is the target of the automation.   |\n| `alert_media`   | `media`       | The target for the `media` selector for the media player and media id with the alter. |\n| `open_duration` | `duration`    | A `duration` selector, the amount of time before playing the alert.                   |\n\nThe automation should play the selected media when the door has been open for the specified duration.\n","","```yaml\nblueprint:\n  name: Door Left Open Alert\n  description: Plays an alert on the speaker when the door is left open for a specified duration.\n  inputs:\n    door_sensor:\n      friendly_name: Door Sensor\n      selector: entity\n      description: A binary_sensor entity that represents the door status.\n    alert_media:\n      friendly_name: Alert Media\n      selector: media\n      description: The media player and media id to play the alert.\n    open_duration:\n      friendly_name: Open Duration\n      selector: duration\n      description: The duration in minutes after which the alert should be played if the door is open.\n  steps:\n    - id: check_door_status\n      title: Check if the door is open\n      action:\n        service: rest_api.call\n        data:\n          entity_id: '{{ inputs.door_sensor }}'\n          payload:\n            state: 'on'\n    - id: check_duration\n      title: Check if the door has been open for the specified duration\n      action:\n        service: rest_api.call\n        data:\n          entity_id: '{{ inputs.door_sensor }}'\n          payload:\n            state: 'on'\n            duration: '{{ inputs.open_duration }}'\n    - id: play_alert\n      title: Play the alert media\n      action:\n        service: media_player.play_media\n        data:\n          entity_id: '{{ inputs.alert_media }}'\n          media_type: 'sound'\n          media_content_id: '{{ inputs.alert_media }}'\n```","door_left_open-test_blueprint_inputs","Bad","AssertionError"
"door_left_open_door_left_open-door_left_open-3","qwen3-4b","media_player","# Door left open\n\n## Problem statement\n\nCreate an blueprint automation to play an alert on the speaker when the door is\nleft open.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Play an message on the living room speaker if the garage door has been left open for more than 30 minutes\n- When the front door is ajar for 5 minutes, play a sound on the kitchen bluetooth speaker.\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input           | Selector Type | Description                                                                           |\n| --------------- | ------------- | ------------------------------------------------------------------------------------- |\n| `door_sensor`   | `entity`      | A `binary_sensor` entity selector door sensor that is the target of the automation.   |\n| `alert_media`   | `media`       | The target for the `media` selector for the media player and media id with the alter. |\n| `open_duration` | `duration`    | A `duration` selector, the amount of time before playing the alert.                   |\n\nThe automation should play the selected media when the door has been open for the specified duration.\n","","```yaml\nblueprint:\n  name: Door Left Open Alert\n  description: Plays an alert on the speaker when the door is left open for a specified duration.\n  inputs:\n    door_sensor:\n      friendly_name: Door Sensor\n      selector: entity\n      description: A binary_sensor entity that represents the door status.\n    alert_media:\n      friendly_name: Alert Media\n      selector: media\n      description: The media player and media id to play the alert.\n    open_duration:\n      friendly_name: Open Duration\n      selector: duration\n      description: The duration in minutes after which the alert should be played if the door is open.\n  steps:\n    - id: check_door_status\n      title: Check if the door is open\n      action:\n        service: rest_api.call\n        data:\n          entity_id: '{{ inputs.door_sensor }}'\n          payload:\n            state: 'on'\n    - id: check_duration\n      title: Check if the door has been open for the specified duration\n      action:\n        service: rest_api.call\n        data:\n          entity_id: '{{ inputs.door_sensor }}'\n          payload:\n            state: 'on'\n            duration: '{{ inputs.open_duration }}'\n    - id: play_alert\n      title: Play the alert media\n      action:\n        service: media_player.play_media\n        data:\n          entity_id: '{{ inputs.alert_media }}'\n          media_type: 'sound'\n          media_content_id: '{{ inputs.alert_media }}'\n```","door_left_open-test_door_open_plays_media","Bad","AssertionError: Unable to load automation."
"door_left_open_door_left_open-door_left_open-4","qwen3-4b","media_player","# Door left open\n\n## Problem statement\n\nCreate an blueprint automation to play an alert on the speaker when the door is\nleft open.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Play an message on the living room speaker if the garage door has been left open for more than 30 minutes\n- When the front door is ajar for 5 minutes, play a sound on the kitchen bluetooth speaker.\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input           | Selector Type | Description                                                                           |\n| --------------- | ------------- | ------------------------------------------------------------------------------------- |\n| `door_sensor`   | `entity`      | A `binary_sensor` entity selector door sensor that is the target of the automation.   |\n| `alert_media`   | `media`       | The target for the `media` selector for the media player and media id with the alter. |\n| `open_duration` | `duration`    | A `duration` selector, the amount of time before playing the alert.                   |\n\nThe automation should play the selected media when the door has been open for the specified duration.\n","","```yaml\nblueprint:\n  name: Door Left Open Alert\n  steps:\n    - title: Detect door state\n      steps:\n        - platform: state\n          entity: '{{ inputs.door_sensor }}'\n          condition: 'is_state'\n          value: 'on'\n          trigger:\n            - platform: state\n              entity_id: '{{ inputs.door_sensor }}'\n              from: 'off'\n          action:\n            - delay: '{{ inputs.open_duration }}'\n            - service: media_player.play_media\n              data:\n                entity_id: '{{ inputs.alert_media }}'\n                media_content_id: 'alert_sound_url'\n                media_type: 'sound'\n```","door_left_open-test_blueprint_inputs","Bad","AssertionError"
"door_left_open_door_left_open-door_left_open-4","qwen3-4b","media_player","# Door left open\n\n## Problem statement\n\nCreate an blueprint automation to play an alert on the speaker when the door is\nleft open.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Play an message on the living room speaker if the garage door has been left open for more than 30 minutes\n- When the front door is ajar for 5 minutes, play a sound on the kitchen bluetooth speaker.\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input           | Selector Type | Description                                                                           |\n| --------------- | ------------- | ------------------------------------------------------------------------------------- |\n| `door_sensor`   | `entity`      | A `binary_sensor` entity selector door sensor that is the target of the automation.   |\n| `alert_media`   | `media`       | The target for the `media` selector for the media player and media id with the alter. |\n| `open_duration` | `duration`    | A `duration` selector, the amount of time before playing the alert.                   |\n\nThe automation should play the selected media when the door has been open for the specified duration.\n","","```yaml\nblueprint:\n  name: Door Left Open Alert\n  steps:\n    - title: Detect door state\n      steps:\n        - platform: state\n          entity: '{{ inputs.door_sensor }}'\n          condition: 'is_state'\n          value: 'on'\n          trigger:\n            - platform: state\n              entity_id: '{{ inputs.door_sensor }}'\n              from: 'off'\n          action:\n            - delay: '{{ inputs.open_duration }}'\n            - service: media_player.play_media\n              data:\n                entity_id: '{{ inputs.alert_media }}'\n                media_content_id: 'alert_sound_url'\n                media_type: 'sound'\n```","door_left_open-test_door_open_plays_media","Bad","AssertionError: Unable to load automation."
"door_left_open_door_left_open-door_left_open-0","qwen3-8b","media_player","# Door left open\n\n## Problem statement\n\nCreate an blueprint automation to play an alert on the speaker when the door is\nleft open.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Play an message on the living room speaker if the garage door has been left open for more than 30 minutes\n- When the front door is ajar for 5 minutes, play a sound on the kitchen bluetooth speaker.\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input           | Selector Type | Description                                                                           |\n| --------------- | ------------- | ------------------------------------------------------------------------------------- |\n| `door_sensor`   | `entity`      | A `binary_sensor` entity selector door sensor that is the target of the automation.   |\n| `alert_media`   | `media`       | The target for the `media` selector for the media player and media id with the alter. |\n| `open_duration` | `duration`    | A `duration` selector, the amount of time before playing the alert.                   |\n\nThe automation should play the selected media when the door has been open for the specified duration.\n","","```yaml\nblueprint:\n  name: door_left_open_alert\n  description: Play an alert on the speaker when the door is left open for a specified duration.\n  inputs:\n    door_sensor:\n      name: Door Sensor\n      description: A binary_sensor entity that detects if the door is open.\n      selector:\n        entity:\n          domain: binary_sensor\n          device_class: opening\n    alert_media:\n      name: Alert Media\n      description: The media player and media ID to play the alert.\n      selector:\n        media:\n          type: media_player\n          media_id: 'alert_sound.mp3'\n    open_duration:\n      name: Open Duration\n      description: The duration the door must be open before triggering the alert.\n      selector:\n        duration:\n          default: '00:05:00'\n  automation:\n    - alias: Play alert if door is left open\n      trigger:\n        - platform: state\n          entity_id: '{{ door_sensor }}'\n          to: 'on'\n      condition:\n        - condition: template\n          value_template: >\n            {{ is_state_attr('binary_sensor.{{ door_sensor }}', 'last_changed') | timestamp_diff(now(), 'minutes') >= open_duration | timestamp_sec }}\n      action:\n        - service: media_player.play_media\n          data:\n            entity_id: '{{ alert_media.entity }}'\n            media_id: '{{ alert_media.media_id }}'\n```","door_left_open-test_blueprint_inputs","Bad","AssertionError"
"door_left_open_door_left_open-door_left_open-0","qwen3-8b","media_player","# Door left open\n\n## Problem statement\n\nCreate an blueprint automation to play an alert on the speaker when the door is\nleft open.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Play an message on the living room speaker if the garage door has been left open for more than 30 minutes\n- When the front door is ajar for 5 minutes, play a sound on the kitchen bluetooth speaker.\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input           | Selector Type | Description                                                                           |\n| --------------- | ------------- | ------------------------------------------------------------------------------------- |\n| `door_sensor`   | `entity`      | A `binary_sensor` entity selector door sensor that is the target of the automation.   |\n| `alert_media`   | `media`       | The target for the `media` selector for the media player and media id with the alter. |\n| `open_duration` | `duration`    | A `duration` selector, the amount of time before playing the alert.                   |\n\nThe automation should play the selected media when the door has been open for the specified duration.\n","","```yaml\nblueprint:\n  name: door_left_open_alert\n  description: Play an alert on the speaker when the door is left open for a specified duration.\n  inputs:\n    door_sensor:\n      name: Door Sensor\n      description: A binary_sensor entity that detects if the door is open.\n      selector:\n        entity:\n          domain: binary_sensor\n          device_class: opening\n    alert_media:\n      name: Alert Media\n      description: The media player and media ID to play the alert.\n      selector:\n        media:\n          type: media_player\n          media_id: 'alert_sound.mp3'\n    open_duration:\n      name: Open Duration\n      description: The duration the door must be open before triggering the alert.\n      selector:\n        duration:\n          default: '00:05:00'\n  automation:\n    - alias: Play alert if door is left open\n      trigger:\n        - platform: state\n          entity_id: '{{ door_sensor }}'\n          to: 'on'\n      condition:\n        - condition: template\n          value_template: >\n            {{ is_state_attr('binary_sensor.{{ door_sensor }}', 'last_changed') | timestamp_diff(now(), 'minutes') >= open_duration | timestamp_sec }}\n      action:\n        - service: media_player.play_media\n          data:\n            entity_id: '{{ alert_media.entity }}'\n            media_id: '{{ alert_media.media_id }}'\n```","door_left_open-test_door_open_plays_media","Bad","AssertionError: Unable to load automation."
"door_left_open_door_left_open-door_left_open-1","qwen3-8b","media_player","# Door left open\n\n## Problem statement\n\nCreate an blueprint automation to play an alert on the speaker when the door is\nleft open.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Play an message on the living room speaker if the garage door has been left open for more than 30 minutes\n- When the front door is ajar for 5 minutes, play a sound on the kitchen bluetooth speaker.\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input           | Selector Type | Description                                                                           |\n| --------------- | ------------- | ------------------------------------------------------------------------------------- |\n| `door_sensor`   | `entity`      | A `binary_sensor` entity selector door sensor that is the target of the automation.   |\n| `alert_media`   | `media`       | The target for the `media` selector for the media player and media id with the alter. |\n| `open_duration` | `duration`    | A `duration` selector, the amount of time before playing the alert.                   |\n\nThe automation should play the selected media when the door has been open for the specified duration.\n","","```yaml\nblueprint:\n  name: door_left_open_alert\n  description: Plays an alert on a speaker when a door is left open for a specified duration.\n  inputs:\n    door_sensor:\n      description: A binary_sensor entity that represents the door.\n      selector:\n        entity:\n          domain: binary_sensor\n          device_class: opening\n    alert_media:\n      description: The media player and media ID to play the alert.\n      selector:\n        media:\n          media_player: true\n          media_id: true\n    open_duration:\n      description: The duration the door must be open before triggering the alert.\n      selector:\n        duration:\n          minutes: true\n  sensors:\n    door_open_duration:\n      friendly_name: 'Door Open Duration'\n      unit_of_measurement: 'minutes'\n      icon: 'mdi:timer'\n      value_template: >\n        {% if states.binary_sensor['<door_sensor>'] == 'on' %}\n          {{ (as_timestamp(now()) - as_timestamp(states.binary_sensor['<door_sensor>'].last_changed)) | float / 60 | round(2) }}\n        {% else %}\n          0\n        {% endif %}\n  conditions:\n    condition: template\n    value_template: >\n      {% if (as_timestamp(now()) - as_timestamp(states.binary_sensor['<door_sensor>'].last_changed)) | float / 60 | round(2) >= (open_duration | int / 60) %}\n        true\n      {% else %}\n        false\n      {% endif %}\n  actions:\n    - service: media_player.play_media\n      data:\n        entity_id: >-\n          {% if alert_media.media_player is not none %}\n            {{ alert_media.media_player }}\n          {% else %}\n            {{ alert_media.entity_id }}\n          {% endif %}\n        media_id: '{{ alert_media.media_id }}'\n```","door_left_open-test_blueprint_inputs","Bad","AssertionError"
"door_left_open_door_left_open-door_left_open-1","qwen3-8b","media_player","# Door left open\n\n## Problem statement\n\nCreate an blueprint automation to play an alert on the speaker when the door is\nleft open.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Play an message on the living room speaker if the garage door has been left open for more than 30 minutes\n- When the front door is ajar for 5 minutes, play a sound on the kitchen bluetooth speaker.\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input           | Selector Type | Description                                                                           |\n| --------------- | ------------- | ------------------------------------------------------------------------------------- |\n| `door_sensor`   | `entity`      | A `binary_sensor` entity selector door sensor that is the target of the automation.   |\n| `alert_media`   | `media`       | The target for the `media` selector for the media player and media id with the alter. |\n| `open_duration` | `duration`    | A `duration` selector, the amount of time before playing the alert.                   |\n\nThe automation should play the selected media when the door has been open for the specified duration.\n","","```yaml\nblueprint:\n  name: door_left_open_alert\n  description: Plays an alert on a speaker when a door is left open for a specified duration.\n  inputs:\n    door_sensor:\n      description: A binary_sensor entity that represents the door.\n      selector:\n        entity:\n          domain: binary_sensor\n          device_class: opening\n    alert_media:\n      description: The media player and media ID to play the alert.\n      selector:\n        media:\n          media_player: true\n          media_id: true\n    open_duration:\n      description: The duration the door must be open before triggering the alert.\n      selector:\n        duration:\n          minutes: true\n  sensors:\n    door_open_duration:\n      friendly_name: 'Door Open Duration'\n      unit_of_measurement: 'minutes'\n      icon: 'mdi:timer'\n      value_template: >\n        {% if states.binary_sensor['<door_sensor>'] == 'on' %}\n          {{ (as_timestamp(now()) - as_timestamp(states.binary_sensor['<door_sensor>'].last_changed)) | float / 60 | round(2) }}\n        {% else %}\n          0\n        {% endif %}\n  conditions:\n    condition: template\n    value_template: >\n      {% if (as_timestamp(now()) - as_timestamp(states.binary_sensor['<door_sensor>'].last_changed)) | float / 60 | round(2) >= (open_duration | int / 60) %}\n        true\n      {% else %}\n        false\n      {% endif %}\n  actions:\n    - service: media_player.play_media\n      data:\n        entity_id: >-\n          {% if alert_media.media_player is not none %}\n            {{ alert_media.media_player }}\n          {% else %}\n            {{ alert_media.entity_id }}\n          {% endif %}\n        media_id: '{{ alert_media.media_id }}'\n```","door_left_open-test_door_open_plays_media","Bad","AssertionError: Unable to load automation."
"door_left_open_door_left_open-door_left_open-2","qwen3-8b","media_player","# Door left open\n\n## Problem statement\n\nCreate an blueprint automation to play an alert on the speaker when the door is\nleft open.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Play an message on the living room speaker if the garage door has been left open for more than 30 minutes\n- When the front door is ajar for 5 minutes, play a sound on the kitchen bluetooth speaker.\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input           | Selector Type | Description                                                                           |\n| --------------- | ------------- | ------------------------------------------------------------------------------------- |\n| `door_sensor`   | `entity`      | A `binary_sensor` entity selector door sensor that is the target of the automation.   |\n| `alert_media`   | `media`       | The target for the `media` selector for the media player and media id with the alter. |\n| `open_duration` | `duration`    | A `duration` selector, the amount of time before playing the alert.                   |\n\nThe automation should play the selected media when the door has been open for the specified duration.\n","","```yaml\nblueprint:\n  name: door_left_open_alert\n  description: Play an alert on a speaker when a door is left open for a specified duration.\n  inputs:\n    door_sensor:\n      description: A binary_sensor entity that represents the door.\n      selector:\n        entity:\n          domain: binary_sensor\n          device_class: door\n    alert_media:\n      description: The media player and media ID to play the alert.\n      selector:\n        media:\n          media_player: true\n          media_id: true\n    open_duration:\n      description: The duration the door must be open before triggering the alert.\n      selector:\n        duration:\n          minutes: true\n  sensors:\n    door_open_duration:\n      description: Tracks how long the door has been open.\n      unit_of_measurement: 'minutes'\n      icon: 'mdi:timer'\n      value_template: >\n        {% if is_state('binary_sensor.door', 'on') %}\n          {{ (now() - state_attr('binary_sensor.door', 'last_changed')).total_seconds() / 60 | round }}\n        {% else %}\n          0\n        {% endif %}\n  conditions:\n    condition: template\n    value_template: >\n      {{ (now() - state_attr('binary_sensor.door', 'last_changed')).total_seconds() / 60 | round >= (open_duration | timestamp_offset('minute') | timestamp_seconds / 60) }}\n  actions:\n    - service: media_player.play_media\n      data:\n        entity_id: >-\n          {{ alert_media.entity_id }}\n        media_id: >-\n          {{ alert_media.media_id }}\n```","door_left_open-test_blueprint_inputs","Bad","AssertionError"
"door_left_open_door_left_open-door_left_open-2","qwen3-8b","media_player","# Door left open\n\n## Problem statement\n\nCreate an blueprint automation to play an alert on the speaker when the door is\nleft open.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Play an message on the living room speaker if the garage door has been left open for more than 30 minutes\n- When the front door is ajar for 5 minutes, play a sound on the kitchen bluetooth speaker.\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input           | Selector Type | Description                                                                           |\n| --------------- | ------------- | ------------------------------------------------------------------------------------- |\n| `door_sensor`   | `entity`      | A `binary_sensor` entity selector door sensor that is the target of the automation.   |\n| `alert_media`   | `media`       | The target for the `media` selector for the media player and media id with the alter. |\n| `open_duration` | `duration`    | A `duration` selector, the amount of time before playing the alert.                   |\n\nThe automation should play the selected media when the door has been open for the specified duration.\n","","```yaml\nblueprint:\n  name: door_left_open_alert\n  description: Play an alert on a speaker when a door is left open for a specified duration.\n  inputs:\n    door_sensor:\n      description: A binary_sensor entity that represents the door.\n      selector:\n        entity:\n          domain: binary_sensor\n          device_class: door\n    alert_media:\n      description: The media player and media ID to play the alert.\n      selector:\n        media:\n          media_player: true\n          media_id: true\n    open_duration:\n      description: The duration the door must be open before triggering the alert.\n      selector:\n        duration:\n          minutes: true\n  sensors:\n    door_open_duration:\n      description: Tracks how long the door has been open.\n      unit_of_measurement: 'minutes'\n      icon: 'mdi:timer'\n      value_template: >\n        {% if is_state('binary_sensor.door', 'on') %}\n          {{ (now() - state_attr('binary_sensor.door', 'last_changed')).total_seconds() / 60 | round }}\n        {% else %}\n          0\n        {% endif %}\n  conditions:\n    condition: template\n    value_template: >\n      {{ (now() - state_attr('binary_sensor.door', 'last_changed')).total_seconds() / 60 | round >= (open_duration | timestamp_offset('minute') | timestamp_seconds / 60) }}\n  actions:\n    - service: media_player.play_media\n      data:\n        entity_id: >-\n          {{ alert_media.entity_id }}\n        media_id: >-\n          {{ alert_media.media_id }}\n```","door_left_open-test_door_open_plays_media","Bad","AssertionError: Unable to load automation."
"door_left_open_door_left_open-door_left_open-3","qwen3-8b","media_player","# Door left open\n\n## Problem statement\n\nCreate an blueprint automation to play an alert on the speaker when the door is\nleft open.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Play an message on the living room speaker if the garage door has been left open for more than 30 minutes\n- When the front door is ajar for 5 minutes, play a sound on the kitchen bluetooth speaker.\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input           | Selector Type | Description                                                                           |\n| --------------- | ------------- | ------------------------------------------------------------------------------------- |\n| `door_sensor`   | `entity`      | A `binary_sensor` entity selector door sensor that is the target of the automation.   |\n| `alert_media`   | `media`       | The target for the `media` selector for the media player and media id with the alter. |\n| `open_duration` | `duration`    | A `duration` selector, the amount of time before playing the alert.                   |\n\nThe automation should play the selected media when the door has been open for the specified duration.\n","","```yaml\nblueprint:\n  name: door_left_open_alert\n  description: Plays an alert on a speaker when a door has been left open for a specified duration.\n  author: Home Assistant\n  domain: homeassistant\n  inputs:\n    door_sensor:\n      description: A binary_sensor entity that represents the door.\n      selector:\n        entity:\n          domain: binary_sensor\n          device_class: opening\n    alert_media:\n      description: The media player and media ID to play the alert.\n      selector:\n        media:\n          media_player:\n            - selector: media_player\n          media_id:\n            - selector: media_id\n    open_duration:\n      description: The duration the door must be open before triggering the alert.\n      selector:\n        duration:\n          default: 00:05:00\n  sensors:\n    door_open_duration:\n      description: Tracks how long the door has been open.\n      unit_of_measurement: minutes\n      icon: mdi:timer\n      value_template: >\n        {% if states.binary_sensor['<door_sensor>'] == 'on' %}\n          {{ (now() - states.binary_sensor['<door_sensor>'].last_changed).seconds / 60 | round }}\n        {% else %}\n          0\n        {% endif %}\n  automation:\n    - alias: Play alert if door is left open\n      trigger:\n        - platform: state\n          entity_id: '{{ door_sensor }}'\n          to: 'on'\n      condition:\n        - condition: template\n          value_template: >\n            {% if (now() - states.binary_sensor['<door_sensor>'].last_changed).seconds >= open_duration | timestamp_sec %}\n              true\n            {% else %}\n              false\n            {% endif %}\n      action:\n        - service: media_player.play_media\n          data:\n            entity_id: '{{ alert_media.media_player }}'\n            media_id: '{{ alert_media.media_id }}'\n```","door_left_open-test_blueprint_inputs","Bad","AssertionError"
"door_left_open_door_left_open-door_left_open-3","qwen3-8b","media_player","# Door left open\n\n## Problem statement\n\nCreate an blueprint automation to play an alert on the speaker when the door is\nleft open.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Play an message on the living room speaker if the garage door has been left open for more than 30 minutes\n- When the front door is ajar for 5 minutes, play a sound on the kitchen bluetooth speaker.\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input           | Selector Type | Description                                                                           |\n| --------------- | ------------- | ------------------------------------------------------------------------------------- |\n| `door_sensor`   | `entity`      | A `binary_sensor` entity selector door sensor that is the target of the automation.   |\n| `alert_media`   | `media`       | The target for the `media` selector for the media player and media id with the alter. |\n| `open_duration` | `duration`    | A `duration` selector, the amount of time before playing the alert.                   |\n\nThe automation should play the selected media when the door has been open for the specified duration.\n","","```yaml\nblueprint:\n  name: door_left_open_alert\n  description: Plays an alert on a speaker when a door has been left open for a specified duration.\n  author: Home Assistant\n  domain: homeassistant\n  inputs:\n    door_sensor:\n      description: A binary_sensor entity that represents the door.\n      selector:\n        entity:\n          domain: binary_sensor\n          device_class: opening\n    alert_media:\n      description: The media player and media ID to play the alert.\n      selector:\n        media:\n          media_player:\n            - selector: media_player\n          media_id:\n            - selector: media_id\n    open_duration:\n      description: The duration the door must be open before triggering the alert.\n      selector:\n        duration:\n          default: 00:05:00\n  sensors:\n    door_open_duration:\n      description: Tracks how long the door has been open.\n      unit_of_measurement: minutes\n      icon: mdi:timer\n      value_template: >\n        {% if states.binary_sensor['<door_sensor>'] == 'on' %}\n          {{ (now() - states.binary_sensor['<door_sensor>'].last_changed).seconds / 60 | round }}\n        {% else %}\n          0\n        {% endif %}\n  automation:\n    - alias: Play alert if door is left open\n      trigger:\n        - platform: state\n          entity_id: '{{ door_sensor }}'\n          to: 'on'\n      condition:\n        - condition: template\n          value_template: >\n            {% if (now() - states.binary_sensor['<door_sensor>'].last_changed).seconds >= open_duration | timestamp_sec %}\n              true\n            {% else %}\n              false\n            {% endif %}\n      action:\n        - service: media_player.play_media\n          data:\n            entity_id: '{{ alert_media.media_player }}'\n            media_id: '{{ alert_media.media_id }}'\n```","door_left_open-test_door_open_plays_media","Bad","AssertionError: Unable to load automation."
"door_left_open_door_left_open-door_left_open-4","qwen3-8b","media_player","# Door left open\n\n## Problem statement\n\nCreate an blueprint automation to play an alert on the speaker when the door is\nleft open.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Play an message on the living room speaker if the garage door has been left open for more than 30 minutes\n- When the front door is ajar for 5 minutes, play a sound on the kitchen bluetooth speaker.\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input           | Selector Type | Description                                                                           |\n| --------------- | ------------- | ------------------------------------------------------------------------------------- |\n| `door_sensor`   | `entity`      | A `binary_sensor` entity selector door sensor that is the target of the automation.   |\n| `alert_media`   | `media`       | The target for the `media` selector for the media player and media id with the alter. |\n| `open_duration` | `duration`    | A `duration` selector, the amount of time before playing the alert.                   |\n\nThe automation should play the selected media when the door has been open for the specified duration.\n","","```yaml\nblueprint:\n  name: Door left open alert\n  description: Plays an alert on a speaker when a door has been left open for a specified duration.\n  inputs:\n    door_sensor:\n      description: A binary_sensor entity representing the door.\n      selector:\n        entity:\n          domain: binary_sensor\n          device_class: opening\n    alert_media:\n      description: The media player and media ID to play the alert.\n      selector:\n        media:\n          media_player:\n            - selector: media_player\n          media_id:\n            - selector: media_id\n    open_duration:\n      description: The duration the door must be open before triggering the alert.\n      selector:\n        duration:\n          minutes: 0\n  sensors:\n    door_open_duration:\n      description: Tracks how long the door has been open.\n      unit_of_measurement: minutes\n      value_template: >\n        {% if is_state('binary_sensor.door', 'on') %}\n          {{ (now() - states('binary_sensor.door').last_changed).total_seconds() / 60 | round }}\n        {% else %}\n          0\n        {% endif %}\n  conditions:\n    condition:\n      - condition: template\n        value_template: >\n          {% if (now() - states('binary_sensor.door').last_changed).total_seconds() / 60 >= (open_duration | int) %}\n            true\n          {% else %}\n            false\n          {% endif %}\n  actions:\n    - service: media_player.play_media\n      data:\n        entity_id: !input.alert_media.media_player\n        media_id: !input.alert_media.media_id\n```","door_left_open-test_blueprint_inputs","Bad","AssertionError"
"door_left_open_door_left_open-door_left_open-4","qwen3-8b","media_player","# Door left open\n\n## Problem statement\n\nCreate an blueprint automation to play an alert on the speaker when the door is\nleft open.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Play an message on the living room speaker if the garage door has been left open for more than 30 minutes\n- When the front door is ajar for 5 minutes, play a sound on the kitchen bluetooth speaker.\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input           | Selector Type | Description                                                                           |\n| --------------- | ------------- | ------------------------------------------------------------------------------------- |\n| `door_sensor`   | `entity`      | A `binary_sensor` entity selector door sensor that is the target of the automation.   |\n| `alert_media`   | `media`       | The target for the `media` selector for the media player and media id with the alter. |\n| `open_duration` | `duration`    | A `duration` selector, the amount of time before playing the alert.                   |\n\nThe automation should play the selected media when the door has been open for the specified duration.\n","","```yaml\nblueprint:\n  name: Door left open alert\n  description: Plays an alert on a speaker when a door has been left open for a specified duration.\n  inputs:\n    door_sensor:\n      description: A binary_sensor entity representing the door.\n      selector:\n        entity:\n          domain: binary_sensor\n          device_class: opening\n    alert_media:\n      description: The media player and media ID to play the alert.\n      selector:\n        media:\n          media_player:\n            - selector: media_player\n          media_id:\n            - selector: media_id\n    open_duration:\n      description: The duration the door must be open before triggering the alert.\n      selector:\n        duration:\n          minutes: 0\n  sensors:\n    door_open_duration:\n      description: Tracks how long the door has been open.\n      unit_of_measurement: minutes\n      value_template: >\n        {% if is_state('binary_sensor.door', 'on') %}\n          {{ (now() - states('binary_sensor.door').last_changed).total_seconds() / 60 | round }}\n        {% else %}\n          0\n        {% endif %}\n  conditions:\n    condition:\n      - condition: template\n        value_template: >\n          {% if (now() - states('binary_sensor.door').last_changed).total_seconds() / 60 >= (open_duration | int) %}\n            true\n          {% else %}\n            false\n          {% endif %}\n  actions:\n    - service: media_player.play_media\n      data:\n        entity_id: !input.alert_media.media_player\n        media_id: !input.alert_media.media_id\n```","door_left_open-test_door_open_plays_media","Bad","AssertionError: Unable to load automation."
"humidity_fan_humidity_fan-humidity_fan-0","gemini-2.5-flash","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\nblueprint:\n  name: Humidity Fan Control\n  description: Turns a fan on when humidity rises above a set level and off when it falls below.\n  domain: automation\n  input:\n    humidity_sensor:\n      name: Humidity Sensor\n      description: The humidity sensor that triggers the automation (e.g., Bathroom Humidity).\n      selector:\n        entity:\n          domain: sensor\n          device_class: humidity\n    humidity_level:\n      name: Humidity Level (%)\n      description: The humidity percentage level at which to turn the fan on/off.\n      default: 60\n      selector:\n        number:\n          min: 0\n          max: 100\n          step: 1\n          unit_of_measurement: '%'\n          mode: slider\n    fan_entity:\n      name: Fan Entity\n      description: The fan entity to control (e.g., Bathroom Exhaust Fan).\n      selector:\n        entity:\n          domain: fan\n  source_url: https://community.home-assistant.io/t/humidity-fan-control/example\n\nmode: single\n\ntrigger:\n  - platform: numeric_state\n    entity_id: !input humidity_sensor\n    above: !input humidity_level\n    id: turn_on_fan\n    # The automation triggers when the sensor goes above the threshold.\n    # The 'for' option is not used here to ensure quick response,\n    # but could be added if momentary spikes are an issue.\n\n  - platform: numeric_state\n    entity_id: !input humidity_sensor\n    below: !input humidity_level\n    id: turn_off_fan\n    # The automation triggers when the sensor goes below the threshold.\n\naction:\n  - choose:\n      # Action to turn on the fan when humidity goes above the set level.\n      - conditions:\n          - condition: trigger\n            id: turn_on_fan\n          - condition: state # Only try to turn on if the fan is currently off.\n            entity_id: !input fan_entity\n            state: 'off'\n        sequence:\n          - service: fan.turn_on\n            target:\n              entity_id: !input fan_entity\n\n      # Action to turn off the fan when humidity goes below the set level.\n      - conditions:\n          - condition: trigger\n            id: turn_off_fan\n          - condition: state # Only try to turn off if the fan is currently on.\n            entity_id: !input fan_entity\n            state: 'on'\n        sequence:\n          - service: fan.turn_off\n            target:\n              entity_id: !input fan_entity\n```","humidity_fan-test_blueprint_inputs","Good",""
"humidity_fan_humidity_fan-humidity_fan-0","gemini-2.5-flash","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\nblueprint:\n  name: Humidity Fan Control\n  description: Turns a fan on when humidity rises above a set level and off when it falls below.\n  domain: automation\n  input:\n    humidity_sensor:\n      name: Humidity Sensor\n      description: The humidity sensor that triggers the automation (e.g., Bathroom Humidity).\n      selector:\n        entity:\n          domain: sensor\n          device_class: humidity\n    humidity_level:\n      name: Humidity Level (%)\n      description: The humidity percentage level at which to turn the fan on/off.\n      default: 60\n      selector:\n        number:\n          min: 0\n          max: 100\n          step: 1\n          unit_of_measurement: '%'\n          mode: slider\n    fan_entity:\n      name: Fan Entity\n      description: The fan entity to control (e.g., Bathroom Exhaust Fan).\n      selector:\n        entity:\n          domain: fan\n  source_url: https://community.home-assistant.io/t/humidity-fan-control/example\n\nmode: single\n\ntrigger:\n  - platform: numeric_state\n    entity_id: !input humidity_sensor\n    above: !input humidity_level\n    id: turn_on_fan\n    # The automation triggers when the sensor goes above the threshold.\n    # The 'for' option is not used here to ensure quick response,\n    # but could be added if momentary spikes are an issue.\n\n  - platform: numeric_state\n    entity_id: !input humidity_sensor\n    below: !input humidity_level\n    id: turn_off_fan\n    # The automation triggers when the sensor goes below the threshold.\n\naction:\n  - choose:\n      # Action to turn on the fan when humidity goes above the set level.\n      - conditions:\n          - condition: trigger\n            id: turn_on_fan\n          - condition: state # Only try to turn on if the fan is currently off.\n            entity_id: !input fan_entity\n            state: 'off'\n        sequence:\n          - service: fan.turn_on\n            target:\n              entity_id: !input fan_entity\n\n      # Action to turn off the fan when humidity goes below the set level.\n      - conditions:\n          - condition: trigger\n            id: turn_off_fan\n          - condition: state # Only try to turn off if the fan is currently on.\n            entity_id: !input fan_entity\n            state: 'on'\n        sequence:\n          - service: fan.turn_off\n            target:\n              entity_id: !input fan_entity\n```","humidity_fan-test_fan_triggered_on","Good",""
"humidity_fan_humidity_fan-humidity_fan-0","gemini-2.5-flash","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\nblueprint:\n  name: Humidity Fan Control\n  description: Turns a fan on when humidity rises above a set level and off when it falls below.\n  domain: automation\n  input:\n    humidity_sensor:\n      name: Humidity Sensor\n      description: The humidity sensor that triggers the automation (e.g., Bathroom Humidity).\n      selector:\n        entity:\n          domain: sensor\n          device_class: humidity\n    humidity_level:\n      name: Humidity Level (%)\n      description: The humidity percentage level at which to turn the fan on/off.\n      default: 60\n      selector:\n        number:\n          min: 0\n          max: 100\n          step: 1\n          unit_of_measurement: '%'\n          mode: slider\n    fan_entity:\n      name: Fan Entity\n      description: The fan entity to control (e.g., Bathroom Exhaust Fan).\n      selector:\n        entity:\n          domain: fan\n  source_url: https://community.home-assistant.io/t/humidity-fan-control/example\n\nmode: single\n\ntrigger:\n  - platform: numeric_state\n    entity_id: !input humidity_sensor\n    above: !input humidity_level\n    id: turn_on_fan\n    # The automation triggers when the sensor goes above the threshold.\n    # The 'for' option is not used here to ensure quick response,\n    # but could be added if momentary spikes are an issue.\n\n  - platform: numeric_state\n    entity_id: !input humidity_sensor\n    below: !input humidity_level\n    id: turn_off_fan\n    # The automation triggers when the sensor goes below the threshold.\n\naction:\n  - choose:\n      # Action to turn on the fan when humidity goes above the set level.\n      - conditions:\n          - condition: trigger\n            id: turn_on_fan\n          - condition: state # Only try to turn on if the fan is currently off.\n            entity_id: !input fan_entity\n            state: 'off'\n        sequence:\n          - service: fan.turn_on\n            target:\n              entity_id: !input fan_entity\n\n      # Action to turn off the fan when humidity goes below the set level.\n      - conditions:\n          - condition: trigger\n            id: turn_off_fan\n          - condition: state # Only try to turn off if the fan is currently on.\n            entity_id: !input fan_entity\n            state: 'on'\n        sequence:\n          - service: fan.turn_off\n            target:\n              entity_id: !input fan_entity\n```","humidity_fan-test_fan_triggered_off","Good",""
"humidity_fan_humidity_fan-humidity_fan-1","gemini-2.5-flash","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\nblueprint:\n  name: Humidity Fan Control\n  description: Turns on a fan when humidity rises above a set level, and turns it off when it falls below that level.\n  domain: automation\n  input:\n    humidity_sensor:\n      name: Humidity Sensor\n      description: The humidity sensor that triggers the automation (e.g., Bathroom Humidity).\n      selector:\n        entity:\n          domain: sensor\n          device_class: humidity # Recommends sensors with a humidity device class for better filtering.\n    humidity_level:\n      name: Humidity Threshold (%)\n      description: The humidity percentage (%) at which the fan should turn on (above) or off (below).\n      default: 60 # A common default for bathroom humidity\n      selector:\n        number:\n          min: 0\n          max: 100\n          step: 1\n          unit_of_measurement: '%'\n          mode: slider\n    fan_entity:\n      name: Fan Entity\n      description: The fan entity to control (e.g., Bathroom Exhaust Fan).\n      selector:\n        entity:\n          domain: fan\n\nmode: single # Ensures that the automation runs one execution at a time. If it's already running, new triggers are ignored.\n\ntrigger:\n  # Trigger when humidity goes above the specified level (to turn on the fan)\n  - platform: numeric_state\n    entity_id: !input humidity_sensor\n    above: !input humidity_level\n    id: 'humidity_high' # Unique ID for this trigger\n  # Trigger when humidity goes below the specified level (to turn off the fan)\n  - platform: numeric_state\n    entity_id: !input humidity_sensor\n    below: !input humidity_level\n    id: 'humidity_low' # Unique ID for this trigger\n\naction:\n  # Use a choose action to differentiate between the two triggers (high vs. low humidity)\n  - choose:\n      # Action block for when humidity goes above the threshold\n      - conditions:\n          - condition: trigger\n            id: 'humidity_high'\n        sequence:\n          # Condition: Only turn on the fan if it is currently off\n          - condition: state\n            entity_id: !input fan_entity\n            state: 'off'\n          - service: fan.turn_on\n            target:\n              entity_id: !input fan_entity\n            # You can add fan speed/percentage here if your fan supports it, e.g.:\n            # data:\n            #   percentage: 100\n            #   preset_mode: 'On' # Or 'High' etc., depending on fan model\n            # Note: For simplicity, this blueprint only uses turn_on/turn_off.\n\n      # Action block for when humidity goes below the threshold\n      - conditions:\n          - condition: trigger\n            id: 'humidity_low'\n        sequence:\n          # Condition: Only turn off the fan if it is currently on\n          - condition: state\n            entity_id: !input fan_entity\n            state: 'on'\n          - service: fan.turn_off\n            target:\n              entity_id: !input fan_entity\n```","humidity_fan-test_blueprint_inputs","Good",""
"humidity_fan_humidity_fan-humidity_fan-1","gemini-2.5-flash","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\nblueprint:\n  name: Humidity Fan Control\n  description: Turns on a fan when humidity rises above a set level, and turns it off when it falls below that level.\n  domain: automation\n  input:\n    humidity_sensor:\n      name: Humidity Sensor\n      description: The humidity sensor that triggers the automation (e.g., Bathroom Humidity).\n      selector:\n        entity:\n          domain: sensor\n          device_class: humidity # Recommends sensors with a humidity device class for better filtering.\n    humidity_level:\n      name: Humidity Threshold (%)\n      description: The humidity percentage (%) at which the fan should turn on (above) or off (below).\n      default: 60 # A common default for bathroom humidity\n      selector:\n        number:\n          min: 0\n          max: 100\n          step: 1\n          unit_of_measurement: '%'\n          mode: slider\n    fan_entity:\n      name: Fan Entity\n      description: The fan entity to control (e.g., Bathroom Exhaust Fan).\n      selector:\n        entity:\n          domain: fan\n\nmode: single # Ensures that the automation runs one execution at a time. If it's already running, new triggers are ignored.\n\ntrigger:\n  # Trigger when humidity goes above the specified level (to turn on the fan)\n  - platform: numeric_state\n    entity_id: !input humidity_sensor\n    above: !input humidity_level\n    id: 'humidity_high' # Unique ID for this trigger\n  # Trigger when humidity goes below the specified level (to turn off the fan)\n  - platform: numeric_state\n    entity_id: !input humidity_sensor\n    below: !input humidity_level\n    id: 'humidity_low' # Unique ID for this trigger\n\naction:\n  # Use a choose action to differentiate between the two triggers (high vs. low humidity)\n  - choose:\n      # Action block for when humidity goes above the threshold\n      - conditions:\n          - condition: trigger\n            id: 'humidity_high'\n        sequence:\n          # Condition: Only turn on the fan if it is currently off\n          - condition: state\n            entity_id: !input fan_entity\n            state: 'off'\n          - service: fan.turn_on\n            target:\n              entity_id: !input fan_entity\n            # You can add fan speed/percentage here if your fan supports it, e.g.:\n            # data:\n            #   percentage: 100\n            #   preset_mode: 'On' # Or 'High' etc., depending on fan model\n            # Note: For simplicity, this blueprint only uses turn_on/turn_off.\n\n      # Action block for when humidity goes below the threshold\n      - conditions:\n          - condition: trigger\n            id: 'humidity_low'\n        sequence:\n          # Condition: Only turn off the fan if it is currently on\n          - condition: state\n            entity_id: !input fan_entity\n            state: 'on'\n          - service: fan.turn_off\n            target:\n              entity_id: !input fan_entity\n```","humidity_fan-test_fan_triggered_on","Good",""
"humidity_fan_humidity_fan-humidity_fan-1","gemini-2.5-flash","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\nblueprint:\n  name: Humidity Fan Control\n  description: Turns on a fan when humidity rises above a set level, and turns it off when it falls below that level.\n  domain: automation\n  input:\n    humidity_sensor:\n      name: Humidity Sensor\n      description: The humidity sensor that triggers the automation (e.g., Bathroom Humidity).\n      selector:\n        entity:\n          domain: sensor\n          device_class: humidity # Recommends sensors with a humidity device class for better filtering.\n    humidity_level:\n      name: Humidity Threshold (%)\n      description: The humidity percentage (%) at which the fan should turn on (above) or off (below).\n      default: 60 # A common default for bathroom humidity\n      selector:\n        number:\n          min: 0\n          max: 100\n          step: 1\n          unit_of_measurement: '%'\n          mode: slider\n    fan_entity:\n      name: Fan Entity\n      description: The fan entity to control (e.g., Bathroom Exhaust Fan).\n      selector:\n        entity:\n          domain: fan\n\nmode: single # Ensures that the automation runs one execution at a time. If it's already running, new triggers are ignored.\n\ntrigger:\n  # Trigger when humidity goes above the specified level (to turn on the fan)\n  - platform: numeric_state\n    entity_id: !input humidity_sensor\n    above: !input humidity_level\n    id: 'humidity_high' # Unique ID for this trigger\n  # Trigger when humidity goes below the specified level (to turn off the fan)\n  - platform: numeric_state\n    entity_id: !input humidity_sensor\n    below: !input humidity_level\n    id: 'humidity_low' # Unique ID for this trigger\n\naction:\n  # Use a choose action to differentiate between the two triggers (high vs. low humidity)\n  - choose:\n      # Action block for when humidity goes above the threshold\n      - conditions:\n          - condition: trigger\n            id: 'humidity_high'\n        sequence:\n          # Condition: Only turn on the fan if it is currently off\n          - condition: state\n            entity_id: !input fan_entity\n            state: 'off'\n          - service: fan.turn_on\n            target:\n              entity_id: !input fan_entity\n            # You can add fan speed/percentage here if your fan supports it, e.g.:\n            # data:\n            #   percentage: 100\n            #   preset_mode: 'On' # Or 'High' etc., depending on fan model\n            # Note: For simplicity, this blueprint only uses turn_on/turn_off.\n\n      # Action block for when humidity goes below the threshold\n      - conditions:\n          - condition: trigger\n            id: 'humidity_low'\n        sequence:\n          # Condition: Only turn off the fan if it is currently on\n          - condition: state\n            entity_id: !input fan_entity\n            state: 'on'\n          - service: fan.turn_off\n            target:\n              entity_id: !input fan_entity\n```","humidity_fan-test_fan_triggered_off","Good",""
"humidity_fan_humidity_fan-humidity_fan-2","gemini-2.5-flash","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\nblueprint:\n  name: Humidity Fan Control\n  description: Turns a fan on when humidity goes above a set level and off when it drops below, helping to manage humidity levels in a space.\n  domain: automation\n  input:\n    humidity_sensor:\n      name: Humidity Sensor\n      description: The humidity sensor entity that will trigger the automation (e.g., Bathroom Humidity Sensor).\n      selector:\n        entity:\n          domain: sensor\n          device_class: humidity # Filters entities to only show humidity sensors\n    humidity_level:\n      name: Humidity Threshold (%)\n      description: The humidity percentage at which the fan should turn on/off.\n      default: 60 # A common default for humidity control\n      selector:\n        number:\n          min: 0\n          max: 100\n          step: 1\n          unit_of_measurement: '%'\n          mode: slider # Provides a user-friendly slider for selection\n    fan_entity:\n      name: Fan Entity\n      description: The fan entity to control (e.g., Bathroom Exhaust Fan, Garage Fan).\n      selector:\n        entity:\n          domain: fan\n\nmode: single # Ensures that only one instance of the automation runs at a time, preventing conflicts if humidity fluctuates rapidly\n\ntrigger:\n  - platform: numeric_state\n    entity_id: !input humidity_sensor\n    above: !input humidity_level\n    id: 'turn_on_fan' # Unique ID for this trigger to differentiate actions\n    # This trigger fires when the humidity_sensor's state changes from below to above humidity_level\n\n  - platform: numeric_state\n    entity_id: !input humidity_sensor\n    below: !input humidity_level\n    id: 'turn_off_fan' # Unique ID for this trigger\n    # This trigger fires when the humidity_sensor's state changes from above to below humidity_level\n\naction:\n  - choose:\n      # Action to turn on the fan\n      - conditions:\n          - condition: trigger # Check which trigger fired\n            id: 'turn_on_fan'\n          - condition: state # Ensure the fan is currently off before attempting to turn it on\n            entity_id: !input fan_entity\n            state: 'off'\n        sequence:\n          - service: fan.turn_on\n            target:\n              entity_id: !input fan_entity\n          - service: system_log.write # Log the action for debugging/monitoring\n            message: 'Humidity ({{ states(!input 'humidity_sensor').state }}%) is above threshold ({{ states('input_number.humidity_level').state }}%), turning on {{ states(!input 'fan_entity').name }}.'\n            level: info\n\n      # Action to turn off the fan\n      - conditions:\n          - condition: trigger # Check which trigger fired\n            id: 'turn_off_fan'\n          - condition: state # Ensure the fan is currently on before attempting to turn it off\n            entity_id: !input fan_entity\n            state: 'on'\n        sequence:\n          - service: fan.turn_off\n            target:\n              entity_id: !input fan_entity\n          - service: system_log.write # Log the action for debugging/monitoring\n            message: 'Humidity ({{ states(!input 'humidity_sensor').state }}%) is below threshold ({{ states('input_number.humidity_level').state }}%), turning off {{ states(!input 'fan_entity').name }}.'\n            level: info\n    default: [] # No action taken if none of the above conditions are met (e.g., fan already in desired state)\n\n```","humidity_fan-test_blueprint_inputs","Good",""
"humidity_fan_humidity_fan-humidity_fan-2","gemini-2.5-flash","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\nblueprint:\n  name: Humidity Fan Control\n  description: Turns a fan on when humidity goes above a set level and off when it drops below, helping to manage humidity levels in a space.\n  domain: automation\n  input:\n    humidity_sensor:\n      name: Humidity Sensor\n      description: The humidity sensor entity that will trigger the automation (e.g., Bathroom Humidity Sensor).\n      selector:\n        entity:\n          domain: sensor\n          device_class: humidity # Filters entities to only show humidity sensors\n    humidity_level:\n      name: Humidity Threshold (%)\n      description: The humidity percentage at which the fan should turn on/off.\n      default: 60 # A common default for humidity control\n      selector:\n        number:\n          min: 0\n          max: 100\n          step: 1\n          unit_of_measurement: '%'\n          mode: slider # Provides a user-friendly slider for selection\n    fan_entity:\n      name: Fan Entity\n      description: The fan entity to control (e.g., Bathroom Exhaust Fan, Garage Fan).\n      selector:\n        entity:\n          domain: fan\n\nmode: single # Ensures that only one instance of the automation runs at a time, preventing conflicts if humidity fluctuates rapidly\n\ntrigger:\n  - platform: numeric_state\n    entity_id: !input humidity_sensor\n    above: !input humidity_level\n    id: 'turn_on_fan' # Unique ID for this trigger to differentiate actions\n    # This trigger fires when the humidity_sensor's state changes from below to above humidity_level\n\n  - platform: numeric_state\n    entity_id: !input humidity_sensor\n    below: !input humidity_level\n    id: 'turn_off_fan' # Unique ID for this trigger\n    # This trigger fires when the humidity_sensor's state changes from above to below humidity_level\n\naction:\n  - choose:\n      # Action to turn on the fan\n      - conditions:\n          - condition: trigger # Check which trigger fired\n            id: 'turn_on_fan'\n          - condition: state # Ensure the fan is currently off before attempting to turn it on\n            entity_id: !input fan_entity\n            state: 'off'\n        sequence:\n          - service: fan.turn_on\n            target:\n              entity_id: !input fan_entity\n          - service: system_log.write # Log the action for debugging/monitoring\n            message: 'Humidity ({{ states(!input 'humidity_sensor').state }}%) is above threshold ({{ states('input_number.humidity_level').state }}%), turning on {{ states(!input 'fan_entity').name }}.'\n            level: info\n\n      # Action to turn off the fan\n      - conditions:\n          - condition: trigger # Check which trigger fired\n            id: 'turn_off_fan'\n          - condition: state # Ensure the fan is currently on before attempting to turn it off\n            entity_id: !input fan_entity\n            state: 'on'\n        sequence:\n          - service: fan.turn_off\n            target:\n              entity_id: !input fan_entity\n          - service: system_log.write # Log the action for debugging/monitoring\n            message: 'Humidity ({{ states(!input 'humidity_sensor').state }}%) is below threshold ({{ states('input_number.humidity_level').state }}%), turning off {{ states(!input 'fan_entity').name }}.'\n            level: info\n    default: [] # No action taken if none of the above conditions are met (e.g., fan already in desired state)\n\n```","humidity_fan-test_fan_triggered_on","Bad","AssertionError: Unable to load automation."
"humidity_fan_humidity_fan-humidity_fan-2","gemini-2.5-flash","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\nblueprint:\n  name: Humidity Fan Control\n  description: Turns a fan on when humidity goes above a set level and off when it drops below, helping to manage humidity levels in a space.\n  domain: automation\n  input:\n    humidity_sensor:\n      name: Humidity Sensor\n      description: The humidity sensor entity that will trigger the automation (e.g., Bathroom Humidity Sensor).\n      selector:\n        entity:\n          domain: sensor\n          device_class: humidity # Filters entities to only show humidity sensors\n    humidity_level:\n      name: Humidity Threshold (%)\n      description: The humidity percentage at which the fan should turn on/off.\n      default: 60 # A common default for humidity control\n      selector:\n        number:\n          min: 0\n          max: 100\n          step: 1\n          unit_of_measurement: '%'\n          mode: slider # Provides a user-friendly slider for selection\n    fan_entity:\n      name: Fan Entity\n      description: The fan entity to control (e.g., Bathroom Exhaust Fan, Garage Fan).\n      selector:\n        entity:\n          domain: fan\n\nmode: single # Ensures that only one instance of the automation runs at a time, preventing conflicts if humidity fluctuates rapidly\n\ntrigger:\n  - platform: numeric_state\n    entity_id: !input humidity_sensor\n    above: !input humidity_level\n    id: 'turn_on_fan' # Unique ID for this trigger to differentiate actions\n    # This trigger fires when the humidity_sensor's state changes from below to above humidity_level\n\n  - platform: numeric_state\n    entity_id: !input humidity_sensor\n    below: !input humidity_level\n    id: 'turn_off_fan' # Unique ID for this trigger\n    # This trigger fires when the humidity_sensor's state changes from above to below humidity_level\n\naction:\n  - choose:\n      # Action to turn on the fan\n      - conditions:\n          - condition: trigger # Check which trigger fired\n            id: 'turn_on_fan'\n          - condition: state # Ensure the fan is currently off before attempting to turn it on\n            entity_id: !input fan_entity\n            state: 'off'\n        sequence:\n          - service: fan.turn_on\n            target:\n              entity_id: !input fan_entity\n          - service: system_log.write # Log the action for debugging/monitoring\n            message: 'Humidity ({{ states(!input 'humidity_sensor').state }}%) is above threshold ({{ states('input_number.humidity_level').state }}%), turning on {{ states(!input 'fan_entity').name }}.'\n            level: info\n\n      # Action to turn off the fan\n      - conditions:\n          - condition: trigger # Check which trigger fired\n            id: 'turn_off_fan'\n          - condition: state # Ensure the fan is currently on before attempting to turn it off\n            entity_id: !input fan_entity\n            state: 'on'\n        sequence:\n          - service: fan.turn_off\n            target:\n              entity_id: !input fan_entity\n          - service: system_log.write # Log the action for debugging/monitoring\n            message: 'Humidity ({{ states(!input 'humidity_sensor').state }}%) is below threshold ({{ states('input_number.humidity_level').state }}%), turning off {{ states(!input 'fan_entity').name }}.'\n            level: info\n    default: [] # No action taken if none of the above conditions are met (e.g., fan already in desired state)\n\n```","humidity_fan-test_fan_triggered_off","Bad","AssertionError: Unable to load automation."
"humidity_fan_humidity_fan-humidity_fan-3","gemini-2.5-flash","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\nblueprint:\n  name: Humidity Fan\n  description: Turns on a fan when the humidity level rises above a specified threshold and turns it off when the humidity drops below that threshold.\n  domain: automation\n  input:\n    humidity_sensor:\n      name: Humidity Sensor\n      description: The humidity sensor that triggers the automation (e.g., Bathroom Humidity Sensor).\n      selector:\n        entity:\n          domain: sensor\n          device_class: humidity\n    humidity_level:\n      name: Humidity Threshold (%)\n      description: The humidity percentage at which the fan should turn on/off.\n      selector:\n        number:\n          min: 0\n          max: 100\n          unit_of_measurement: '%'\n          mode: slider\n          step: 1\n          initial: 60 # Default to 60% as per example use case\n    fan_entity:\n      name: Fan Entity\n      description: The fan entity to control (e.g., Bathroom Exhaust Fan).\n      selector:\n        entity:\n          domain: fan\n\nmode: single\nmax_exceeded: silent\n\ntrigger:\n  - platform: numeric_state\n    entity_id: !input humidity_sensor\n    above: !input humidity_level\n    id: 'humidity_high' # Identifier for the trigger when humidity goes above the level\n\n  - platform: numeric_state\n    entity_id: !input humidity_sensor\n    below: !input humidity_level\n    id: 'humidity_low' # Identifier for the trigger when humidity goes below the level\n\naction:\n  - choose:\n      # Action to turn on the fan when humidity is high\n      - conditions:\n          - condition: trigger\n            id: 'humidity_high'\n          - condition: state # Only turn on if the fan is currently off\n            entity_id: !input fan_entity\n            state: 'off'\n        sequence:\n          - service: fan.turn_on\n            target:\n              entity_id: !input fan_entity\n            data: {} # No additional data needed for simple turn_on\n\n      # Action to turn off the fan when humidity is low\n      - conditions:\n          - condition: trigger\n            id: 'humidity_low'\n          - condition: state # Only turn off if the fan is currently on\n            entity_id: !input fan_entity\n            state: 'on'\n        sequence:\n          - service: fan.turn_off\n            target:\n              entity_id: !input fan_entity\n```","humidity_fan-test_blueprint_inputs","Good",""
"humidity_fan_humidity_fan-humidity_fan-3","gemini-2.5-flash","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\nblueprint:\n  name: Humidity Fan\n  description: Turns on a fan when the humidity level rises above a specified threshold and turns it off when the humidity drops below that threshold.\n  domain: automation\n  input:\n    humidity_sensor:\n      name: Humidity Sensor\n      description: The humidity sensor that triggers the automation (e.g., Bathroom Humidity Sensor).\n      selector:\n        entity:\n          domain: sensor\n          device_class: humidity\n    humidity_level:\n      name: Humidity Threshold (%)\n      description: The humidity percentage at which the fan should turn on/off.\n      selector:\n        number:\n          min: 0\n          max: 100\n          unit_of_measurement: '%'\n          mode: slider\n          step: 1\n          initial: 60 # Default to 60% as per example use case\n    fan_entity:\n      name: Fan Entity\n      description: The fan entity to control (e.g., Bathroom Exhaust Fan).\n      selector:\n        entity:\n          domain: fan\n\nmode: single\nmax_exceeded: silent\n\ntrigger:\n  - platform: numeric_state\n    entity_id: !input humidity_sensor\n    above: !input humidity_level\n    id: 'humidity_high' # Identifier for the trigger when humidity goes above the level\n\n  - platform: numeric_state\n    entity_id: !input humidity_sensor\n    below: !input humidity_level\n    id: 'humidity_low' # Identifier for the trigger when humidity goes below the level\n\naction:\n  - choose:\n      # Action to turn on the fan when humidity is high\n      - conditions:\n          - condition: trigger\n            id: 'humidity_high'\n          - condition: state # Only turn on if the fan is currently off\n            entity_id: !input fan_entity\n            state: 'off'\n        sequence:\n          - service: fan.turn_on\n            target:\n              entity_id: !input fan_entity\n            data: {} # No additional data needed for simple turn_on\n\n      # Action to turn off the fan when humidity is low\n      - conditions:\n          - condition: trigger\n            id: 'humidity_low'\n          - condition: state # Only turn off if the fan is currently on\n            entity_id: !input fan_entity\n            state: 'on'\n        sequence:\n          - service: fan.turn_off\n            target:\n              entity_id: !input fan_entity\n```","humidity_fan-test_fan_triggered_on","Bad","AssertionError: Unable to load automation."
"humidity_fan_humidity_fan-humidity_fan-3","gemini-2.5-flash","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\nblueprint:\n  name: Humidity Fan\n  description: Turns on a fan when the humidity level rises above a specified threshold and turns it off when the humidity drops below that threshold.\n  domain: automation\n  input:\n    humidity_sensor:\n      name: Humidity Sensor\n      description: The humidity sensor that triggers the automation (e.g., Bathroom Humidity Sensor).\n      selector:\n        entity:\n          domain: sensor\n          device_class: humidity\n    humidity_level:\n      name: Humidity Threshold (%)\n      description: The humidity percentage at which the fan should turn on/off.\n      selector:\n        number:\n          min: 0\n          max: 100\n          unit_of_measurement: '%'\n          mode: slider\n          step: 1\n          initial: 60 # Default to 60% as per example use case\n    fan_entity:\n      name: Fan Entity\n      description: The fan entity to control (e.g., Bathroom Exhaust Fan).\n      selector:\n        entity:\n          domain: fan\n\nmode: single\nmax_exceeded: silent\n\ntrigger:\n  - platform: numeric_state\n    entity_id: !input humidity_sensor\n    above: !input humidity_level\n    id: 'humidity_high' # Identifier for the trigger when humidity goes above the level\n\n  - platform: numeric_state\n    entity_id: !input humidity_sensor\n    below: !input humidity_level\n    id: 'humidity_low' # Identifier for the trigger when humidity goes below the level\n\naction:\n  - choose:\n      # Action to turn on the fan when humidity is high\n      - conditions:\n          - condition: trigger\n            id: 'humidity_high'\n          - condition: state # Only turn on if the fan is currently off\n            entity_id: !input fan_entity\n            state: 'off'\n        sequence:\n          - service: fan.turn_on\n            target:\n              entity_id: !input fan_entity\n            data: {} # No additional data needed for simple turn_on\n\n      # Action to turn off the fan when humidity is low\n      - conditions:\n          - condition: trigger\n            id: 'humidity_low'\n          - condition: state # Only turn off if the fan is currently on\n            entity_id: !input fan_entity\n            state: 'on'\n        sequence:\n          - service: fan.turn_off\n            target:\n              entity_id: !input fan_entity\n```","humidity_fan-test_fan_triggered_off","Bad","AssertionError: Unable to load automation."
"humidity_fan_humidity_fan-humidity_fan-4","gemini-2.5-flash","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\nblueprint:\n  name: Humidity Fan\n  description: Turns on a fan when humidity exceeds a specified level, and turns it off when humidity drops back below that level.\n  domain: automation\n  input:\n    humidity_sensor:\n      name: Humidity Sensor\n      description: The humidity sensor entity that will trigger the automation (e.g., bathroom humidity sensor).\n      selector:\n        entity:\n          domain: sensor\n          device_class: humidity\n    humidity_level:\n      name: Humidity Threshold (%)\n      description: The humidity level (in percent) above which the fan should turn on, and below which it should turn off.\n      default: 60\n      selector:\n        number:\n          min: 0\n          max: 100\n          step: 1\n          unit_of_measurement: '%'\n    fan_entity:\n      name: Fan Entity\n      description: The fan entity to control (e.g., bathroom exhaust fan).\n      selector:\n        entity:\n          domain: fan\n\nmode: single\nmax_exceeded: silent\n\ntrigger:\n  - platform: state\n    entity_id: !input humidity_sensor\n\naction:\n  - choose:\n      # Option 1: Turn fan ON if humidity is above the threshold and fan is currently off\n      - conditions:\n          # Check if the current humidity is above the specified level\n          - condition: template\n            value_template: '{{ trigger.to_state.state | is_number and trigger.to_state.state | float > inputs['humidity_level'] | float }}'\n          # Check if the fan is currently off to avoid unnecessary service calls\n          - condition: state\n            entity_id: !input fan_entity\n            state: 'off'\n        sequence:\n          - service: fan.turn_on\n            target:\n              entity_id: !input fan_entity\n            data: {} # No specific fan speed data required unless specified\n      # Option 2: Turn fan OFF if humidity is at or below the threshold and fan is currently on\n      - conditions:\n          # Check if the current humidity is at or below the specified level\n          - condition: template\n            value_template: '{{ trigger.to_state.state | is_number and trigger.to_state.state | float <= inputs['humidity_level'] | float }}'\n          # Check if the fan is currently on to avoid unnecessary service calls\n          - condition: state\n            entity_id: !input fan_entity\n            state: 'on'\n        sequence:\n          - service: fan.turn_off\n            target:\n              entity_id: !input fan_entity\n    default: [] # Do nothing if no conditions are met (e.g., humidity changed but didn't cross threshold, or fan is already in desired state)\n\n```","humidity_fan-test_blueprint_inputs","Good",""
"humidity_fan_humidity_fan-humidity_fan-4","gemini-2.5-flash","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\nblueprint:\n  name: Humidity Fan\n  description: Turns on a fan when humidity exceeds a specified level, and turns it off when humidity drops back below that level.\n  domain: automation\n  input:\n    humidity_sensor:\n      name: Humidity Sensor\n      description: The humidity sensor entity that will trigger the automation (e.g., bathroom humidity sensor).\n      selector:\n        entity:\n          domain: sensor\n          device_class: humidity\n    humidity_level:\n      name: Humidity Threshold (%)\n      description: The humidity level (in percent) above which the fan should turn on, and below which it should turn off.\n      default: 60\n      selector:\n        number:\n          min: 0\n          max: 100\n          step: 1\n          unit_of_measurement: '%'\n    fan_entity:\n      name: Fan Entity\n      description: The fan entity to control (e.g., bathroom exhaust fan).\n      selector:\n        entity:\n          domain: fan\n\nmode: single\nmax_exceeded: silent\n\ntrigger:\n  - platform: state\n    entity_id: !input humidity_sensor\n\naction:\n  - choose:\n      # Option 1: Turn fan ON if humidity is above the threshold and fan is currently off\n      - conditions:\n          # Check if the current humidity is above the specified level\n          - condition: template\n            value_template: '{{ trigger.to_state.state | is_number and trigger.to_state.state | float > inputs['humidity_level'] | float }}'\n          # Check if the fan is currently off to avoid unnecessary service calls\n          - condition: state\n            entity_id: !input fan_entity\n            state: 'off'\n        sequence:\n          - service: fan.turn_on\n            target:\n              entity_id: !input fan_entity\n            data: {} # No specific fan speed data required unless specified\n      # Option 2: Turn fan OFF if humidity is at or below the threshold and fan is currently on\n      - conditions:\n          # Check if the current humidity is at or below the specified level\n          - condition: template\n            value_template: '{{ trigger.to_state.state | is_number and trigger.to_state.state | float <= inputs['humidity_level'] | float }}'\n          # Check if the fan is currently on to avoid unnecessary service calls\n          - condition: state\n            entity_id: !input fan_entity\n            state: 'on'\n        sequence:\n          - service: fan.turn_off\n            target:\n              entity_id: !input fan_entity\n    default: [] # Do nothing if no conditions are met (e.g., humidity changed but didn't cross threshold, or fan is already in desired state)\n\n```","humidity_fan-test_fan_triggered_on","Bad","TimeoutError,TimeoutError: Timeout waiting for fan state to change"
"humidity_fan_humidity_fan-humidity_fan-4","gemini-2.5-flash","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\nblueprint:\n  name: Humidity Fan\n  description: Turns on a fan when humidity exceeds a specified level, and turns it off when humidity drops back below that level.\n  domain: automation\n  input:\n    humidity_sensor:\n      name: Humidity Sensor\n      description: The humidity sensor entity that will trigger the automation (e.g., bathroom humidity sensor).\n      selector:\n        entity:\n          domain: sensor\n          device_class: humidity\n    humidity_level:\n      name: Humidity Threshold (%)\n      description: The humidity level (in percent) above which the fan should turn on, and below which it should turn off.\n      default: 60\n      selector:\n        number:\n          min: 0\n          max: 100\n          step: 1\n          unit_of_measurement: '%'\n    fan_entity:\n      name: Fan Entity\n      description: The fan entity to control (e.g., bathroom exhaust fan).\n      selector:\n        entity:\n          domain: fan\n\nmode: single\nmax_exceeded: silent\n\ntrigger:\n  - platform: state\n    entity_id: !input humidity_sensor\n\naction:\n  - choose:\n      # Option 1: Turn fan ON if humidity is above the threshold and fan is currently off\n      - conditions:\n          # Check if the current humidity is above the specified level\n          - condition: template\n            value_template: '{{ trigger.to_state.state | is_number and trigger.to_state.state | float > inputs['humidity_level'] | float }}'\n          # Check if the fan is currently off to avoid unnecessary service calls\n          - condition: state\n            entity_id: !input fan_entity\n            state: 'off'\n        sequence:\n          - service: fan.turn_on\n            target:\n              entity_id: !input fan_entity\n            data: {} # No specific fan speed data required unless specified\n      # Option 2: Turn fan OFF if humidity is at or below the threshold and fan is currently on\n      - conditions:\n          # Check if the current humidity is at or below the specified level\n          - condition: template\n            value_template: '{{ trigger.to_state.state | is_number and trigger.to_state.state | float <= inputs['humidity_level'] | float }}'\n          # Check if the fan is currently on to avoid unnecessary service calls\n          - condition: state\n            entity_id: !input fan_entity\n            state: 'on'\n        sequence:\n          - service: fan.turn_off\n            target:\n              entity_id: !input fan_entity\n    default: [] # Do nothing if no conditions are met (e.g., humidity changed but didn't cross threshold, or fan is already in desired state)\n\n```","humidity_fan-test_fan_triggered_off","Bad","TimeoutError,TimeoutError: Timeout waiting for fan state to change"
"humidity_fan_humidity_fan-humidity_fan-0","gemini-2.5-flash-lite","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\n# Humidity Fan\n# https://www.home-assistant.io/docs/automation/blueprint/\n\nblueprint:\n  name: Humidity Fan\n  description: Turn on a fan based on humidity sensor readings.\n  domain: automation\n  input:\n    humidity_sensor:\n      name: Humidity Sensor\n      description: The humidity sensor to monitor.\n      selector:\n        entity:\n          domain: sensor\n          # Allow only sensors that have a humidity device class\n          device_class: humidity\n          # Ensure the sensor provides a state (is not unavailable)\n          state: 'true'\n    humidity_level:\n      name: Humidity Level (%)\n      description: The humidity percentage to turn the fan on at.\n      selector:\n        number:\n          min: 0\n          max: 100\n          unit_of_measurement: '%'\n          step: 1\n          mode: slider\n    fan_entity:\n      name: Fan Entity\n      description: The fan to control.\n      selector:\n        entity:\n          domain: fan\n          # Ensure the fan entity is available and not unavailable\n          state: 'true'\n\n# This is the actual automation that will be created.\n# It uses the inputs defined above to configure the triggers and actions.\n# The mode: 'single' ensures that only one instance of this automation can run at a time.\n# This is important to prevent multiple fans from being turned on or off unexpectedly.\nmode: single\n# Define the triggers for the automation.\n# The automation will trigger when the humidity sensor's state changes.\n# The 'above' condition ensures that the automation only triggers when the humidity\n# goes above the specified level.\n# The 'below' condition ensures that the automation only triggers when the humidity\n# goes below the specified level.\n# This ensures that the fan is turned on and off appropriately.\ntrigger:\n  # Trigger when humidity goes above the specified level\n  - platform: numeric_state\n    entity_id: !input humidity_sensor\n    above: !input humidity_level\n  # Trigger when humidity goes below the specified level\n  - platform: numeric_state\n    entity_id: !input humidity_sensor\n    below: !input humidity_level\n\n# Define the conditions for the automation.\n# The 'state' condition ensures that the fan is only turned on if it is currently off.\n# The 'state' condition also ensures that the fan is only turned off if it is currently on.\n# This prevents the automation from turning on an already on fan, or turning off an already off fan.\ncondition:\n  # This condition is for when the humidity goes above the threshold\n  # We only want to turn the fan ON if it's currently OFF\n  - condition: template\n    value_template: '{{ (trigger.platform == 'numeric_state' and trigger.entity_id == !input humidity_sensor.entity_id and trigger.above == !input humidity_level) and not is_state(!input fan_entity, 'on') }}'\n  # This condition is for when the humidity goes below the threshold\n  # We only want to turn the fan OFF if it's currently ON\n  - condition: template\n    value_template: '{{ (trigger.platform == 'numeric_state' and trigger.entity_id == !input humidity_sensor.entity_id and trigger.below == !input humidity_level) and is_state(!input fan_entity, 'on') }}'\n\n# Define the actions to be taken when the automation is triggered.\n# The 'service' action calls a service to turn the fan on or off.\n# The 'entity_id' specifies the fan to control.\n# The 'data' specifies the action to perform (turn_on or turn_off).\naction:\n  # If the humidity is above the threshold, turn the fan ON\n  - service: fan.turn_on\n    target:\n      entity_id: !input fan_entity\n    # Only execute this action if the trigger was the 'above' condition\n    # and the fan is not already on.\n    enabled: '{{ trigger.platform == 'numeric_state' and trigger.entity_id == !input humidity_sensor.entity_id and trigger.above == !input humidity_level }}'\n  # If the humidity is below the threshold, turn the fan OFF\n  - service: fan.turn_off\n    target:\n      entity_id: !input fan_entity\n    # Only execute this action if the trigger was the 'below' condition\n    # and the fan is not already off.\n    enabled: '{{ trigger.platform == 'numeric_state' and trigger.entity_id == !input humidity_sensor.entity_id and trigger.below == !input humidity_level }}'\n\n```","humidity_fan-test_blueprint_inputs","Good",""
"humidity_fan_humidity_fan-humidity_fan-0","gemini-2.5-flash-lite","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\n# Humidity Fan\n# https://www.home-assistant.io/docs/automation/blueprint/\n\nblueprint:\n  name: Humidity Fan\n  description: Turn on a fan based on humidity sensor readings.\n  domain: automation\n  input:\n    humidity_sensor:\n      name: Humidity Sensor\n      description: The humidity sensor to monitor.\n      selector:\n        entity:\n          domain: sensor\n          # Allow only sensors that have a humidity device class\n          device_class: humidity\n          # Ensure the sensor provides a state (is not unavailable)\n          state: 'true'\n    humidity_level:\n      name: Humidity Level (%)\n      description: The humidity percentage to turn the fan on at.\n      selector:\n        number:\n          min: 0\n          max: 100\n          unit_of_measurement: '%'\n          step: 1\n          mode: slider\n    fan_entity:\n      name: Fan Entity\n      description: The fan to control.\n      selector:\n        entity:\n          domain: fan\n          # Ensure the fan entity is available and not unavailable\n          state: 'true'\n\n# This is the actual automation that will be created.\n# It uses the inputs defined above to configure the triggers and actions.\n# The mode: 'single' ensures that only one instance of this automation can run at a time.\n# This is important to prevent multiple fans from being turned on or off unexpectedly.\nmode: single\n# Define the triggers for the automation.\n# The automation will trigger when the humidity sensor's state changes.\n# The 'above' condition ensures that the automation only triggers when the humidity\n# goes above the specified level.\n# The 'below' condition ensures that the automation only triggers when the humidity\n# goes below the specified level.\n# This ensures that the fan is turned on and off appropriately.\ntrigger:\n  # Trigger when humidity goes above the specified level\n  - platform: numeric_state\n    entity_id: !input humidity_sensor\n    above: !input humidity_level\n  # Trigger when humidity goes below the specified level\n  - platform: numeric_state\n    entity_id: !input humidity_sensor\n    below: !input humidity_level\n\n# Define the conditions for the automation.\n# The 'state' condition ensures that the fan is only turned on if it is currently off.\n# The 'state' condition also ensures that the fan is only turned off if it is currently on.\n# This prevents the automation from turning on an already on fan, or turning off an already off fan.\ncondition:\n  # This condition is for when the humidity goes above the threshold\n  # We only want to turn the fan ON if it's currently OFF\n  - condition: template\n    value_template: '{{ (trigger.platform == 'numeric_state' and trigger.entity_id == !input humidity_sensor.entity_id and trigger.above == !input humidity_level) and not is_state(!input fan_entity, 'on') }}'\n  # This condition is for when the humidity goes below the threshold\n  # We only want to turn the fan OFF if it's currently ON\n  - condition: template\n    value_template: '{{ (trigger.platform == 'numeric_state' and trigger.entity_id == !input humidity_sensor.entity_id and trigger.below == !input humidity_level) and is_state(!input fan_entity, 'on') }}'\n\n# Define the actions to be taken when the automation is triggered.\n# The 'service' action calls a service to turn the fan on or off.\n# The 'entity_id' specifies the fan to control.\n# The 'data' specifies the action to perform (turn_on or turn_off).\naction:\n  # If the humidity is above the threshold, turn the fan ON\n  - service: fan.turn_on\n    target:\n      entity_id: !input fan_entity\n    # Only execute this action if the trigger was the 'above' condition\n    # and the fan is not already on.\n    enabled: '{{ trigger.platform == 'numeric_state' and trigger.entity_id == !input humidity_sensor.entity_id and trigger.above == !input humidity_level }}'\n  # If the humidity is below the threshold, turn the fan OFF\n  - service: fan.turn_off\n    target:\n      entity_id: !input fan_entity\n    # Only execute this action if the trigger was the 'below' condition\n    # and the fan is not already off.\n    enabled: '{{ trigger.platform == 'numeric_state' and trigger.entity_id == !input humidity_sensor.entity_id and trigger.below == !input humidity_level }}'\n\n```","humidity_fan-test_fan_triggered_on","Bad","AssertionError: Unable to load automation."
"humidity_fan_humidity_fan-humidity_fan-0","gemini-2.5-flash-lite","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\n# Humidity Fan\n# https://www.home-assistant.io/docs/automation/blueprint/\n\nblueprint:\n  name: Humidity Fan\n  description: Turn on a fan based on humidity sensor readings.\n  domain: automation\n  input:\n    humidity_sensor:\n      name: Humidity Sensor\n      description: The humidity sensor to monitor.\n      selector:\n        entity:\n          domain: sensor\n          # Allow only sensors that have a humidity device class\n          device_class: humidity\n          # Ensure the sensor provides a state (is not unavailable)\n          state: 'true'\n    humidity_level:\n      name: Humidity Level (%)\n      description: The humidity percentage to turn the fan on at.\n      selector:\n        number:\n          min: 0\n          max: 100\n          unit_of_measurement: '%'\n          step: 1\n          mode: slider\n    fan_entity:\n      name: Fan Entity\n      description: The fan to control.\n      selector:\n        entity:\n          domain: fan\n          # Ensure the fan entity is available and not unavailable\n          state: 'true'\n\n# This is the actual automation that will be created.\n# It uses the inputs defined above to configure the triggers and actions.\n# The mode: 'single' ensures that only one instance of this automation can run at a time.\n# This is important to prevent multiple fans from being turned on or off unexpectedly.\nmode: single\n# Define the triggers for the automation.\n# The automation will trigger when the humidity sensor's state changes.\n# The 'above' condition ensures that the automation only triggers when the humidity\n# goes above the specified level.\n# The 'below' condition ensures that the automation only triggers when the humidity\n# goes below the specified level.\n# This ensures that the fan is turned on and off appropriately.\ntrigger:\n  # Trigger when humidity goes above the specified level\n  - platform: numeric_state\n    entity_id: !input humidity_sensor\n    above: !input humidity_level\n  # Trigger when humidity goes below the specified level\n  - platform: numeric_state\n    entity_id: !input humidity_sensor\n    below: !input humidity_level\n\n# Define the conditions for the automation.\n# The 'state' condition ensures that the fan is only turned on if it is currently off.\n# The 'state' condition also ensures that the fan is only turned off if it is currently on.\n# This prevents the automation from turning on an already on fan, or turning off an already off fan.\ncondition:\n  # This condition is for when the humidity goes above the threshold\n  # We only want to turn the fan ON if it's currently OFF\n  - condition: template\n    value_template: '{{ (trigger.platform == 'numeric_state' and trigger.entity_id == !input humidity_sensor.entity_id and trigger.above == !input humidity_level) and not is_state(!input fan_entity, 'on') }}'\n  # This condition is for when the humidity goes below the threshold\n  # We only want to turn the fan OFF if it's currently ON\n  - condition: template\n    value_template: '{{ (trigger.platform == 'numeric_state' and trigger.entity_id == !input humidity_sensor.entity_id and trigger.below == !input humidity_level) and is_state(!input fan_entity, 'on') }}'\n\n# Define the actions to be taken when the automation is triggered.\n# The 'service' action calls a service to turn the fan on or off.\n# The 'entity_id' specifies the fan to control.\n# The 'data' specifies the action to perform (turn_on or turn_off).\naction:\n  # If the humidity is above the threshold, turn the fan ON\n  - service: fan.turn_on\n    target:\n      entity_id: !input fan_entity\n    # Only execute this action if the trigger was the 'above' condition\n    # and the fan is not already on.\n    enabled: '{{ trigger.platform == 'numeric_state' and trigger.entity_id == !input humidity_sensor.entity_id and trigger.above == !input humidity_level }}'\n  # If the humidity is below the threshold, turn the fan OFF\n  - service: fan.turn_off\n    target:\n      entity_id: !input fan_entity\n    # Only execute this action if the trigger was the 'below' condition\n    # and the fan is not already off.\n    enabled: '{{ trigger.platform == 'numeric_state' and trigger.entity_id == !input humidity_sensor.entity_id and trigger.below == !input humidity_level }}'\n\n```","humidity_fan-test_fan_triggered_off","Bad","AssertionError: Unable to load automation."
"humidity_fan_humidity_fan-humidity_fan-1","gemini-2.5-flash-lite","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\nblueprint:\n  name: Humidity Fan Control\n  description: Turns a fan on/off based on humidity sensor readings.\n  domain: automation\n  input:\n    humidity_sensor:\n      name: Humidity Sensor\n      description: The humidity sensor to monitor.\n      selector:\n        entity:\n          domain: sensor\n          # Filter for entities that are likely humidity sensors based on their device class\n          device_class: humidity\n    humidity_level:\n      name: Humidity Threshold\n      description: The humidity percentage above which the fan should turn on.\n      selector:\n        number:\n          min: 0\n          max: 100\n          unit_of_measurement: '%'\n          mode: slider\n    fan_entity:\n      name: Fan Entity\n      description: The fan to control.\n      selector:\n        entity:\n          domain: fan\n# Define the trigger for the automation\n# This trigger will fire when the humidity sensor's state changes\ntrigger:\n  - platform: numeric_state\n    entity_id: !input humidity_sensor\n    above: !input humidity_level # Trigger when humidity goes above the set threshold\n# Define the conditions for the automation to run\n# This condition ensures the fan is not already on when we want to turn it on\ncondition:\n  # If the automation is triggered because humidity went *above* the threshold,\n  # we want to turn the fan *on*.\n  # We check if the humidity is above the threshold.\n  - condition: numeric_state\n    entity_id: !input humidity_sensor\n    above: !input humidity_level\n# Define the actions to be performed when the automation triggers and conditions are met\naction:\n  # Turn on the fan if it's not already on.\n  # The 'service' will be 'turn_on' for the fan entity.\n  - service: fan.turn_on\n    target:\n      entity_id: !input fan_entity\n# Define a second trigger to turn off the fan when humidity drops\n# This trigger will fire when the humidity sensor's state changes\n  - platform: numeric_state\n    entity_id: !input humidity_sensor\n    below: !input humidity_level # Trigger when humidity goes below the set threshold\n# Define the conditions for this second part of the automation\n# This condition ensures the fan is not already off when we want to turn it off\ncondition:\n  # If the automation is triggered because humidity went *below* the threshold,\n  # we want to turn the fan *off*.\n  # We check if the humidity is below the threshold.\n  - condition: numeric_state\n    entity_id: !input humidity_sensor\n    below: !input humidity_level\n# Define the actions to be performed when this second trigger fires and conditions are met\naction:\n  # Turn off the fan if it's not already off.\n  # The 'service' will be 'turn_off' for the fan entity.\n  - service: fan.turn_off\n    target:\n      entity_id: !input fan_entity\n\n# Note: Home Assistant automatically handles not trying to turn on an already on\n# device or turn off an already off device for these basic fan services.\n# The explicit checks for fan state are not strictly necessary with fan.turn_on\n# and fan.turn_off services, but the conditions based on humidity levels are crucial\n# for the desired behavior.\n```","humidity_fan-test_blueprint_inputs","Good",""
"humidity_fan_humidity_fan-humidity_fan-1","gemini-2.5-flash-lite","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\nblueprint:\n  name: Humidity Fan Control\n  description: Turns a fan on/off based on humidity sensor readings.\n  domain: automation\n  input:\n    humidity_sensor:\n      name: Humidity Sensor\n      description: The humidity sensor to monitor.\n      selector:\n        entity:\n          domain: sensor\n          # Filter for entities that are likely humidity sensors based on their device class\n          device_class: humidity\n    humidity_level:\n      name: Humidity Threshold\n      description: The humidity percentage above which the fan should turn on.\n      selector:\n        number:\n          min: 0\n          max: 100\n          unit_of_measurement: '%'\n          mode: slider\n    fan_entity:\n      name: Fan Entity\n      description: The fan to control.\n      selector:\n        entity:\n          domain: fan\n# Define the trigger for the automation\n# This trigger will fire when the humidity sensor's state changes\ntrigger:\n  - platform: numeric_state\n    entity_id: !input humidity_sensor\n    above: !input humidity_level # Trigger when humidity goes above the set threshold\n# Define the conditions for the automation to run\n# This condition ensures the fan is not already on when we want to turn it on\ncondition:\n  # If the automation is triggered because humidity went *above* the threshold,\n  # we want to turn the fan *on*.\n  # We check if the humidity is above the threshold.\n  - condition: numeric_state\n    entity_id: !input humidity_sensor\n    above: !input humidity_level\n# Define the actions to be performed when the automation triggers and conditions are met\naction:\n  # Turn on the fan if it's not already on.\n  # The 'service' will be 'turn_on' for the fan entity.\n  - service: fan.turn_on\n    target:\n      entity_id: !input fan_entity\n# Define a second trigger to turn off the fan when humidity drops\n# This trigger will fire when the humidity sensor's state changes\n  - platform: numeric_state\n    entity_id: !input humidity_sensor\n    below: !input humidity_level # Trigger when humidity goes below the set threshold\n# Define the conditions for this second part of the automation\n# This condition ensures the fan is not already off when we want to turn it off\ncondition:\n  # If the automation is triggered because humidity went *below* the threshold,\n  # we want to turn the fan *off*.\n  # We check if the humidity is below the threshold.\n  - condition: numeric_state\n    entity_id: !input humidity_sensor\n    below: !input humidity_level\n# Define the actions to be performed when this second trigger fires and conditions are met\naction:\n  # Turn off the fan if it's not already off.\n  # The 'service' will be 'turn_off' for the fan entity.\n  - service: fan.turn_off\n    target:\n      entity_id: !input fan_entity\n\n# Note: Home Assistant automatically handles not trying to turn on an already on\n# device or turn off an already off device for these basic fan services.\n# The explicit checks for fan state are not strictly necessary with fan.turn_on\n# and fan.turn_off services, but the conditions based on humidity levels are crucial\n# for the desired behavior.\n```","humidity_fan-test_fan_triggered_on","Bad","TimeoutError,TimeoutError: Timeout waiting for fan state to change"
"humidity_fan_humidity_fan-humidity_fan-1","gemini-2.5-flash-lite","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\nblueprint:\n  name: Humidity Fan Control\n  description: Turns a fan on/off based on humidity sensor readings.\n  domain: automation\n  input:\n    humidity_sensor:\n      name: Humidity Sensor\n      description: The humidity sensor to monitor.\n      selector:\n        entity:\n          domain: sensor\n          # Filter for entities that are likely humidity sensors based on their device class\n          device_class: humidity\n    humidity_level:\n      name: Humidity Threshold\n      description: The humidity percentage above which the fan should turn on.\n      selector:\n        number:\n          min: 0\n          max: 100\n          unit_of_measurement: '%'\n          mode: slider\n    fan_entity:\n      name: Fan Entity\n      description: The fan to control.\n      selector:\n        entity:\n          domain: fan\n# Define the trigger for the automation\n# This trigger will fire when the humidity sensor's state changes\ntrigger:\n  - platform: numeric_state\n    entity_id: !input humidity_sensor\n    above: !input humidity_level # Trigger when humidity goes above the set threshold\n# Define the conditions for the automation to run\n# This condition ensures the fan is not already on when we want to turn it on\ncondition:\n  # If the automation is triggered because humidity went *above* the threshold,\n  # we want to turn the fan *on*.\n  # We check if the humidity is above the threshold.\n  - condition: numeric_state\n    entity_id: !input humidity_sensor\n    above: !input humidity_level\n# Define the actions to be performed when the automation triggers and conditions are met\naction:\n  # Turn on the fan if it's not already on.\n  # The 'service' will be 'turn_on' for the fan entity.\n  - service: fan.turn_on\n    target:\n      entity_id: !input fan_entity\n# Define a second trigger to turn off the fan when humidity drops\n# This trigger will fire when the humidity sensor's state changes\n  - platform: numeric_state\n    entity_id: !input humidity_sensor\n    below: !input humidity_level # Trigger when humidity goes below the set threshold\n# Define the conditions for this second part of the automation\n# This condition ensures the fan is not already off when we want to turn it off\ncondition:\n  # If the automation is triggered because humidity went *below* the threshold,\n  # we want to turn the fan *off*.\n  # We check if the humidity is below the threshold.\n  - condition: numeric_state\n    entity_id: !input humidity_sensor\n    below: !input humidity_level\n# Define the actions to be performed when this second trigger fires and conditions are met\naction:\n  # Turn off the fan if it's not already off.\n  # The 'service' will be 'turn_off' for the fan entity.\n  - service: fan.turn_off\n    target:\n      entity_id: !input fan_entity\n\n# Note: Home Assistant automatically handles not trying to turn on an already on\n# device or turn off an already off device for these basic fan services.\n# The explicit checks for fan state are not strictly necessary with fan.turn_on\n# and fan.turn_off services, but the conditions based on humidity levels are crucial\n# for the desired behavior.\n```","humidity_fan-test_fan_triggered_off","Good",""
"humidity_fan_humidity_fan-humidity_fan-2","gemini-2.5-flash-lite","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\n# Home Assistant Blueprint for Humidity-Based Fan Control\n#\n# Author: Your Name\n# Version: 1.0.0\n# Description: Automatically controls a fan based on humidity levels from a sensor.\n#\n# Example Use Cases:\n# - Turn on the bathroom exhaust fan when humidity exceeds 60%.\n# - Ensure the garage does not become too humid by running a fan.\n\nblueprint:\n  name: Humidity Fan Control\n  description: Automatically controls a fan based on humidity levels from a sensor.\n  domain: automation\n  source_url: https://github.com/your_github_username/home-assistant-blueprints/blob/main/humidity_fan.yaml # Replace with your actual URL if applicable\n\n# Define input parameters for the user to configure\ninput:\n  humidity_sensor:\n    name: Humidity Sensor\n    description: The humidity sensor entity to monitor.\n    selector:\n      entity:\n        domain: sensor\n        # Filter for entities that are likely humidity sensors (common attributes)\n        # This is a best-effort filter and might need adjustment based on your entities.\n        # Common device classes for humidity: 'humidity'\n        # Common unit of measurement: '%'\n        # You might want to check the actual attributes of your humidity sensors.\n        # For example, if your humidity sensor has `device_class: humidity` and `unit_of_measurement: '%'`.\n        # You can also omit filters if you want to allow any sensor and rely on the user to pick correctly.\n        # Example filter:\n        # device_class: humidity\n        # unit_of_measurement: '%'\n  humidity_level:\n    name: Humidity Trigger Level (%)\n    description: The humidity percentage at which to turn the fan on.\n    selector:\n      number:\n        min: 0\n        max: 100\n        unit_of_measurement: '%'\n        mode: slider\n        step: 1\n        initial: 60 # Default to 60%\n  fan_entity:\n    name: Fan Entity\n    description: The fan entity to control.\n    selector:\n      entity:\n        domain: fan\n\n# Define the automation's triggers, conditions, and actions\ntrigger:\n  # Trigger when the humidity sensor's state changes\n  - platform: state\n    entity_id: !input humidity_sensor\n    # The 'from' and 'to' states are used to detect changes.\n    # We don't specify them here to trigger on any change.\n\ncondition:\n  # Trigger only if the humidity level is above the set threshold\n  - condition: numeric_state\n    entity_id: !input humidity_sensor\n    above: !input humidity_level\n\naction:\n  # Action to turn on the fan\n  - service: fan.turn_on\n    target:\n      entity_id: !input fan_entity\n    # This condition ensures we don't try to turn the fan on if it's already on.\n    # This is handled implicitly by fan.turn_on, but can be made explicit if needed.\n    # For more complex logic (e.g., turning off when humidity drops), additional triggers/conditions are needed.\n    # The request implies turning the fan *on* when humidity goes *above*, and stopping when it goes *below*.\n    # This blueprint currently handles turning ON when above.\n    # To handle turning OFF when below, a separate trigger or a more complex combined trigger is needed.\n    # Let's refine the logic to handle both ON and OFF based on thresholds.\n\n# To handle turning OFF when humidity drops below a certain level, we need to consider two scenarios:\n# 1. Humidity goes ABOVE threshold -> Turn ON fan\n# 2. Humidity goes BELOW threshold -> Turn OFF fan\n\n# Let's restructure the automation to handle both directions.\n# We can use two separate triggers or a single trigger with complex conditions.\n# A single trigger that monitors the humidity sensor state changes and then checks conditions is often cleaner.\n\n# Reworking the automation based on the description:\n# 'The automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When triggered, the fan should be turned on.'\n# 'The fan should also be stopped when the sensor goes back down below the desired level.'\n# 'The automation should not try to turn the fan on if it is already on, and should not turn the fan off when it is already off.'\n\n# To achieve the 'turn off when below' part, we need a trigger that detects when the humidity *drops* below a level.\n# This typically means we need to define a 'turn off' threshold, which might be different from the 'turn on' threshold\n# to prevent rapid cycling (hysteresis). The prompt doesn't specify a hysteresis level, so we'll assume a simple drop below the ON level.\n\n# Let's refine the blueprint structure for both ON and OFF actions.\n\n# We can use a single trigger that fires whenever the humidity sensor state changes.\n# Then, we use conditions to determine if we should turn ON or OFF the fan.\n\ntrigger:\n  - platform: state\n    entity_id: !input humidity_sensor\n\naction:\n  - choose:\n      # If humidity is above the threshold AND the fan is off, turn it on\n      - conditions:\n          - condition: numeric_state\n            entity_id: !input humidity_sensor\n            above: !input humidity_level\n          - condition: state\n            entity_id: !input fan_entity\n            state: 'off'\n        sequence:\n          - service: fan.turn_on\n            target:\n              entity_id: !input fan_entity\n      # If humidity is below the threshold AND the fan is on, turn it off\n      # We need a 'below' threshold. Let's assume it's the same as the 'above' threshold for simplicity,\n      # but a separate 'off_level' input would be better for hysteresis.\n      # For now, let's use the same level for simplicity as per the prompt.\n      - conditions:\n          - condition: numeric_state\n            entity_id: !input humidity_sensor\n            below: !input humidity_level\n          - condition: state\n            entity_id: !input fan_entity\n            state: 'on'\n        sequence:\n          - service: fan.turn_off\n            target:\n              entity_id: !input fan_entity\n    # The default case is for when neither condition is met (e.g., humidity is normal and fan is off,\n    # or humidity is normal and fan is on). In these cases, we do nothing.\n    # default: [] # No explicit default action needed.\n\n# Final check on the requirements:\n# - Trigger when humidity sensor level goes above humidity_level: Yes, handled by the first 'choose' condition.\n# - When triggered, fan should be turned on: Yes.\n# - Fan should be stopped when the sensor goes back down below the desired level: Yes, handled by the second 'choose' condition.\n# - Automation should not try to turn the fan on if it is already on: Yes, handled by the `state: 'off'` condition in the first 'choose'.\n# - Automation should not turn the fan off when it is already off: Yes, handled by the `state: 'on'` condition in the second 'choose'.\n\n# One refinement: The prompt mentions 'when the sensor goes back down below the desired level'.\n# If the 'desired level' is strictly the ON level, then the current logic is fine.\n# However, typically, there's a hysteresis band. E.g., turn ON at 60%, turn OFF at 50%.\n# The blueprint currently doesn't allow for a separate OFF level.\n# For this blueprint, we'll stick to the prompt's wording and use the same level for ON and OFF thresholds.\n# If hysteresis is desired, an additional input_number for 'humidity_level_off' would be needed.\n\n# Let's add comments to explain the structure clearly.\n\n```","humidity_fan-test_blueprint_inputs","Bad","AssertionError"
"humidity_fan_humidity_fan-humidity_fan-2","gemini-2.5-flash-lite","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\n# Home Assistant Blueprint for Humidity-Based Fan Control\n#\n# Author: Your Name\n# Version: 1.0.0\n# Description: Automatically controls a fan based on humidity levels from a sensor.\n#\n# Example Use Cases:\n# - Turn on the bathroom exhaust fan when humidity exceeds 60%.\n# - Ensure the garage does not become too humid by running a fan.\n\nblueprint:\n  name: Humidity Fan Control\n  description: Automatically controls a fan based on humidity levels from a sensor.\n  domain: automation\n  source_url: https://github.com/your_github_username/home-assistant-blueprints/blob/main/humidity_fan.yaml # Replace with your actual URL if applicable\n\n# Define input parameters for the user to configure\ninput:\n  humidity_sensor:\n    name: Humidity Sensor\n    description: The humidity sensor entity to monitor.\n    selector:\n      entity:\n        domain: sensor\n        # Filter for entities that are likely humidity sensors (common attributes)\n        # This is a best-effort filter and might need adjustment based on your entities.\n        # Common device classes for humidity: 'humidity'\n        # Common unit of measurement: '%'\n        # You might want to check the actual attributes of your humidity sensors.\n        # For example, if your humidity sensor has `device_class: humidity` and `unit_of_measurement: '%'`.\n        # You can also omit filters if you want to allow any sensor and rely on the user to pick correctly.\n        # Example filter:\n        # device_class: humidity\n        # unit_of_measurement: '%'\n  humidity_level:\n    name: Humidity Trigger Level (%)\n    description: The humidity percentage at which to turn the fan on.\n    selector:\n      number:\n        min: 0\n        max: 100\n        unit_of_measurement: '%'\n        mode: slider\n        step: 1\n        initial: 60 # Default to 60%\n  fan_entity:\n    name: Fan Entity\n    description: The fan entity to control.\n    selector:\n      entity:\n        domain: fan\n\n# Define the automation's triggers, conditions, and actions\ntrigger:\n  # Trigger when the humidity sensor's state changes\n  - platform: state\n    entity_id: !input humidity_sensor\n    # The 'from' and 'to' states are used to detect changes.\n    # We don't specify them here to trigger on any change.\n\ncondition:\n  # Trigger only if the humidity level is above the set threshold\n  - condition: numeric_state\n    entity_id: !input humidity_sensor\n    above: !input humidity_level\n\naction:\n  # Action to turn on the fan\n  - service: fan.turn_on\n    target:\n      entity_id: !input fan_entity\n    # This condition ensures we don't try to turn the fan on if it's already on.\n    # This is handled implicitly by fan.turn_on, but can be made explicit if needed.\n    # For more complex logic (e.g., turning off when humidity drops), additional triggers/conditions are needed.\n    # The request implies turning the fan *on* when humidity goes *above*, and stopping when it goes *below*.\n    # This blueprint currently handles turning ON when above.\n    # To handle turning OFF when below, a separate trigger or a more complex combined trigger is needed.\n    # Let's refine the logic to handle both ON and OFF based on thresholds.\n\n# To handle turning OFF when humidity drops below a certain level, we need to consider two scenarios:\n# 1. Humidity goes ABOVE threshold -> Turn ON fan\n# 2. Humidity goes BELOW threshold -> Turn OFF fan\n\n# Let's restructure the automation to handle both directions.\n# We can use two separate triggers or a single trigger with complex conditions.\n# A single trigger that monitors the humidity sensor state changes and then checks conditions is often cleaner.\n\n# Reworking the automation based on the description:\n# 'The automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When triggered, the fan should be turned on.'\n# 'The fan should also be stopped when the sensor goes back down below the desired level.'\n# 'The automation should not try to turn the fan on if it is already on, and should not turn the fan off when it is already off.'\n\n# To achieve the 'turn off when below' part, we need a trigger that detects when the humidity *drops* below a level.\n# This typically means we need to define a 'turn off' threshold, which might be different from the 'turn on' threshold\n# to prevent rapid cycling (hysteresis). The prompt doesn't specify a hysteresis level, so we'll assume a simple drop below the ON level.\n\n# Let's refine the blueprint structure for both ON and OFF actions.\n\n# We can use a single trigger that fires whenever the humidity sensor state changes.\n# Then, we use conditions to determine if we should turn ON or OFF the fan.\n\ntrigger:\n  - platform: state\n    entity_id: !input humidity_sensor\n\naction:\n  - choose:\n      # If humidity is above the threshold AND the fan is off, turn it on\n      - conditions:\n          - condition: numeric_state\n            entity_id: !input humidity_sensor\n            above: !input humidity_level\n          - condition: state\n            entity_id: !input fan_entity\n            state: 'off'\n        sequence:\n          - service: fan.turn_on\n            target:\n              entity_id: !input fan_entity\n      # If humidity is below the threshold AND the fan is on, turn it off\n      # We need a 'below' threshold. Let's assume it's the same as the 'above' threshold for simplicity,\n      # but a separate 'off_level' input would be better for hysteresis.\n      # For now, let's use the same level for simplicity as per the prompt.\n      - conditions:\n          - condition: numeric_state\n            entity_id: !input humidity_sensor\n            below: !input humidity_level\n          - condition: state\n            entity_id: !input fan_entity\n            state: 'on'\n        sequence:\n          - service: fan.turn_off\n            target:\n              entity_id: !input fan_entity\n    # The default case is for when neither condition is met (e.g., humidity is normal and fan is off,\n    # or humidity is normal and fan is on). In these cases, we do nothing.\n    # default: [] # No explicit default action needed.\n\n# Final check on the requirements:\n# - Trigger when humidity sensor level goes above humidity_level: Yes, handled by the first 'choose' condition.\n# - When triggered, fan should be turned on: Yes.\n# - Fan should be stopped when the sensor goes back down below the desired level: Yes, handled by the second 'choose' condition.\n# - Automation should not try to turn the fan on if it is already on: Yes, handled by the `state: 'off'` condition in the first 'choose'.\n# - Automation should not turn the fan off when it is already off: Yes, handled by the `state: 'on'` condition in the second 'choose'.\n\n# One refinement: The prompt mentions 'when the sensor goes back down below the desired level'.\n# If the 'desired level' is strictly the ON level, then the current logic is fine.\n# However, typically, there's a hysteresis band. E.g., turn ON at 60%, turn OFF at 50%.\n# The blueprint currently doesn't allow for a separate OFF level.\n# For this blueprint, we'll stick to the prompt's wording and use the same level for ON and OFF thresholds.\n# If hysteresis is desired, an additional input_number for 'humidity_level_off' would be needed.\n\n# Let's add comments to explain the structure clearly.\n\n```","humidity_fan-test_fan_triggered_on","Bad","AssertionError: Unable to load automation."
"humidity_fan_humidity_fan-humidity_fan-2","gemini-2.5-flash-lite","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\n# Home Assistant Blueprint for Humidity-Based Fan Control\n#\n# Author: Your Name\n# Version: 1.0.0\n# Description: Automatically controls a fan based on humidity levels from a sensor.\n#\n# Example Use Cases:\n# - Turn on the bathroom exhaust fan when humidity exceeds 60%.\n# - Ensure the garage does not become too humid by running a fan.\n\nblueprint:\n  name: Humidity Fan Control\n  description: Automatically controls a fan based on humidity levels from a sensor.\n  domain: automation\n  source_url: https://github.com/your_github_username/home-assistant-blueprints/blob/main/humidity_fan.yaml # Replace with your actual URL if applicable\n\n# Define input parameters for the user to configure\ninput:\n  humidity_sensor:\n    name: Humidity Sensor\n    description: The humidity sensor entity to monitor.\n    selector:\n      entity:\n        domain: sensor\n        # Filter for entities that are likely humidity sensors (common attributes)\n        # This is a best-effort filter and might need adjustment based on your entities.\n        # Common device classes for humidity: 'humidity'\n        # Common unit of measurement: '%'\n        # You might want to check the actual attributes of your humidity sensors.\n        # For example, if your humidity sensor has `device_class: humidity` and `unit_of_measurement: '%'`.\n        # You can also omit filters if you want to allow any sensor and rely on the user to pick correctly.\n        # Example filter:\n        # device_class: humidity\n        # unit_of_measurement: '%'\n  humidity_level:\n    name: Humidity Trigger Level (%)\n    description: The humidity percentage at which to turn the fan on.\n    selector:\n      number:\n        min: 0\n        max: 100\n        unit_of_measurement: '%'\n        mode: slider\n        step: 1\n        initial: 60 # Default to 60%\n  fan_entity:\n    name: Fan Entity\n    description: The fan entity to control.\n    selector:\n      entity:\n        domain: fan\n\n# Define the automation's triggers, conditions, and actions\ntrigger:\n  # Trigger when the humidity sensor's state changes\n  - platform: state\n    entity_id: !input humidity_sensor\n    # The 'from' and 'to' states are used to detect changes.\n    # We don't specify them here to trigger on any change.\n\ncondition:\n  # Trigger only if the humidity level is above the set threshold\n  - condition: numeric_state\n    entity_id: !input humidity_sensor\n    above: !input humidity_level\n\naction:\n  # Action to turn on the fan\n  - service: fan.turn_on\n    target:\n      entity_id: !input fan_entity\n    # This condition ensures we don't try to turn the fan on if it's already on.\n    # This is handled implicitly by fan.turn_on, but can be made explicit if needed.\n    # For more complex logic (e.g., turning off when humidity drops), additional triggers/conditions are needed.\n    # The request implies turning the fan *on* when humidity goes *above*, and stopping when it goes *below*.\n    # This blueprint currently handles turning ON when above.\n    # To handle turning OFF when below, a separate trigger or a more complex combined trigger is needed.\n    # Let's refine the logic to handle both ON and OFF based on thresholds.\n\n# To handle turning OFF when humidity drops below a certain level, we need to consider two scenarios:\n# 1. Humidity goes ABOVE threshold -> Turn ON fan\n# 2. Humidity goes BELOW threshold -> Turn OFF fan\n\n# Let's restructure the automation to handle both directions.\n# We can use two separate triggers or a single trigger with complex conditions.\n# A single trigger that monitors the humidity sensor state changes and then checks conditions is often cleaner.\n\n# Reworking the automation based on the description:\n# 'The automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When triggered, the fan should be turned on.'\n# 'The fan should also be stopped when the sensor goes back down below the desired level.'\n# 'The automation should not try to turn the fan on if it is already on, and should not turn the fan off when it is already off.'\n\n# To achieve the 'turn off when below' part, we need a trigger that detects when the humidity *drops* below a level.\n# This typically means we need to define a 'turn off' threshold, which might be different from the 'turn on' threshold\n# to prevent rapid cycling (hysteresis). The prompt doesn't specify a hysteresis level, so we'll assume a simple drop below the ON level.\n\n# Let's refine the blueprint structure for both ON and OFF actions.\n\n# We can use a single trigger that fires whenever the humidity sensor state changes.\n# Then, we use conditions to determine if we should turn ON or OFF the fan.\n\ntrigger:\n  - platform: state\n    entity_id: !input humidity_sensor\n\naction:\n  - choose:\n      # If humidity is above the threshold AND the fan is off, turn it on\n      - conditions:\n          - condition: numeric_state\n            entity_id: !input humidity_sensor\n            above: !input humidity_level\n          - condition: state\n            entity_id: !input fan_entity\n            state: 'off'\n        sequence:\n          - service: fan.turn_on\n            target:\n              entity_id: !input fan_entity\n      # If humidity is below the threshold AND the fan is on, turn it off\n      # We need a 'below' threshold. Let's assume it's the same as the 'above' threshold for simplicity,\n      # but a separate 'off_level' input would be better for hysteresis.\n      # For now, let's use the same level for simplicity as per the prompt.\n      - conditions:\n          - condition: numeric_state\n            entity_id: !input humidity_sensor\n            below: !input humidity_level\n          - condition: state\n            entity_id: !input fan_entity\n            state: 'on'\n        sequence:\n          - service: fan.turn_off\n            target:\n              entity_id: !input fan_entity\n    # The default case is for when neither condition is met (e.g., humidity is normal and fan is off,\n    # or humidity is normal and fan is on). In these cases, we do nothing.\n    # default: [] # No explicit default action needed.\n\n# Final check on the requirements:\n# - Trigger when humidity sensor level goes above humidity_level: Yes, handled by the first 'choose' condition.\n# - When triggered, fan should be turned on: Yes.\n# - Fan should be stopped when the sensor goes back down below the desired level: Yes, handled by the second 'choose' condition.\n# - Automation should not try to turn the fan on if it is already on: Yes, handled by the `state: 'off'` condition in the first 'choose'.\n# - Automation should not turn the fan off when it is already off: Yes, handled by the `state: 'on'` condition in the second 'choose'.\n\n# One refinement: The prompt mentions 'when the sensor goes back down below the desired level'.\n# If the 'desired level' is strictly the ON level, then the current logic is fine.\n# However, typically, there's a hysteresis band. E.g., turn ON at 60%, turn OFF at 50%.\n# The blueprint currently doesn't allow for a separate OFF level.\n# For this blueprint, we'll stick to the prompt's wording and use the same level for ON and OFF thresholds.\n# If hysteresis is desired, an additional input_number for 'humidity_level_off' would be needed.\n\n# Let's add comments to explain the structure clearly.\n\n```","humidity_fan-test_fan_triggered_off","Bad","AssertionError: Unable to load automation."
"humidity_fan_humidity_fan-humidity_fan-3","gemini-2.5-flash-lite","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\nblueprint:\n  name: Humidity Fan\n  description: Turns on a fan when humidity rises above a set level and turns it off when it falls below.\n  domain: automation\n  source_url: https://github.com/your_username/your_repo/blob/main/humidity_fan.yaml # Replace with your actual URL\n  input:\n    humidity_sensor:\n      name: Humidity Sensor\n      description: Select the humidity sensor to monitor.\n      selector:\n        entity:\n          domain: sensor\n          # We expect the state to be a number, which is usually the case for humidity sensors.\n          # Filtering by device_class 'humidity' can also be a good practice if available.\n          # device_class: humidity # Uncomment if you want to enforce this device class\n    humidity_level:\n      name: Humidity Level\n      description: The humidity percentage to trigger the fan.\n      selector:\n        number:\n          min: 0\n          max: 100\n          step: 1\n          unit_of_measurement: '%'\n          mode: slider\n    fan_entity:\n      name: Fan Entity\n      description: Select the fan to control.\n      selector:\n        entity:\n          domain: fan\n\n# Trigger when humidity goes above the specified level.\ntrigger:\n  - platform: numeric_state\n    entity_id: !input humidity_sensor\n    above: !input humidity_level\n    # This trigger should only fire if the fan is currently off.\n    # We will handle the turning on in the action.\n\n# Trigger when humidity goes below the specified level.\n# This will be used to turn the fan off.\n- platform: numeric_state\n  entity_id: !input humidity_sensor\n  below: !input humidity_level\n  # This trigger should only fire if the fan is currently on.\n  # We will handle the turning off in the action.\n\n# Actions to perform when triggered.\naction:\n  # If the humidity is above the level, turn the fan on.\n  - choose:\n      # If the humidity sensor is above the humidity level...\n      - conditions:\n          - condition: numeric_state\n            entity_id: !input humidity_sensor\n            above: !input humidity_level\n        sequence:\n          # ...and the fan is not already on, turn it on.\n          - service: fan.turn_on\n            target:\n              entity_id: !input fan_entity\n            data: {}\n      # If the humidity sensor is below the humidity level...\n      - conditions:\n          - condition: numeric_state\n            entity_id: !input humidity_sensor\n            below: !input humidity_level\n        sequence:\n          # ...and the fan is not already off, turn it off.\n          - service: fan.turn_off\n            target:\n              entity_id: !input fan_entity\n            data: {}\n    # This default case handles situations where the trigger might have fired\n    # but the conditions inside the choose statement are not met (e.g., if the fan\n    # state changed unexpectedly between the trigger and action).\n    # In this simple case, we don't need a specific default action as the\n    # conditions within the choose handle the desired state changes.\n    default: []\n\n# This mode ensures that if the humidity fluctuates rapidly, the fan doesn't\n# keep turning on and off unnecessarily in quick succession.\nmode: single\n```","humidity_fan-test_blueprint_inputs","Bad","^,AssertionError: Blueprint was not valid yaml: while parsing a block mapping   in '<unicode string>', line 1, column 1:     blueprint:     ^ expected <block end>, but found '-'   in '<unicode string>', line 43, column 1:     - platform: numeric_state     ^"
"humidity_fan_humidity_fan-humidity_fan-3","gemini-2.5-flash-lite","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\nblueprint:\n  name: Humidity Fan\n  description: Turns on a fan when humidity rises above a set level and turns it off when it falls below.\n  domain: automation\n  source_url: https://github.com/your_username/your_repo/blob/main/humidity_fan.yaml # Replace with your actual URL\n  input:\n    humidity_sensor:\n      name: Humidity Sensor\n      description: Select the humidity sensor to monitor.\n      selector:\n        entity:\n          domain: sensor\n          # We expect the state to be a number, which is usually the case for humidity sensors.\n          # Filtering by device_class 'humidity' can also be a good practice if available.\n          # device_class: humidity # Uncomment if you want to enforce this device class\n    humidity_level:\n      name: Humidity Level\n      description: The humidity percentage to trigger the fan.\n      selector:\n        number:\n          min: 0\n          max: 100\n          step: 1\n          unit_of_measurement: '%'\n          mode: slider\n    fan_entity:\n      name: Fan Entity\n      description: Select the fan to control.\n      selector:\n        entity:\n          domain: fan\n\n# Trigger when humidity goes above the specified level.\ntrigger:\n  - platform: numeric_state\n    entity_id: !input humidity_sensor\n    above: !input humidity_level\n    # This trigger should only fire if the fan is currently off.\n    # We will handle the turning on in the action.\n\n# Trigger when humidity goes below the specified level.\n# This will be used to turn the fan off.\n- platform: numeric_state\n  entity_id: !input humidity_sensor\n  below: !input humidity_level\n  # This trigger should only fire if the fan is currently on.\n  # We will handle the turning off in the action.\n\n# Actions to perform when triggered.\naction:\n  # If the humidity is above the level, turn the fan on.\n  - choose:\n      # If the humidity sensor is above the humidity level...\n      - conditions:\n          - condition: numeric_state\n            entity_id: !input humidity_sensor\n            above: !input humidity_level\n        sequence:\n          # ...and the fan is not already on, turn it on.\n          - service: fan.turn_on\n            target:\n              entity_id: !input fan_entity\n            data: {}\n      # If the humidity sensor is below the humidity level...\n      - conditions:\n          - condition: numeric_state\n            entity_id: !input humidity_sensor\n            below: !input humidity_level\n        sequence:\n          # ...and the fan is not already off, turn it off.\n          - service: fan.turn_off\n            target:\n              entity_id: !input fan_entity\n            data: {}\n    # This default case handles situations where the trigger might have fired\n    # but the conditions inside the choose statement are not met (e.g., if the fan\n    # state changed unexpectedly between the trigger and action).\n    # In this simple case, we don't need a specific default action as the\n    # conditions within the choose handle the desired state changes.\n    default: []\n\n# This mode ensures that if the humidity fluctuates rapidly, the fan doesn't\n# keep turning on and off unnecessarily in quick succession.\nmode: single\n```","humidity_fan-test_fan_triggered_on","Bad","AssertionError: Unable to load automation."
"humidity_fan_humidity_fan-humidity_fan-3","gemini-2.5-flash-lite","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\nblueprint:\n  name: Humidity Fan\n  description: Turns on a fan when humidity rises above a set level and turns it off when it falls below.\n  domain: automation\n  source_url: https://github.com/your_username/your_repo/blob/main/humidity_fan.yaml # Replace with your actual URL\n  input:\n    humidity_sensor:\n      name: Humidity Sensor\n      description: Select the humidity sensor to monitor.\n      selector:\n        entity:\n          domain: sensor\n          # We expect the state to be a number, which is usually the case for humidity sensors.\n          # Filtering by device_class 'humidity' can also be a good practice if available.\n          # device_class: humidity # Uncomment if you want to enforce this device class\n    humidity_level:\n      name: Humidity Level\n      description: The humidity percentage to trigger the fan.\n      selector:\n        number:\n          min: 0\n          max: 100\n          step: 1\n          unit_of_measurement: '%'\n          mode: slider\n    fan_entity:\n      name: Fan Entity\n      description: Select the fan to control.\n      selector:\n        entity:\n          domain: fan\n\n# Trigger when humidity goes above the specified level.\ntrigger:\n  - platform: numeric_state\n    entity_id: !input humidity_sensor\n    above: !input humidity_level\n    # This trigger should only fire if the fan is currently off.\n    # We will handle the turning on in the action.\n\n# Trigger when humidity goes below the specified level.\n# This will be used to turn the fan off.\n- platform: numeric_state\n  entity_id: !input humidity_sensor\n  below: !input humidity_level\n  # This trigger should only fire if the fan is currently on.\n  # We will handle the turning off in the action.\n\n# Actions to perform when triggered.\naction:\n  # If the humidity is above the level, turn the fan on.\n  - choose:\n      # If the humidity sensor is above the humidity level...\n      - conditions:\n          - condition: numeric_state\n            entity_id: !input humidity_sensor\n            above: !input humidity_level\n        sequence:\n          # ...and the fan is not already on, turn it on.\n          - service: fan.turn_on\n            target:\n              entity_id: !input fan_entity\n            data: {}\n      # If the humidity sensor is below the humidity level...\n      - conditions:\n          - condition: numeric_state\n            entity_id: !input humidity_sensor\n            below: !input humidity_level\n        sequence:\n          # ...and the fan is not already off, turn it off.\n          - service: fan.turn_off\n            target:\n              entity_id: !input fan_entity\n            data: {}\n    # This default case handles situations where the trigger might have fired\n    # but the conditions inside the choose statement are not met (e.g., if the fan\n    # state changed unexpectedly between the trigger and action).\n    # In this simple case, we don't need a specific default action as the\n    # conditions within the choose handle the desired state changes.\n    default: []\n\n# This mode ensures that if the humidity fluctuates rapidly, the fan doesn't\n# keep turning on and off unnecessarily in quick succession.\nmode: single\n```","humidity_fan-test_fan_triggered_off","Bad","AssertionError: Unable to load automation."
"humidity_fan_humidity_fan-humidity_fan-4","gemini-2.5-flash-lite","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\n# Humidity Fan\n#\n# Blueprint to control a fan based on humidity levels.\n#\n# Example use cases:\n# - Turn on the bathroom exhaust fan when the bathroom humidity is above 60%\n# - Make sure the garage does not get too humid\nblueprint:\n  name: Humidity Fan\n  description: Controls a fan based on humidity sensor readings.\n  domain: automation\n  input:\n    humidity_sensor:\n      name: Humidity Sensor\n      description: The humidity sensor entity (e.g., 'sensor.bathroom_humidity').\n      selector:\n        entity:\n          domain: sensor\n    humidity_level:\n      name: Humidity Level\n      description: The humidity percentage (e.g., 60) above which the fan should turn on.\n      selector:\n        number:\n          min: 0\n          max: 100\n          step: 1\n          unit_of_measurement: '%'\n          mode: slider\n    fan_entity:\n      name: Fan Entity\n      description: The fan entity to control (e.g., 'fan.bathroom_fan').\n      selector:\n        entity:\n          domain: fan\n\n# The automation triggers when the humidity sensor state changes.\ntrigger:\n  # Trigger when the humidity sensor's state changes.\n  - platform: state\n    entity_id: !input humidity_sensor\n    # The 'to' field is not strictly necessary here because we want to trigger\n    # on any change, and the conditions will filter for the desired humidity level.\n    # However, specifying it can sometimes lead to slightly more efficient triggering\n    # if the platform optimizes for state changes to a particular type of value.\n    # For humidity sensors, these are typically numeric.\n    to:\n\n# Conditions for the automation to run.\ncondition:\n  # Condition 1: Check if the current humidity is above the specified level.\n  - condition: numeric_state\n    entity_id: !input humidity_sensor\n    above: !input humidity_level\n  # Condition 2: Ensure the fan is currently off before turning it on.\n  # This prevents unnecessary service calls if the fan is already on.\n  - condition: state\n    entity_id: !input fan_entity\n    state: 'off'\n\n# Actions to perform when the trigger and conditions are met.\naction:\n  # Turn on the fan entity specified in the input.\n  - service: fan.turn_on\n    target:\n      entity_id: !input fan_entity\n\n# This is a second trigger/action pair to handle turning the fan off.\n# We need a separate trigger for when the humidity drops below the threshold.\n# Note: Home Assistant automations can have multiple trigger/condition/action sets.\n# This approach is common for 'turn on when X, turn off when Y' logic.\n# However, a more robust approach for turning off would be a separate automation\n# or by using a 'wait_for_trigger' within a single automation, which can be complex.\n# For this blueprint, we'll use a simpler approach where the fan is turned ON\n# by the first trigger/action set, and the OFF logic is handled implicitly by\n# the fact that the automation will re-evaluate when humidity drops, and\n# if the fan is ON, a separate automation or condition would be needed to turn it off.\n#\n# Let's refine this: The original request implies turning the fan OFF when humidity drops.\n# This requires a separate trigger/action set or a more complex automation structure.\n# A common pattern for this is to have a separate 'turn off' automation,\n# or to use `choose` actions. Let's use `choose` to handle both on and off within one.\n\n# Let's restructure to handle both ON and OFF. This typically involves\n# either two separate automations defined by the blueprint or a more complex\n# single automation using `choose`. For a blueprint, defining two distinct\n# automation configurations might be cleaner for the user, but a single\n# automation with `choose` is more efficient. Let's go with a single automation\n# and rely on the trigger to re-evaluate.\n\n# Rethinking the OFF logic: The request states 'The fan should also be stopped when\n# the sensor goes back down below the desired level.'\n# This requires a trigger when humidity drops.\n# A single automation can handle this by having two trigger blocks.\n\n# Corrected Structure:\n# Trigger 1: Humidity goes ABOVE threshold -> Turn ON fan (if off)\n# Trigger 2: Humidity goes BELOW threshold -> Turn OFF fan (if on)\n\n# Re-defining the blueprint with two trigger blocks for clarity and to meet the requirements.\n\ntrigger:\n  # Trigger 1: When humidity goes above the threshold\n  - platform: numeric_state\n    entity_id: !input humidity_sensor\n    above: !input humidity_level\n  # Trigger 2: When humidity goes below the threshold\n  - platform: numeric_state\n    entity_id: !input humidity_sensor\n    below: !input humidity_level\n\n# Using 'choose' to handle the ON/OFF logic based on the trigger that fired.\naction:\n  - choose:\n      # If Trigger 1 fired (humidity went ABOVE threshold)\n      - conditions:\n          # Check if the humidity is indeed above the level\n          - condition: numeric_state\n            entity_id: !input humidity_sensor\n            above: !input humidity_level\n          # And if the fan is currently off\n          - condition: state\n            entity_id: !input fan_entity\n            state: 'off'\n        sequence:\n          # Turn the fan on\n          - service: fan.turn_on\n            target:\n              entity_id: !input fan_entity\n      # If Trigger 2 fired (humidity went BELOW threshold)\n      - conditions:\n          # Check if the humidity is indeed below the level\n          - condition: numeric_state\n            entity_id: !input humidity_sensor\n            below: !input humidity_level\n          # And if the fan is currently on\n          - condition: state\n            entity_id: !input fan_entity\n            state: 'on'\n        sequence:\n          # Turn the fan off\n          - service: fan.turn_off\n            target:\n              entity_id: !input fan_entity\n    # If neither of the above conditions are met (e.g., humidity is at the threshold\n    # and we don't want to act), do nothing.\n    default: []\n```","humidity_fan-test_blueprint_inputs","Good",""
"humidity_fan_humidity_fan-humidity_fan-4","gemini-2.5-flash-lite","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\n# Humidity Fan\n#\n# Blueprint to control a fan based on humidity levels.\n#\n# Example use cases:\n# - Turn on the bathroom exhaust fan when the bathroom humidity is above 60%\n# - Make sure the garage does not get too humid\nblueprint:\n  name: Humidity Fan\n  description: Controls a fan based on humidity sensor readings.\n  domain: automation\n  input:\n    humidity_sensor:\n      name: Humidity Sensor\n      description: The humidity sensor entity (e.g., 'sensor.bathroom_humidity').\n      selector:\n        entity:\n          domain: sensor\n    humidity_level:\n      name: Humidity Level\n      description: The humidity percentage (e.g., 60) above which the fan should turn on.\n      selector:\n        number:\n          min: 0\n          max: 100\n          step: 1\n          unit_of_measurement: '%'\n          mode: slider\n    fan_entity:\n      name: Fan Entity\n      description: The fan entity to control (e.g., 'fan.bathroom_fan').\n      selector:\n        entity:\n          domain: fan\n\n# The automation triggers when the humidity sensor state changes.\ntrigger:\n  # Trigger when the humidity sensor's state changes.\n  - platform: state\n    entity_id: !input humidity_sensor\n    # The 'to' field is not strictly necessary here because we want to trigger\n    # on any change, and the conditions will filter for the desired humidity level.\n    # However, specifying it can sometimes lead to slightly more efficient triggering\n    # if the platform optimizes for state changes to a particular type of value.\n    # For humidity sensors, these are typically numeric.\n    to:\n\n# Conditions for the automation to run.\ncondition:\n  # Condition 1: Check if the current humidity is above the specified level.\n  - condition: numeric_state\n    entity_id: !input humidity_sensor\n    above: !input humidity_level\n  # Condition 2: Ensure the fan is currently off before turning it on.\n  # This prevents unnecessary service calls if the fan is already on.\n  - condition: state\n    entity_id: !input fan_entity\n    state: 'off'\n\n# Actions to perform when the trigger and conditions are met.\naction:\n  # Turn on the fan entity specified in the input.\n  - service: fan.turn_on\n    target:\n      entity_id: !input fan_entity\n\n# This is a second trigger/action pair to handle turning the fan off.\n# We need a separate trigger for when the humidity drops below the threshold.\n# Note: Home Assistant automations can have multiple trigger/condition/action sets.\n# This approach is common for 'turn on when X, turn off when Y' logic.\n# However, a more robust approach for turning off would be a separate automation\n# or by using a 'wait_for_trigger' within a single automation, which can be complex.\n# For this blueprint, we'll use a simpler approach where the fan is turned ON\n# by the first trigger/action set, and the OFF logic is handled implicitly by\n# the fact that the automation will re-evaluate when humidity drops, and\n# if the fan is ON, a separate automation or condition would be needed to turn it off.\n#\n# Let's refine this: The original request implies turning the fan OFF when humidity drops.\n# This requires a separate trigger/action set or a more complex automation structure.\n# A common pattern for this is to have a separate 'turn off' automation,\n# or to use `choose` actions. Let's use `choose` to handle both on and off within one.\n\n# Let's restructure to handle both ON and OFF. This typically involves\n# either two separate automations defined by the blueprint or a more complex\n# single automation using `choose`. For a blueprint, defining two distinct\n# automation configurations might be cleaner for the user, but a single\n# automation with `choose` is more efficient. Let's go with a single automation\n# and rely on the trigger to re-evaluate.\n\n# Rethinking the OFF logic: The request states 'The fan should also be stopped when\n# the sensor goes back down below the desired level.'\n# This requires a trigger when humidity drops.\n# A single automation can handle this by having two trigger blocks.\n\n# Corrected Structure:\n# Trigger 1: Humidity goes ABOVE threshold -> Turn ON fan (if off)\n# Trigger 2: Humidity goes BELOW threshold -> Turn OFF fan (if on)\n\n# Re-defining the blueprint with two trigger blocks for clarity and to meet the requirements.\n\ntrigger:\n  # Trigger 1: When humidity goes above the threshold\n  - platform: numeric_state\n    entity_id: !input humidity_sensor\n    above: !input humidity_level\n  # Trigger 2: When humidity goes below the threshold\n  - platform: numeric_state\n    entity_id: !input humidity_sensor\n    below: !input humidity_level\n\n# Using 'choose' to handle the ON/OFF logic based on the trigger that fired.\naction:\n  - choose:\n      # If Trigger 1 fired (humidity went ABOVE threshold)\n      - conditions:\n          # Check if the humidity is indeed above the level\n          - condition: numeric_state\n            entity_id: !input humidity_sensor\n            above: !input humidity_level\n          # And if the fan is currently off\n          - condition: state\n            entity_id: !input fan_entity\n            state: 'off'\n        sequence:\n          # Turn the fan on\n          - service: fan.turn_on\n            target:\n              entity_id: !input fan_entity\n      # If Trigger 2 fired (humidity went BELOW threshold)\n      - conditions:\n          # Check if the humidity is indeed below the level\n          - condition: numeric_state\n            entity_id: !input humidity_sensor\n            below: !input humidity_level\n          # And if the fan is currently on\n          - condition: state\n            entity_id: !input fan_entity\n            state: 'on'\n        sequence:\n          # Turn the fan off\n          - service: fan.turn_off\n            target:\n              entity_id: !input fan_entity\n    # If neither of the above conditions are met (e.g., humidity is at the threshold\n    # and we don't want to act), do nothing.\n    default: []\n```","humidity_fan-test_fan_triggered_on","Good",""
"humidity_fan_humidity_fan-humidity_fan-4","gemini-2.5-flash-lite","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\n# Humidity Fan\n#\n# Blueprint to control a fan based on humidity levels.\n#\n# Example use cases:\n# - Turn on the bathroom exhaust fan when the bathroom humidity is above 60%\n# - Make sure the garage does not get too humid\nblueprint:\n  name: Humidity Fan\n  description: Controls a fan based on humidity sensor readings.\n  domain: automation\n  input:\n    humidity_sensor:\n      name: Humidity Sensor\n      description: The humidity sensor entity (e.g., 'sensor.bathroom_humidity').\n      selector:\n        entity:\n          domain: sensor\n    humidity_level:\n      name: Humidity Level\n      description: The humidity percentage (e.g., 60) above which the fan should turn on.\n      selector:\n        number:\n          min: 0\n          max: 100\n          step: 1\n          unit_of_measurement: '%'\n          mode: slider\n    fan_entity:\n      name: Fan Entity\n      description: The fan entity to control (e.g., 'fan.bathroom_fan').\n      selector:\n        entity:\n          domain: fan\n\n# The automation triggers when the humidity sensor state changes.\ntrigger:\n  # Trigger when the humidity sensor's state changes.\n  - platform: state\n    entity_id: !input humidity_sensor\n    # The 'to' field is not strictly necessary here because we want to trigger\n    # on any change, and the conditions will filter for the desired humidity level.\n    # However, specifying it can sometimes lead to slightly more efficient triggering\n    # if the platform optimizes for state changes to a particular type of value.\n    # For humidity sensors, these are typically numeric.\n    to:\n\n# Conditions for the automation to run.\ncondition:\n  # Condition 1: Check if the current humidity is above the specified level.\n  - condition: numeric_state\n    entity_id: !input humidity_sensor\n    above: !input humidity_level\n  # Condition 2: Ensure the fan is currently off before turning it on.\n  # This prevents unnecessary service calls if the fan is already on.\n  - condition: state\n    entity_id: !input fan_entity\n    state: 'off'\n\n# Actions to perform when the trigger and conditions are met.\naction:\n  # Turn on the fan entity specified in the input.\n  - service: fan.turn_on\n    target:\n      entity_id: !input fan_entity\n\n# This is a second trigger/action pair to handle turning the fan off.\n# We need a separate trigger for when the humidity drops below the threshold.\n# Note: Home Assistant automations can have multiple trigger/condition/action sets.\n# This approach is common for 'turn on when X, turn off when Y' logic.\n# However, a more robust approach for turning off would be a separate automation\n# or by using a 'wait_for_trigger' within a single automation, which can be complex.\n# For this blueprint, we'll use a simpler approach where the fan is turned ON\n# by the first trigger/action set, and the OFF logic is handled implicitly by\n# the fact that the automation will re-evaluate when humidity drops, and\n# if the fan is ON, a separate automation or condition would be needed to turn it off.\n#\n# Let's refine this: The original request implies turning the fan OFF when humidity drops.\n# This requires a separate trigger/action set or a more complex automation structure.\n# A common pattern for this is to have a separate 'turn off' automation,\n# or to use `choose` actions. Let's use `choose` to handle both on and off within one.\n\n# Let's restructure to handle both ON and OFF. This typically involves\n# either two separate automations defined by the blueprint or a more complex\n# single automation using `choose`. For a blueprint, defining two distinct\n# automation configurations might be cleaner for the user, but a single\n# automation with `choose` is more efficient. Let's go with a single automation\n# and rely on the trigger to re-evaluate.\n\n# Rethinking the OFF logic: The request states 'The fan should also be stopped when\n# the sensor goes back down below the desired level.'\n# This requires a trigger when humidity drops.\n# A single automation can handle this by having two trigger blocks.\n\n# Corrected Structure:\n# Trigger 1: Humidity goes ABOVE threshold -> Turn ON fan (if off)\n# Trigger 2: Humidity goes BELOW threshold -> Turn OFF fan (if on)\n\n# Re-defining the blueprint with two trigger blocks for clarity and to meet the requirements.\n\ntrigger:\n  # Trigger 1: When humidity goes above the threshold\n  - platform: numeric_state\n    entity_id: !input humidity_sensor\n    above: !input humidity_level\n  # Trigger 2: When humidity goes below the threshold\n  - platform: numeric_state\n    entity_id: !input humidity_sensor\n    below: !input humidity_level\n\n# Using 'choose' to handle the ON/OFF logic based on the trigger that fired.\naction:\n  - choose:\n      # If Trigger 1 fired (humidity went ABOVE threshold)\n      - conditions:\n          # Check if the humidity is indeed above the level\n          - condition: numeric_state\n            entity_id: !input humidity_sensor\n            above: !input humidity_level\n          # And if the fan is currently off\n          - condition: state\n            entity_id: !input fan_entity\n            state: 'off'\n        sequence:\n          # Turn the fan on\n          - service: fan.turn_on\n            target:\n              entity_id: !input fan_entity\n      # If Trigger 2 fired (humidity went BELOW threshold)\n      - conditions:\n          # Check if the humidity is indeed below the level\n          - condition: numeric_state\n            entity_id: !input humidity_sensor\n            below: !input humidity_level\n          # And if the fan is currently on\n          - condition: state\n            entity_id: !input fan_entity\n            state: 'on'\n        sequence:\n          # Turn the fan off\n          - service: fan.turn_off\n            target:\n              entity_id: !input fan_entity\n    # If neither of the above conditions are met (e.g., humidity is at the threshold\n    # and we don't want to act), do nothing.\n    default: []\n```","humidity_fan-test_fan_triggered_off","Bad","TimeoutError,TimeoutError: Timeout waiting for fan state to change"
"humidity_fan_humidity_fan-humidity_fan-0","qwen3-1.7b","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\n## Humidity Fan Automation\n\n## Configuration\nautomation:\n  - trigger:\n    - platform: sensor\n      entity_id: sensor.humidty_sensor\n  - action:\n    - service: fan.turn_on\n      service_data:\n        entity_id: fan.fan_entity\n\n  - trigger:\n    - platform: sensor\n      entity_id: sensor.humidty_sensor\n    - condition:\n      - condition: sensor.state > 0\n      - value: 60\n  - action:\n    - service: fan.turn_off\n    - service_data:\n      entity_id: fan.fan_entity\n\n  - trigger:\n    - platform: sensor\n      entity_id: sensor.humidty_sensor\n    - condition:\n      - condition: sensor.state < 0\n      - value: 60\n  - action:\n    - service: fan.turn_off\n    - service_data:\n      entity_id: fan.fan_entity\n```","humidity_fan-test_blueprint_inputs","Bad","AssertionError: Blueprint yaml did not contain 'blueprint:' key"
"humidity_fan_humidity_fan-humidity_fan-0","qwen3-1.7b","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\n## Humidity Fan Automation\n\n## Configuration\nautomation:\n  - trigger:\n    - platform: sensor\n      entity_id: sensor.humidty_sensor\n  - action:\n    - service: fan.turn_on\n      service_data:\n        entity_id: fan.fan_entity\n\n  - trigger:\n    - platform: sensor\n      entity_id: sensor.humidty_sensor\n    - condition:\n      - condition: sensor.state > 0\n      - value: 60\n  - action:\n    - service: fan.turn_off\n    - service_data:\n      entity_id: fan.fan_entity\n\n  - trigger:\n    - platform: sensor\n      entity_id: sensor.humidty_sensor\n    - condition:\n      - condition: sensor.state < 0\n      - value: 60\n  - action:\n    - service: fan.turn_off\n    - service_data:\n      entity_id: fan.fan_entity\n```","humidity_fan-test_fan_triggered_on","Bad","AssertionError: Unable to load automation."
"humidity_fan_humidity_fan-humidity_fan-0","qwen3-1.7b","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\n## Humidity Fan Automation\n\n## Configuration\nautomation:\n  - trigger:\n    - platform: sensor\n      entity_id: sensor.humidty_sensor\n  - action:\n    - service: fan.turn_on\n      service_data:\n        entity_id: fan.fan_entity\n\n  - trigger:\n    - platform: sensor\n      entity_id: sensor.humidty_sensor\n    - condition:\n      - condition: sensor.state > 0\n      - value: 60\n  - action:\n    - service: fan.turn_off\n    - service_data:\n      entity_id: fan.fan_entity\n\n  - trigger:\n    - platform: sensor\n      entity_id: sensor.humidty_sensor\n    - condition:\n      - condition: sensor.state < 0\n      - value: 60\n  - action:\n    - service: fan.turn_off\n    - service_data:\n      entity_id: fan.fan_entity\n```","humidity_fan-test_fan_triggered_off","Bad","AssertionError: Unable to load automation."
"humidity_fan_humidity_fan-humidity_fan-1","qwen3-1.7b","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\n# Humidity Fan Automation\n\n# Define the automation\nautomation:\n  # Automation to turn on the fan when humidity is above a certain level\n  - id: 'humidity_fan_automation'\n    entry: 'Home Assistant'\n    description: 'Turn on the fan when humidity is above a certain level'\n    trigger:\n      - platform: sensor\n        sensor:\n          entity_id: 'sensor.humidity_sensor'\n    action:\n      - service: fan.turn_on\n        data:\n          entity_id: '{{ fan_entity }}'\n    conditions:\n      - platform: template\n        condition: (states('sensor.humidity_sensor').state == '100%' or states('sensor.humidity_sensor').state == '100%') and (states('sensor.humidity_sensor').state > humidity_level)\n    - platform: template\n      condition: (states('sensor.humidity_sensor').state < humidity_level)\n    - platform: template\n      condition: (states('fan.entity').state == 'on')\n    - platform: template\n      condition: (states('fan.entity').state == 'off')\n```\n\n```yaml\n# Configuration for the humidity fan blueprint\n\n# Define the sensor entity\nsensor.humidity_sensor:\n  name: 'Humidity Sensor'\n  unit_of_measurement: '%'\n  value_template: '{{ states('sensor.humidity_sensor').state }}'\n\n# Define the number selector\nnumber.humidity_level:\n  name: 'Humidity Level'\n  unit_of_measurement: '%'\n  value_template: '{{ states('number.humidity_level').state }}'\n\n# Define the fan entity\nfan.exhaust_fan:\n  name: 'Exhaust Fan'\n  entity_id: 'fan.exhaust_fan'\n  command: 'turn_on'\n  command_template: '{{ states('fan.exhaust_fan').state }}'\n```","humidity_fan-test_blueprint_inputs","Bad","^,AssertionError: Blueprint was not valid yaml: while parsing a block mapping   in '<unicode string>', line 5, column 3:       name: 'Humidity Sensor'       ^ expected <block end>, but found '<scalar>'   in '<unicode string>', line 7, column 31:       value_template: '{{ states('sensor.humidity_sensor').state }}'                                   ^"
"humidity_fan_humidity_fan-humidity_fan-1","qwen3-1.7b","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\n# Humidity Fan Automation\n\n# Define the automation\nautomation:\n  # Automation to turn on the fan when humidity is above a certain level\n  - id: 'humidity_fan_automation'\n    entry: 'Home Assistant'\n    description: 'Turn on the fan when humidity is above a certain level'\n    trigger:\n      - platform: sensor\n        sensor:\n          entity_id: 'sensor.humidity_sensor'\n    action:\n      - service: fan.turn_on\n        data:\n          entity_id: '{{ fan_entity }}'\n    conditions:\n      - platform: template\n        condition: (states('sensor.humidity_sensor').state == '100%' or states('sensor.humidity_sensor').state == '100%') and (states('sensor.humidity_sensor').state > humidity_level)\n    - platform: template\n      condition: (states('sensor.humidity_sensor').state < humidity_level)\n    - platform: template\n      condition: (states('fan.entity').state == 'on')\n    - platform: template\n      condition: (states('fan.entity').state == 'off')\n```\n\n```yaml\n# Configuration for the humidity fan blueprint\n\n# Define the sensor entity\nsensor.humidity_sensor:\n  name: 'Humidity Sensor'\n  unit_of_measurement: '%'\n  value_template: '{{ states('sensor.humidity_sensor').state }}'\n\n# Define the number selector\nnumber.humidity_level:\n  name: 'Humidity Level'\n  unit_of_measurement: '%'\n  value_template: '{{ states('number.humidity_level').state }}'\n\n# Define the fan entity\nfan.exhaust_fan:\n  name: 'Exhaust Fan'\n  entity_id: 'fan.exhaust_fan'\n  command: 'turn_on'\n  command_template: '{{ states('fan.exhaust_fan').state }}'\n```","humidity_fan-test_fan_triggered_on","Bad","AssertionError: Unable to load automation."
"humidity_fan_humidity_fan-humidity_fan-1","qwen3-1.7b","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\n# Humidity Fan Automation\n\n# Define the automation\nautomation:\n  # Automation to turn on the fan when humidity is above a certain level\n  - id: 'humidity_fan_automation'\n    entry: 'Home Assistant'\n    description: 'Turn on the fan when humidity is above a certain level'\n    trigger:\n      - platform: sensor\n        sensor:\n          entity_id: 'sensor.humidity_sensor'\n    action:\n      - service: fan.turn_on\n        data:\n          entity_id: '{{ fan_entity }}'\n    conditions:\n      - platform: template\n        condition: (states('sensor.humidity_sensor').state == '100%' or states('sensor.humidity_sensor').state == '100%') and (states('sensor.humidity_sensor').state > humidity_level)\n    - platform: template\n      condition: (states('sensor.humidity_sensor').state < humidity_level)\n    - platform: template\n      condition: (states('fan.entity').state == 'on')\n    - platform: template\n      condition: (states('fan.entity').state == 'off')\n```\n\n```yaml\n# Configuration for the humidity fan blueprint\n\n# Define the sensor entity\nsensor.humidity_sensor:\n  name: 'Humidity Sensor'\n  unit_of_measurement: '%'\n  value_template: '{{ states('sensor.humidity_sensor').state }}'\n\n# Define the number selector\nnumber.humidity_level:\n  name: 'Humidity Level'\n  unit_of_measurement: '%'\n  value_template: '{{ states('number.humidity_level').state }}'\n\n# Define the fan entity\nfan.exhaust_fan:\n  name: 'Exhaust Fan'\n  entity_id: 'fan.exhaust_fan'\n  command: 'turn_on'\n  command_template: '{{ states('fan.exhaust_fan').state }}'\n```","humidity_fan-test_fan_triggered_off","Bad","AssertionError: Unable to load automation."
"humidity_fan_humidity_fan-humidity_fan-2","qwen3-1.7b","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\n## Humidity Fan Automation\n\n## Configuration\nautomation:\n  - trigger:\n    - platform: sensor\n      sensor: humidity_sensor\n  - action:\n    - service: fan.turn_on\n      service_data:\n        entity_id: fan.fan_entity\n\n  - trigger:\n    - platform: sensor\n    - sensor: humidity_sensor\n    - value: above\n    - threshold: 60\n  - action:\n    - service: fan.turn_off\n    - service_data:\n      entity_id: fan.fan_entity\n\n  - trigger:\n    - platform: sensor\n    - sensor: humidity_sensor\n    - value: below\n    - threshold: 60\n  - action:\n    - service: fan.turn_off\n    - service_data:\n      entity_id: fan.fan_entity\n```","humidity_fan-test_blueprint_inputs","Bad","AssertionError: Blueprint yaml did not contain 'blueprint:' key"
"humidity_fan_humidity_fan-humidity_fan-2","qwen3-1.7b","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\n## Humidity Fan Automation\n\n## Configuration\nautomation:\n  - trigger:\n    - platform: sensor\n      sensor: humidity_sensor\n  - action:\n    - service: fan.turn_on\n      service_data:\n        entity_id: fan.fan_entity\n\n  - trigger:\n    - platform: sensor\n    - sensor: humidity_sensor\n    - value: above\n    - threshold: 60\n  - action:\n    - service: fan.turn_off\n    - service_data:\n      entity_id: fan.fan_entity\n\n  - trigger:\n    - platform: sensor\n    - sensor: humidity_sensor\n    - value: below\n    - threshold: 60\n  - action:\n    - service: fan.turn_off\n    - service_data:\n      entity_id: fan.fan_entity\n```","humidity_fan-test_fan_triggered_on","Bad","AssertionError: Unable to load automation."
"humidity_fan_humidity_fan-humidity_fan-2","qwen3-1.7b","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\n## Humidity Fan Automation\n\n## Configuration\nautomation:\n  - trigger:\n    - platform: sensor\n      sensor: humidity_sensor\n  - action:\n    - service: fan.turn_on\n      service_data:\n        entity_id: fan.fan_entity\n\n  - trigger:\n    - platform: sensor\n    - sensor: humidity_sensor\n    - value: above\n    - threshold: 60\n  - action:\n    - service: fan.turn_off\n    - service_data:\n      entity_id: fan.fan_entity\n\n  - trigger:\n    - platform: sensor\n    - sensor: humidity_sensor\n    - value: below\n    - threshold: 60\n  - action:\n    - service: fan.turn_off\n    - service_data:\n      entity_id: fan.fan_entity\n```","humidity_fan-test_fan_triggered_off","Bad","AssertionError: Unable to load automation."
"humidity_fan_humidity_fan-humidity_fan-3","qwen3-1.7b","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\n## Humidity Fan Automation\n\n## Blueprint Configuration\n\n## Inputs\n- humidity_sensor: A sensor entity that is a humidity sensor that triggers the automation.\n- humidity_level: A number selector to set the value used as the trigger.\n- fan_entity: A fan entity to turn on when the automation fires.\n\n## Automation\n- When the humidity_sensor level is above humidity_level, turn on the fan_entity.\n- When the humidity_sensor level is below humidity_level, turn off the fan_entity.\n- Do not turn on the fan if it is already on.\n- Do not turn off the fan if it is already off.\n\n## YAML Configuration\n```yaml\nautomation:\n  - trigger:\n      platform: sensor\n      sensor: humidity_sensor\n    action:\n      service: fan.turn_on\n      target: {{ fan_entity }}\n      if: state is 'on'\n\n  - trigger:\n      platform: sensor\n      sensor: humidity_sensor\n    action:\n      service: fan.turn_off\n      target: {{ fan_entity }}\n      if: state is 'off'\n```","humidity_fan-test_blueprint_inputs","Bad","^,AssertionError: Blueprint was not valid yaml: while constructing a mapping   in '<unicode string>', line 7, column 15:           target: {{ fan_entity }}                   ^ found unhashable key   in '<unicode string>', line 7, column 16:           target: {{ fan_entity }}                    ^"
"humidity_fan_humidity_fan-humidity_fan-3","qwen3-1.7b","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\n## Humidity Fan Automation\n\n## Blueprint Configuration\n\n## Inputs\n- humidity_sensor: A sensor entity that is a humidity sensor that triggers the automation.\n- humidity_level: A number selector to set the value used as the trigger.\n- fan_entity: A fan entity to turn on when the automation fires.\n\n## Automation\n- When the humidity_sensor level is above humidity_level, turn on the fan_entity.\n- When the humidity_sensor level is below humidity_level, turn off the fan_entity.\n- Do not turn on the fan if it is already on.\n- Do not turn off the fan if it is already off.\n\n## YAML Configuration\n```yaml\nautomation:\n  - trigger:\n      platform: sensor\n      sensor: humidity_sensor\n    action:\n      service: fan.turn_on\n      target: {{ fan_entity }}\n      if: state is 'on'\n\n  - trigger:\n      platform: sensor\n      sensor: humidity_sensor\n    action:\n      service: fan.turn_off\n      target: {{ fan_entity }}\n      if: state is 'off'\n```","humidity_fan-test_fan_triggered_on","Bad","AssertionError: Unable to load automation."
"humidity_fan_humidity_fan-humidity_fan-3","qwen3-1.7b","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\n## Humidity Fan Automation\n\n## Blueprint Configuration\n\n## Inputs\n- humidity_sensor: A sensor entity that is a humidity sensor that triggers the automation.\n- humidity_level: A number selector to set the value used as the trigger.\n- fan_entity: A fan entity to turn on when the automation fires.\n\n## Automation\n- When the humidity_sensor level is above humidity_level, turn on the fan_entity.\n- When the humidity_sensor level is below humidity_level, turn off the fan_entity.\n- Do not turn on the fan if it is already on.\n- Do not turn off the fan if it is already off.\n\n## YAML Configuration\n```yaml\nautomation:\n  - trigger:\n      platform: sensor\n      sensor: humidity_sensor\n    action:\n      service: fan.turn_on\n      target: {{ fan_entity }}\n      if: state is 'on'\n\n  - trigger:\n      platform: sensor\n      sensor: humidity_sensor\n    action:\n      service: fan.turn_off\n      target: {{ fan_entity }}\n      if: state is 'off'\n```","humidity_fan-test_fan_triggered_off","Bad","AssertionError: Unable to load automation."
"humidity_fan_humidity_fan-humidity_fan-4","qwen3-1.7b","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\n# Humidity Fan Automation\n# This automation turns on the fan when humidity is above a certain level and turns it off when it drops below.\n\nautomation:\n  - trigger:\n      platform: sensor\n      sensor:\n        entity_id: sensor.humidty_sensor\n  - action:\n      service: fan.turn_on\n      service_data:\n        entity_id: fan.fan_entity\n  - trigger:\n      platform: sensor\n      sensor:\n        entity_id: sensor.humidty_sensor\n      value: above\n      value_threshold: 60\n  - action:\n      service: fan.turn_off\n      service_data:\n        entity_id: fan.fan_entity\n```","humidity_fan-test_blueprint_inputs","Bad","AssertionError: Blueprint yaml did not contain 'blueprint:' key"
"humidity_fan_humidity_fan-humidity_fan-4","qwen3-1.7b","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\n# Humidity Fan Automation\n# This automation turns on the fan when humidity is above a certain level and turns it off when it drops below.\n\nautomation:\n  - trigger:\n      platform: sensor\n      sensor:\n        entity_id: sensor.humidty_sensor\n  - action:\n      service: fan.turn_on\n      service_data:\n        entity_id: fan.fan_entity\n  - trigger:\n      platform: sensor\n      sensor:\n        entity_id: sensor.humidty_sensor\n      value: above\n      value_threshold: 60\n  - action:\n      service: fan.turn_off\n      service_data:\n        entity_id: fan.fan_entity\n```","humidity_fan-test_fan_triggered_on","Bad","AssertionError: Unable to load automation."
"humidity_fan_humidity_fan-humidity_fan-4","qwen3-1.7b","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\n# Humidity Fan Automation\n# This automation turns on the fan when humidity is above a certain level and turns it off when it drops below.\n\nautomation:\n  - trigger:\n      platform: sensor\n      sensor:\n        entity_id: sensor.humidty_sensor\n  - action:\n      service: fan.turn_on\n      service_data:\n        entity_id: fan.fan_entity\n  - trigger:\n      platform: sensor\n      sensor:\n        entity_id: sensor.humidty_sensor\n      value: above\n      value_threshold: 60\n  - action:\n      service: fan.turn_off\n      service_data:\n        entity_id: fan.fan_entity\n```","humidity_fan-test_fan_triggered_off","Bad","AssertionError: Unable to load automation."
"humidity_fan_humidity_fan-humidity_fan-0","qwen3-4b","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\nblueprint:\n  name: Humidity Fan\n  description: Turns on the fan based on the value of the humidity sensor.\n  inputs:\n    humidity_sensor:\n      friendly_name: Humidity Sensor\n      type: sensor\n    humidity_level:\n      friendly_name: Humidity Level\n      type: number\n    fan_entity:\n      friendly_name: Fan Entity\n      type: fan\n  steps:\n    - step: Check if the humidity sensor value is above the set level\n      condition:\n        condition: state\n        entity_id: '{{ humidity_sensor }}'\n        below: '{{ humidity_level }}'\n      then:\n        - action: turn_off\n          entity_id: '{{ fan_entity }}'\n    - step: Turn on the fan if it is not already on\n      condition:\n        condition: state\n        entity_id: '{{ fan_entity }}'\n        not:\n          - state: 'on'\n      then:\n        - action: turn_on\n          entity_id: '{{ fan_entity }}'\n```","humidity_fan-test_blueprint_inputs","Bad","AssertionError"
"humidity_fan_humidity_fan-humidity_fan-0","qwen3-4b","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\nblueprint:\n  name: Humidity Fan\n  description: Turns on the fan based on the value of the humidity sensor.\n  inputs:\n    humidity_sensor:\n      friendly_name: Humidity Sensor\n      type: sensor\n    humidity_level:\n      friendly_name: Humidity Level\n      type: number\n    fan_entity:\n      friendly_name: Fan Entity\n      type: fan\n  steps:\n    - step: Check if the humidity sensor value is above the set level\n      condition:\n        condition: state\n        entity_id: '{{ humidity_sensor }}'\n        below: '{{ humidity_level }}'\n      then:\n        - action: turn_off\n          entity_id: '{{ fan_entity }}'\n    - step: Turn on the fan if it is not already on\n      condition:\n        condition: state\n        entity_id: '{{ fan_entity }}'\n        not:\n          - state: 'on'\n      then:\n        - action: turn_on\n          entity_id: '{{ fan_entity }}'\n```","humidity_fan-test_fan_triggered_on","Bad","AssertionError: Unable to load automation."
"humidity_fan_humidity_fan-humidity_fan-0","qwen3-4b","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\nblueprint:\n  name: Humidity Fan\n  description: Turns on the fan based on the value of the humidity sensor.\n  inputs:\n    humidity_sensor:\n      friendly_name: Humidity Sensor\n      type: sensor\n    humidity_level:\n      friendly_name: Humidity Level\n      type: number\n    fan_entity:\n      friendly_name: Fan Entity\n      type: fan\n  steps:\n    - step: Check if the humidity sensor value is above the set level\n      condition:\n        condition: state\n        entity_id: '{{ humidity_sensor }}'\n        below: '{{ humidity_level }}'\n      then:\n        - action: turn_off\n          entity_id: '{{ fan_entity }}'\n    - step: Turn on the fan if it is not already on\n      condition:\n        condition: state\n        entity_id: '{{ fan_entity }}'\n        not:\n          - state: 'on'\n      then:\n        - action: turn_on\n          entity_id: '{{ fan_entity }}'\n```","humidity_fan-test_fan_triggered_off","Bad","AssertionError: Unable to load automation."
"humidity_fan_humidity_fan-humidity_fan-1","qwen3-4b","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\nblueprint:\n  name: Humidity Fan\n  description: Automate a fan based on humidity sensor values.\n  inputs:\n    humidity_sensor:\n      friendly_name: Humidity Sensor\n      type: sensor\n    humidity_level:\n      friendly_name: Humidity Level\n      type: number\n    fan_entity:\n      friendly_name: Fan Entity\n      type: fan\n  steps:\n    - step: Check if humidity is above the set level\n      delay: 10\n      condition:\n        condition: state\n        entity_id: '{{ humidity_sensor }}'\n        below: '{{ humidity_level }}'\n      action:\n        service: light.turn_on\n        target:\n          entity_id: '{{ fan_entity }}'\n    - step: Check if humidity is below the set level\n      delay: 10\n      condition:\n        condition: state\n        entity_id: '{{ fan_entity }}'\n        is: 'on'\n      action:\n        service: light.turn_off\n        target:\n          entity_id: '{{ fan_entity }}'\n```","humidity_fan-test_blueprint_inputs","Bad","AssertionError"
"humidity_fan_humidity_fan-humidity_fan-1","qwen3-4b","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\nblueprint:\n  name: Humidity Fan\n  description: Automate a fan based on humidity sensor values.\n  inputs:\n    humidity_sensor:\n      friendly_name: Humidity Sensor\n      type: sensor\n    humidity_level:\n      friendly_name: Humidity Level\n      type: number\n    fan_entity:\n      friendly_name: Fan Entity\n      type: fan\n  steps:\n    - step: Check if humidity is above the set level\n      delay: 10\n      condition:\n        condition: state\n        entity_id: '{{ humidity_sensor }}'\n        below: '{{ humidity_level }}'\n      action:\n        service: light.turn_on\n        target:\n          entity_id: '{{ fan_entity }}'\n    - step: Check if humidity is below the set level\n      delay: 10\n      condition:\n        condition: state\n        entity_id: '{{ fan_entity }}'\n        is: 'on'\n      action:\n        service: light.turn_off\n        target:\n          entity_id: '{{ fan_entity }}'\n```","humidity_fan-test_fan_triggered_on","Bad","AssertionError: Unable to load automation."
"humidity_fan_humidity_fan-humidity_fan-1","qwen3-4b","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\nblueprint:\n  name: Humidity Fan\n  description: Automate a fan based on humidity sensor values.\n  inputs:\n    humidity_sensor:\n      friendly_name: Humidity Sensor\n      type: sensor\n    humidity_level:\n      friendly_name: Humidity Level\n      type: number\n    fan_entity:\n      friendly_name: Fan Entity\n      type: fan\n  steps:\n    - step: Check if humidity is above the set level\n      delay: 10\n      condition:\n        condition: state\n        entity_id: '{{ humidity_sensor }}'\n        below: '{{ humidity_level }}'\n      action:\n        service: light.turn_on\n        target:\n          entity_id: '{{ fan_entity }}'\n    - step: Check if humidity is below the set level\n      delay: 10\n      condition:\n        condition: state\n        entity_id: '{{ fan_entity }}'\n        is: 'on'\n      action:\n        service: light.turn_off\n        target:\n          entity_id: '{{ fan_entity }}'\n```","humidity_fan-test_fan_triggered_off","Bad","AssertionError: Unable to load automation."
"humidity_fan_humidity_fan-humidity_fan-2","qwen3-4b","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\nblueprint:\n  name: Humidity Fan\n  inputs:\n    humidity_sensor:\n      friendly_name: Humidity Sensor\n      type: sensor\n    humidity_level:\n      friendly_name: Humidity Level\n      type: number\n    fan_entity:\n      friendly_name: Fan Entity\n      type: fan\n  steps:\n    - step: Check if humidity is above the set level\n      action: condition\n      condition: state\n      below: '{{ humidity_sensor.state | float }}'\n      above: '{{ humidity_level }}'\n      then:\n        - step: Turn on the fan if it's not already on\n          action: turn_on\n          target: '{{ fan_entity }}'\n        - step: Log that the fan has been turned on\n          action: log\n          message: 'Fan {{ fan_entity }} turned on due to humidity level {{ humidity_level }}'\n    - step: Check if humidity is below the set level\n      action: condition\n      condition: state\n      below: '{{ humidity_sensor.state | float }}'\n      above: '{{ humidity_level }}'\n      then:\n        - step: Turn off the fan if it's on\n          action: turn_off\n          target: '{{ fan_entity }}'\n        - step: Log that the fan has been turned off\n          action: log\n          message: 'Fan {{ fan_entity }} turned off due to humidity level {{ humidity_level }}'\n```","humidity_fan-test_blueprint_inputs","Bad","AssertionError"
"humidity_fan_humidity_fan-humidity_fan-2","qwen3-4b","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\nblueprint:\n  name: Humidity Fan\n  inputs:\n    humidity_sensor:\n      friendly_name: Humidity Sensor\n      type: sensor\n    humidity_level:\n      friendly_name: Humidity Level\n      type: number\n    fan_entity:\n      friendly_name: Fan Entity\n      type: fan\n  steps:\n    - step: Check if humidity is above the set level\n      action: condition\n      condition: state\n      below: '{{ humidity_sensor.state | float }}'\n      above: '{{ humidity_level }}'\n      then:\n        - step: Turn on the fan if it's not already on\n          action: turn_on\n          target: '{{ fan_entity }}'\n        - step: Log that the fan has been turned on\n          action: log\n          message: 'Fan {{ fan_entity }} turned on due to humidity level {{ humidity_level }}'\n    - step: Check if humidity is below the set level\n      action: condition\n      condition: state\n      below: '{{ humidity_sensor.state | float }}'\n      above: '{{ humidity_level }}'\n      then:\n        - step: Turn off the fan if it's on\n          action: turn_off\n          target: '{{ fan_entity }}'\n        - step: Log that the fan has been turned off\n          action: log\n          message: 'Fan {{ fan_entity }} turned off due to humidity level {{ humidity_level }}'\n```","humidity_fan-test_fan_triggered_on","Bad","AssertionError: Unable to load automation."
"humidity_fan_humidity_fan-humidity_fan-2","qwen3-4b","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\nblueprint:\n  name: Humidity Fan\n  inputs:\n    humidity_sensor:\n      friendly_name: Humidity Sensor\n      type: sensor\n    humidity_level:\n      friendly_name: Humidity Level\n      type: number\n    fan_entity:\n      friendly_name: Fan Entity\n      type: fan\n  steps:\n    - step: Check if humidity is above the set level\n      action: condition\n      condition: state\n      below: '{{ humidity_sensor.state | float }}'\n      above: '{{ humidity_level }}'\n      then:\n        - step: Turn on the fan if it's not already on\n          action: turn_on\n          target: '{{ fan_entity }}'\n        - step: Log that the fan has been turned on\n          action: log\n          message: 'Fan {{ fan_entity }} turned on due to humidity level {{ humidity_level }}'\n    - step: Check if humidity is below the set level\n      action: condition\n      condition: state\n      below: '{{ humidity_sensor.state | float }}'\n      above: '{{ humidity_level }}'\n      then:\n        - step: Turn off the fan if it's on\n          action: turn_off\n          target: '{{ fan_entity }}'\n        - step: Log that the fan has been turned off\n          action: log\n          message: 'Fan {{ fan_entity }} turned off due to humidity level {{ humidity_level }}'\n```","humidity_fan-test_fan_triggered_off","Bad","AssertionError: Unable to load automation."
"humidity_fan_humidity_fan-humidity_fan-3","qwen3-4b","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\nblueprint:\n  name: Humidity Fan\n  description: Turns on the fan based on the value of the humidity sensor.\n  inputs:\n    humidity_sensor:\n      friendly_name: Humidity Sensor\n      description: A sensor entity that is a humidity sensor that triggers the automation.\n      type: sensor\n    humidity_level:\n      friendly_name: Humidity Level\n      description: A number selector to set the value used as the trigger.\n      type: number\n    fan_entity:\n      friendly_name: Fan Entity\n      description: A fan entity to turn on when the automation fires.\n      type: fan\n  steps:\n    - id: check_humidity\n      title: Check humidity level\n      description: Check if the humidity level is above the set threshold.\n      action:\n        service: condition\n        data:\n          condition: state\n          entity_id: '{{ humidity_sensor }}'\n          below: '{{ humidity_level }}'\n    - id: turn_on_fan\n      title: Turn on fan\n      description: Turn on the fan if it is not already on.\n      action:\n        service: fan.turn_on\n        data:\n          entity_id: '{{ fan_entity }}'\n          set_position: 1\n    - id: turn_off_fan\n      title: Turn off fan\n      description: Turn off the fan if it is already on.\n      action:\n        service: fan.turn_off\n        data:\n          entity_id: '{{ fan_entity }}'\n```","humidity_fan-test_blueprint_inputs","Bad","AssertionError"
"humidity_fan_humidity_fan-humidity_fan-3","qwen3-4b","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\nblueprint:\n  name: Humidity Fan\n  description: Turns on the fan based on the value of the humidity sensor.\n  inputs:\n    humidity_sensor:\n      friendly_name: Humidity Sensor\n      description: A sensor entity that is a humidity sensor that triggers the automation.\n      type: sensor\n    humidity_level:\n      friendly_name: Humidity Level\n      description: A number selector to set the value used as the trigger.\n      type: number\n    fan_entity:\n      friendly_name: Fan Entity\n      description: A fan entity to turn on when the automation fires.\n      type: fan\n  steps:\n    - id: check_humidity\n      title: Check humidity level\n      description: Check if the humidity level is above the set threshold.\n      action:\n        service: condition\n        data:\n          condition: state\n          entity_id: '{{ humidity_sensor }}'\n          below: '{{ humidity_level }}'\n    - id: turn_on_fan\n      title: Turn on fan\n      description: Turn on the fan if it is not already on.\n      action:\n        service: fan.turn_on\n        data:\n          entity_id: '{{ fan_entity }}'\n          set_position: 1\n    - id: turn_off_fan\n      title: Turn off fan\n      description: Turn off the fan if it is already on.\n      action:\n        service: fan.turn_off\n        data:\n          entity_id: '{{ fan_entity }}'\n```","humidity_fan-test_fan_triggered_on","Bad","AssertionError: Unable to load automation."
"humidity_fan_humidity_fan-humidity_fan-3","qwen3-4b","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\nblueprint:\n  name: Humidity Fan\n  description: Turns on the fan based on the value of the humidity sensor.\n  inputs:\n    humidity_sensor:\n      friendly_name: Humidity Sensor\n      description: A sensor entity that is a humidity sensor that triggers the automation.\n      type: sensor\n    humidity_level:\n      friendly_name: Humidity Level\n      description: A number selector to set the value used as the trigger.\n      type: number\n    fan_entity:\n      friendly_name: Fan Entity\n      description: A fan entity to turn on when the automation fires.\n      type: fan\n  steps:\n    - id: check_humidity\n      title: Check humidity level\n      description: Check if the humidity level is above the set threshold.\n      action:\n        service: condition\n        data:\n          condition: state\n          entity_id: '{{ humidity_sensor }}'\n          below: '{{ humidity_level }}'\n    - id: turn_on_fan\n      title: Turn on fan\n      description: Turn on the fan if it is not already on.\n      action:\n        service: fan.turn_on\n        data:\n          entity_id: '{{ fan_entity }}'\n          set_position: 1\n    - id: turn_off_fan\n      title: Turn off fan\n      description: Turn off the fan if it is already on.\n      action:\n        service: fan.turn_off\n        data:\n          entity_id: '{{ fan_entity }}'\n```","humidity_fan-test_fan_triggered_off","Bad","AssertionError: Unable to load automation."
"humidity_fan_humidity_fan-humidity_fan-4","qwen3-4b","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\nblueprint:\n  name: Humidity Fan\n  description: Turns on the fan based on the value of the humidity sensor.\n  inputs:\n    humidity_sensor:\n      friendly_name: Humidity Sensor\n      description: A sensor entity that is a humidity sensor that triggers the automation.\n      type: sensor\n    humidity_level:\n      friendly_name: Humidity Level\n      description: A number selector to set the value used as the trigger.\n      type: number\n    fan_entity:\n      friendly_name: Fan Entity\n      description: A fan entity to turn on when the automation fires.\n      type: fan\n  steps:\n    - step: Check if humidity level is above the set level\n      trigger:\n        platform: state\n        entity_id: {{ humidity_sensor }}\n        from: '{{ humidity_level }}'\n        to: '{{ humidity_level }}'\n      action:\n        service: fan.turn_on\n        target:\n          entity_id: {{ fan_entity }}\n        data:\n          brightness: 255\n    - step: Check if humidity level is below the set level\n      trigger:\n        platform: state\n        entity_id: {{ humidity_sensor }}\n        from: '{{ humidity_level }}'\n        to: '{{ humidity_level }}'\n      action:\n        service: fan.turn_off\n        target:\n          entity_id: {{ fan_entity }}\n```","humidity_fan-test_blueprint_inputs","Bad","^,AssertionError: Blueprint was not valid yaml: while constructing a mapping   in '<unicode string>', line 21, column 20:             entity_id: {{ humidity_sensor }}                        ^ found unhashable key   in '<unicode string>', line 21, column 21:             entity_id: {{ humidity_sensor }}                         ^"
"humidity_fan_humidity_fan-humidity_fan-4","qwen3-4b","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\nblueprint:\n  name: Humidity Fan\n  description: Turns on the fan based on the value of the humidity sensor.\n  inputs:\n    humidity_sensor:\n      friendly_name: Humidity Sensor\n      description: A sensor entity that is a humidity sensor that triggers the automation.\n      type: sensor\n    humidity_level:\n      friendly_name: Humidity Level\n      description: A number selector to set the value used as the trigger.\n      type: number\n    fan_entity:\n      friendly_name: Fan Entity\n      description: A fan entity to turn on when the automation fires.\n      type: fan\n  steps:\n    - step: Check if humidity level is above the set level\n      trigger:\n        platform: state\n        entity_id: {{ humidity_sensor }}\n        from: '{{ humidity_level }}'\n        to: '{{ humidity_level }}'\n      action:\n        service: fan.turn_on\n        target:\n          entity_id: {{ fan_entity }}\n        data:\n          brightness: 255\n    - step: Check if humidity level is below the set level\n      trigger:\n        platform: state\n        entity_id: {{ humidity_sensor }}\n        from: '{{ humidity_level }}'\n        to: '{{ humidity_level }}'\n      action:\n        service: fan.turn_off\n        target:\n          entity_id: {{ fan_entity }}\n```","humidity_fan-test_fan_triggered_on","Bad","AssertionError: Unable to load automation."
"humidity_fan_humidity_fan-humidity_fan-4","qwen3-4b","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\nblueprint:\n  name: Humidity Fan\n  description: Turns on the fan based on the value of the humidity sensor.\n  inputs:\n    humidity_sensor:\n      friendly_name: Humidity Sensor\n      description: A sensor entity that is a humidity sensor that triggers the automation.\n      type: sensor\n    humidity_level:\n      friendly_name: Humidity Level\n      description: A number selector to set the value used as the trigger.\n      type: number\n    fan_entity:\n      friendly_name: Fan Entity\n      description: A fan entity to turn on when the automation fires.\n      type: fan\n  steps:\n    - step: Check if humidity level is above the set level\n      trigger:\n        platform: state\n        entity_id: {{ humidity_sensor }}\n        from: '{{ humidity_level }}'\n        to: '{{ humidity_level }}'\n      action:\n        service: fan.turn_on\n        target:\n          entity_id: {{ fan_entity }}\n        data:\n          brightness: 255\n    - step: Check if humidity level is below the set level\n      trigger:\n        platform: state\n        entity_id: {{ humidity_sensor }}\n        from: '{{ humidity_level }}'\n        to: '{{ humidity_level }}'\n      action:\n        service: fan.turn_off\n        target:\n          entity_id: {{ fan_entity }}\n```","humidity_fan-test_fan_triggered_off","Bad","AssertionError: Unable to load automation."
"humidity_fan_humidity_fan-humidity_fan-0","qwen3-8b","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\nblueprint:\n  name: Humidity Fan\n  description: Turn on a fan when humidity exceeds a specified level and turn it off when it drops below.\n  domain: automation\n\n  inputs:\n    humidity_sensor: sensor\n    humidity_level: number\n    fan_entity: fan\n\n  sensors:\n    humidity_sensor: sensor\n    humidity_level: number\n\n  switches:\n    fan_entity: fan\n\n  triggers:\n    - platform: state\n      entity_id: !input.humidity_sensor\n      to: '>'\n      for:\n        minutes: 1\n      value_template: '{{ value_state.attributes['humidity'] }}'\n\n  conditions:\n    - condition: template\n      template: >\n        {{ states('sensor.humidity') | float > states('input.humidity_level') | float }}\n\n  actions:\n    - service: fan.turn_on\n      data:\n        entity_id: !input.fan_entity\n\n    - service: fan.turn_off\n      data:\n        entity_id: !input.fan_entity\n```","humidity_fan-test_blueprint_inputs","Bad","AssertionError"
"humidity_fan_humidity_fan-humidity_fan-0","qwen3-8b","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\nblueprint:\n  name: Humidity Fan\n  description: Turn on a fan when humidity exceeds a specified level and turn it off when it drops below.\n  domain: automation\n\n  inputs:\n    humidity_sensor: sensor\n    humidity_level: number\n    fan_entity: fan\n\n  sensors:\n    humidity_sensor: sensor\n    humidity_level: number\n\n  switches:\n    fan_entity: fan\n\n  triggers:\n    - platform: state\n      entity_id: !input.humidity_sensor\n      to: '>'\n      for:\n        minutes: 1\n      value_template: '{{ value_state.attributes['humidity'] }}'\n\n  conditions:\n    - condition: template\n      template: >\n        {{ states('sensor.humidity') | float > states('input.humidity_level') | float }}\n\n  actions:\n    - service: fan.turn_on\n      data:\n        entity_id: !input.fan_entity\n\n    - service: fan.turn_off\n      data:\n        entity_id: !input.fan_entity\n```","humidity_fan-test_fan_triggered_on","Bad","AssertionError: Unable to load automation."
"humidity_fan_humidity_fan-humidity_fan-0","qwen3-8b","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\nblueprint:\n  name: Humidity Fan\n  description: Turn on a fan when humidity exceeds a specified level and turn it off when it drops below.\n  domain: automation\n\n  inputs:\n    humidity_sensor: sensor\n    humidity_level: number\n    fan_entity: fan\n\n  sensors:\n    humidity_sensor: sensor\n    humidity_level: number\n\n  switches:\n    fan_entity: fan\n\n  triggers:\n    - platform: state\n      entity_id: !input.humidity_sensor\n      to: '>'\n      for:\n        minutes: 1\n      value_template: '{{ value_state.attributes['humidity'] }}'\n\n  conditions:\n    - condition: template\n      template: >\n        {{ states('sensor.humidity') | float > states('input.humidity_level') | float }}\n\n  actions:\n    - service: fan.turn_on\n      data:\n        entity_id: !input.fan_entity\n\n    - service: fan.turn_off\n      data:\n        entity_id: !input.fan_entity\n```","humidity_fan-test_fan_triggered_off","Bad","AssertionError: Unable to load automation."
"humidity_fan_humidity_fan-humidity_fan-1","qwen3-8b","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\nblueprint:\n  name: Humidity Fan\n  description: Turn on a fan when humidity exceeds a specified level and turn it off when it drops below.\n  domain: automation\n\n  inputs:\n    humidity_sensor: sensor\n    humidity_level: number\n    fan_entity: fan\n\n  sensors:\n    humidity_sensor: sensor\n\n  switches:\n    fan_entity: fan\n\n  triggers:\n    - platform: state\n      entity_id: !input.humidity_sensor\n      to: '>'\n      for:\n        minutes: 1\n      value_template: '{{ value_state.attributes['humidity'] }}'\n\n  conditions:\n    - condition: template\n      template: >\n        {{ states('sensor.humidity') | float > states('input.humidity_level') | float }}\n\n  actions:\n    - service: switch.turn_on\n      data:\n        entity_id: !input.fan_entity\n\n    - service: switch.turn_off\n      data:\n        entity_id: !input.fan_entity\n```","humidity_fan-test_blueprint_inputs","Bad","AssertionError"
"humidity_fan_humidity_fan-humidity_fan-1","qwen3-8b","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\nblueprint:\n  name: Humidity Fan\n  description: Turn on a fan when humidity exceeds a specified level and turn it off when it drops below.\n  domain: automation\n\n  inputs:\n    humidity_sensor: sensor\n    humidity_level: number\n    fan_entity: fan\n\n  sensors:\n    humidity_sensor: sensor\n\n  switches:\n    fan_entity: fan\n\n  triggers:\n    - platform: state\n      entity_id: !input.humidity_sensor\n      to: '>'\n      for:\n        minutes: 1\n      value_template: '{{ value_state.attributes['humidity'] }}'\n\n  conditions:\n    - condition: template\n      template: >\n        {{ states('sensor.humidity') | float > states('input.humidity_level') | float }}\n\n  actions:\n    - service: switch.turn_on\n      data:\n        entity_id: !input.fan_entity\n\n    - service: switch.turn_off\n      data:\n        entity_id: !input.fan_entity\n```","humidity_fan-test_fan_triggered_on","Bad","AssertionError: Unable to load automation."
"humidity_fan_humidity_fan-humidity_fan-1","qwen3-8b","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\nblueprint:\n  name: Humidity Fan\n  description: Turn on a fan when humidity exceeds a specified level and turn it off when it drops below.\n  domain: automation\n\n  inputs:\n    humidity_sensor: sensor\n    humidity_level: number\n    fan_entity: fan\n\n  sensors:\n    humidity_sensor: sensor\n\n  switches:\n    fan_entity: fan\n\n  triggers:\n    - platform: state\n      entity_id: !input.humidity_sensor\n      to: '>'\n      for:\n        minutes: 1\n      value_template: '{{ value_state.attributes['humidity'] }}'\n\n  conditions:\n    - condition: template\n      template: >\n        {{ states('sensor.humidity') | float > states('input.humidity_level') | float }}\n\n  actions:\n    - service: switch.turn_on\n      data:\n        entity_id: !input.fan_entity\n\n    - service: switch.turn_off\n      data:\n        entity_id: !input.fan_entity\n```","humidity_fan-test_fan_triggered_off","Bad","AssertionError: Unable to load automation."
"humidity_fan_humidity_fan-humidity_fan-2","qwen3-8b","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\nblueprint:\n  name: Humidity Fan\n  description: Turn on a fan when humidity exceeds a set level and turn it off when humidity drops below that level.\n  version: 1.0\n  author: Home Assistant\n\ninputs:\n  - name: humidity_sensor\n    type: sensor\n    description: A humidity sensor entity that triggers the automation.\n  - name: humidity_level\n    type: number\n    description: The humidity level threshold to trigger the fan.\n  - name: fan_entity\n    type: fan\n    description: The fan entity to control based on humidity levels.\n\ntrigger:\n  - platform: state\n    entity_id: '{{ humidity_sensor }}'\n    to: '{{ humidity_level }}'\n\ncondition:\n  - condition: template\n    template: >\n      states('{{ humidity_sensor }}') > states('{{ humidity_level }}')\n\naction:\n  - service: fan.turn_on\n    data:\n      entity_id: '{{ fan_entity }}'\n    condition: '{{ is_state(fan_entity, 'on') == false }}'\n\nmode: single\n\n- alias: Turn off fan when humidity drops below threshold\n  trigger:\n    - platform: state\n      entity_id: '{{ humidity_sensor }}'\n      to: '{{ humidity_level }}'\n  condition:\n    - condition: template\n      template: >\n        states('{{ humidity_sensor }}') < states('{{ humidity_level }}')\n  action:\n    - service: fan.turn_off\n      data:\n        entity_id: '{{ fan_entity }}'\n      condition: '{{ is_state(fan_entity, 'off') == false }}'\n```","humidity_fan-test_blueprint_inputs","Bad","^,AssertionError: Blueprint was not valid yaml: while parsing a block mapping   in '<unicode string>', line 1, column 1:     blueprint:     ^ expected <block end>, but found '-'   in '<unicode string>', line 36, column 1:     - alias: Turn off fan when humid ...      ^"
"humidity_fan_humidity_fan-humidity_fan-2","qwen3-8b","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\nblueprint:\n  name: Humidity Fan\n  description: Turn on a fan when humidity exceeds a set level and turn it off when humidity drops below that level.\n  version: 1.0\n  author: Home Assistant\n\ninputs:\n  - name: humidity_sensor\n    type: sensor\n    description: A humidity sensor entity that triggers the automation.\n  - name: humidity_level\n    type: number\n    description: The humidity level threshold to trigger the fan.\n  - name: fan_entity\n    type: fan\n    description: The fan entity to control based on humidity levels.\n\ntrigger:\n  - platform: state\n    entity_id: '{{ humidity_sensor }}'\n    to: '{{ humidity_level }}'\n\ncondition:\n  - condition: template\n    template: >\n      states('{{ humidity_sensor }}') > states('{{ humidity_level }}')\n\naction:\n  - service: fan.turn_on\n    data:\n      entity_id: '{{ fan_entity }}'\n    condition: '{{ is_state(fan_entity, 'on') == false }}'\n\nmode: single\n\n- alias: Turn off fan when humidity drops below threshold\n  trigger:\n    - platform: state\n      entity_id: '{{ humidity_sensor }}'\n      to: '{{ humidity_level }}'\n  condition:\n    - condition: template\n      template: >\n        states('{{ humidity_sensor }}') < states('{{ humidity_level }}')\n  action:\n    - service: fan.turn_off\n      data:\n        entity_id: '{{ fan_entity }}'\n      condition: '{{ is_state(fan_entity, 'off') == false }}'\n```","humidity_fan-test_fan_triggered_on","Bad","AssertionError: Unable to load automation."
"humidity_fan_humidity_fan-humidity_fan-2","qwen3-8b","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\nblueprint:\n  name: Humidity Fan\n  description: Turn on a fan when humidity exceeds a set level and turn it off when humidity drops below that level.\n  version: 1.0\n  author: Home Assistant\n\ninputs:\n  - name: humidity_sensor\n    type: sensor\n    description: A humidity sensor entity that triggers the automation.\n  - name: humidity_level\n    type: number\n    description: The humidity level threshold to trigger the fan.\n  - name: fan_entity\n    type: fan\n    description: The fan entity to control based on humidity levels.\n\ntrigger:\n  - platform: state\n    entity_id: '{{ humidity_sensor }}'\n    to: '{{ humidity_level }}'\n\ncondition:\n  - condition: template\n    template: >\n      states('{{ humidity_sensor }}') > states('{{ humidity_level }}')\n\naction:\n  - service: fan.turn_on\n    data:\n      entity_id: '{{ fan_entity }}'\n    condition: '{{ is_state(fan_entity, 'on') == false }}'\n\nmode: single\n\n- alias: Turn off fan when humidity drops below threshold\n  trigger:\n    - platform: state\n      entity_id: '{{ humidity_sensor }}'\n      to: '{{ humidity_level }}'\n  condition:\n    - condition: template\n      template: >\n        states('{{ humidity_sensor }}') < states('{{ humidity_level }}')\n  action:\n    - service: fan.turn_off\n      data:\n        entity_id: '{{ fan_entity }}'\n      condition: '{{ is_state(fan_entity, 'off') == false }}'\n```","humidity_fan-test_fan_triggered_off","Bad","AssertionError: Unable to load automation."
"humidity_fan_humidity_fan-humidity_fan-3","qwen3-8b","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\nblueprint:\n  name: Humidity Fan\n  description: Turn on a fan when humidity exceeds a specified level and turn it off when humidity drops below that level.\n  domain: automation\n\n  inputs:\n    humidity_sensor: sensor\n    humidity_level: number\n    fan_entity: fan\n\n  sensors:\n    humidity_sensor: sensor\n    humidity_level: number\n\n  switches:\n    fan_entity: fan\n\n  triggers:\n    - platform: state\n      entity_id: !input.humidity_sensor\n      to: '>'\n      for:\n        hours: 0\n        minutes: 0\n        seconds: 5\n\n  conditions:\n    - condition: template\n      value_template: >\n        {{ (states('!input.humidity_sensor') | float) > (!input.humidity_level | float) }}\n\n  actions:\n    - service: switch.turn_on\n      data:\n        entity_id: !input.fan_entity\n      condition: '{{ (states('!input.fan_entity') | int) == 0 }}'\n\n    - service: switch.turn_off\n      data:\n        entity_id: !input.fan_entity\n      condition: '{{ (states('!input.fan_entity') | int) == 1 }}'\n```","humidity_fan-test_blueprint_inputs","Bad","^,AssertionError: Blueprint was not valid yaml: while parsing a block mapping   in '<unicode string>', line 33, column 7:         - service: switch.turn_on           ^ expected <block end>, but found '<tag>'   in '<unicode string>', line 36, column 31:           condition: '{{ (states('!input.fan_entity') | int) == 0 }}'                                   ^"
"humidity_fan_humidity_fan-humidity_fan-3","qwen3-8b","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\nblueprint:\n  name: Humidity Fan\n  description: Turn on a fan when humidity exceeds a specified level and turn it off when humidity drops below that level.\n  domain: automation\n\n  inputs:\n    humidity_sensor: sensor\n    humidity_level: number\n    fan_entity: fan\n\n  sensors:\n    humidity_sensor: sensor\n    humidity_level: number\n\n  switches:\n    fan_entity: fan\n\n  triggers:\n    - platform: state\n      entity_id: !input.humidity_sensor\n      to: '>'\n      for:\n        hours: 0\n        minutes: 0\n        seconds: 5\n\n  conditions:\n    - condition: template\n      value_template: >\n        {{ (states('!input.humidity_sensor') | float) > (!input.humidity_level | float) }}\n\n  actions:\n    - service: switch.turn_on\n      data:\n        entity_id: !input.fan_entity\n      condition: '{{ (states('!input.fan_entity') | int) == 0 }}'\n\n    - service: switch.turn_off\n      data:\n        entity_id: !input.fan_entity\n      condition: '{{ (states('!input.fan_entity') | int) == 1 }}'\n```","humidity_fan-test_fan_triggered_on","Bad","AssertionError: Unable to load automation."
"humidity_fan_humidity_fan-humidity_fan-3","qwen3-8b","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\nblueprint:\n  name: Humidity Fan\n  description: Turn on a fan when humidity exceeds a specified level and turn it off when humidity drops below that level.\n  domain: automation\n\n  inputs:\n    humidity_sensor: sensor\n    humidity_level: number\n    fan_entity: fan\n\n  sensors:\n    humidity_sensor: sensor\n    humidity_level: number\n\n  switches:\n    fan_entity: fan\n\n  triggers:\n    - platform: state\n      entity_id: !input.humidity_sensor\n      to: '>'\n      for:\n        hours: 0\n        minutes: 0\n        seconds: 5\n\n  conditions:\n    - condition: template\n      value_template: >\n        {{ (states('!input.humidity_sensor') | float) > (!input.humidity_level | float) }}\n\n  actions:\n    - service: switch.turn_on\n      data:\n        entity_id: !input.fan_entity\n      condition: '{{ (states('!input.fan_entity') | int) == 0 }}'\n\n    - service: switch.turn_off\n      data:\n        entity_id: !input.fan_entity\n      condition: '{{ (states('!input.fan_entity') | int) == 1 }}'\n```","humidity_fan-test_fan_triggered_off","Bad","AssertionError: Unable to load automation."
"humidity_fan_humidity_fan-humidity_fan-4","qwen3-8b","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\nblueprint:\n  name: Humidity Fan\n  description: Turn on a fan when humidity exceeds a certain level and turn it off when humidity drops below the level.\n  version: 1.0\n  author: Home Assistant\n\ninputs:\n  - name: humidity_sensor\n    type: sensor\n    description: The humidity sensor entity that triggers the automation.\n  - name: humidity_level\n    type: number\n    description: The humidity level threshold to trigger the fan.\n  - name: fan_entity\n    type: fan\n    description: The fan entity to control based on humidity levels.\n\ntrigger:\n  - platform: state\n    entity_id: !input.humidity_sensor\n    to: '>'\n    for:\n      minutes: 5\n\ncondition:\n  - condition: template\n    trigger: true\n    value_template: >\n      {{ (states('!input.humidity_sensor') | int) > states('!input.humidity_level') | int }}\n\naction:\n  - service: homeassistant.turn_on\n    data:\n      entity_id: !input.fan_entity\n\n  - service: homeassistant.turn_off\n    data:\n      entity_id: !input.fan_entity\n    condition: template\n    value_template: >\n      {{ (states('!input.humidity_sensor') | int) < states('!input.humidity_level') | int }}\n```","humidity_fan-test_blueprint_inputs","Bad","AssertionError"
"humidity_fan_humidity_fan-humidity_fan-4","qwen3-8b","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\nblueprint:\n  name: Humidity Fan\n  description: Turn on a fan when humidity exceeds a certain level and turn it off when humidity drops below the level.\n  version: 1.0\n  author: Home Assistant\n\ninputs:\n  - name: humidity_sensor\n    type: sensor\n    description: The humidity sensor entity that triggers the automation.\n  - name: humidity_level\n    type: number\n    description: The humidity level threshold to trigger the fan.\n  - name: fan_entity\n    type: fan\n    description: The fan entity to control based on humidity levels.\n\ntrigger:\n  - platform: state\n    entity_id: !input.humidity_sensor\n    to: '>'\n    for:\n      minutes: 5\n\ncondition:\n  - condition: template\n    trigger: true\n    value_template: >\n      {{ (states('!input.humidity_sensor') | int) > states('!input.humidity_level') | int }}\n\naction:\n  - service: homeassistant.turn_on\n    data:\n      entity_id: !input.fan_entity\n\n  - service: homeassistant.turn_off\n    data:\n      entity_id: !input.fan_entity\n    condition: template\n    value_template: >\n      {{ (states('!input.humidity_sensor') | int) < states('!input.humidity_level') | int }}\n```","humidity_fan-test_fan_triggered_on","Bad","AssertionError: Unable to load automation."
"humidity_fan_humidity_fan-humidity_fan-4","qwen3-8b","fan","# Humidity Fan\n\n## Problem statement\n\nCreate a blueprint automation to turn on the fan based on the value of the humidity sensor.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the bathroom exhaust fan when the bathroom humidty is above 60%\n- Make sure the garage does not get too humid\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |\n| `humidity_level` | A `number` selector to set the value used as the trigger. |\n| `fan_entity`     | A `fan` entity to turn on when the automation fires. |\n\nThe automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When\ntriggered, the fan should be turned off. The fan should also be stopped when the\nsensor goes back down below the desired level. The automation should not try to\nturn the fan on if it is already on, and should not turn the fan off when it is\nalready off.\n","","```yaml\nblueprint:\n  name: Humidity Fan\n  description: Turn on a fan when humidity exceeds a certain level and turn it off when humidity drops below the level.\n  version: 1.0\n  author: Home Assistant\n\ninputs:\n  - name: humidity_sensor\n    type: sensor\n    description: The humidity sensor entity that triggers the automation.\n  - name: humidity_level\n    type: number\n    description: The humidity level threshold to trigger the fan.\n  - name: fan_entity\n    type: fan\n    description: The fan entity to control based on humidity levels.\n\ntrigger:\n  - platform: state\n    entity_id: !input.humidity_sensor\n    to: '>'\n    for:\n      minutes: 5\n\ncondition:\n  - condition: template\n    trigger: true\n    value_template: >\n      {{ (states('!input.humidity_sensor') | int) > states('!input.humidity_level') | int }}\n\naction:\n  - service: homeassistant.turn_on\n    data:\n      entity_id: !input.fan_entity\n\n  - service: homeassistant.turn_off\n    data:\n      entity_id: !input.fan_entity\n    condition: template\n    value_template: >\n      {{ (states('!input.humidity_sensor') | int) < states('!input.humidity_level') | int }}\n```","humidity_fan-test_fan_triggered_off","Bad","AssertionError: Unable to load automation."
"light_on_door_light_on_door-light_on_door-0","gemini-2.5-flash","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: Light on Door Open\n  description: Turns on a light when a door opens, and turns it off when the door closes or after a 2-minute timeout.\n  domain: automation\n  input:\n    door_sensor:\n      name: Door Sensor\n      description: The binary sensor for the door (e.g., contact sensor).\n      selector:\n        entity:\n          domain: binary_sensor\n          # It's good practice to suggest device classes if applicable, but not restrict if user has custom ones\n          # device_class: [door, opening] # This can be too restrictive for some setups\n    light_switch:\n      name: Light to Control\n      description: One or more light entities to turn on/off.\n      selector:\n        target:\n          entity:\n            domain: light\n\nmode: single\nmax_exceeded: silent\n\ntrigger:\n  - platform: state\n    entity_id: !input door_sensor\n    from: 'off'\n    to: 'on'\n    id: door_opened\n\naction:\n  - service: light.turn_on\n    target: !input light_switch\n    data: {} # No extra data needed for simple on\n\n  - wait_for_trigger:\n      - platform: state\n        entity_id: !input door_sensor\n        from: 'on'\n        to: 'off'\n        id: door_closed\n    timeout:\n      minutes: 2\n    continue_on_timeout: true # Ensure the automation continues to turn off the light even if it times out\n\n  - service: light.turn_off\n    target: !input light_switch\n    data: {} # No extra data needed for simple off\n```","light_on_door-test_blueprint_inputs","Good",""
"light_on_door_light_on_door-light_on_door-0","gemini-2.5-flash","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: Light on Door Open\n  description: Turns on a light when a door opens, and turns it off when the door closes or after a 2-minute timeout.\n  domain: automation\n  input:\n    door_sensor:\n      name: Door Sensor\n      description: The binary sensor for the door (e.g., contact sensor).\n      selector:\n        entity:\n          domain: binary_sensor\n          # It's good practice to suggest device classes if applicable, but not restrict if user has custom ones\n          # device_class: [door, opening] # This can be too restrictive for some setups\n    light_switch:\n      name: Light to Control\n      description: One or more light entities to turn on/off.\n      selector:\n        target:\n          entity:\n            domain: light\n\nmode: single\nmax_exceeded: silent\n\ntrigger:\n  - platform: state\n    entity_id: !input door_sensor\n    from: 'off'\n    to: 'on'\n    id: door_opened\n\naction:\n  - service: light.turn_on\n    target: !input light_switch\n    data: {} # No extra data needed for simple on\n\n  - wait_for_trigger:\n      - platform: state\n        entity_id: !input door_sensor\n        from: 'on'\n        to: 'off'\n        id: door_closed\n    timeout:\n      minutes: 2\n    continue_on_timeout: true # Ensure the automation continues to turn off the light even if it times out\n\n  - service: light.turn_off\n    target: !input light_switch\n    data: {} # No extra data needed for simple off\n```","light_on_door-test_door_open","Good",""
"light_on_door_light_on_door-light_on_door-0","gemini-2.5-flash","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: Light on Door Open\n  description: Turns on a light when a door opens, and turns it off when the door closes or after a 2-minute timeout.\n  domain: automation\n  input:\n    door_sensor:\n      name: Door Sensor\n      description: The binary sensor for the door (e.g., contact sensor).\n      selector:\n        entity:\n          domain: binary_sensor\n          # It's good practice to suggest device classes if applicable, but not restrict if user has custom ones\n          # device_class: [door, opening] # This can be too restrictive for some setups\n    light_switch:\n      name: Light to Control\n      description: One or more light entities to turn on/off.\n      selector:\n        target:\n          entity:\n            domain: light\n\nmode: single\nmax_exceeded: silent\n\ntrigger:\n  - platform: state\n    entity_id: !input door_sensor\n    from: 'off'\n    to: 'on'\n    id: door_opened\n\naction:\n  - service: light.turn_on\n    target: !input light_switch\n    data: {} # No extra data needed for simple on\n\n  - wait_for_trigger:\n      - platform: state\n        entity_id: !input door_sensor\n        from: 'on'\n        to: 'off'\n        id: door_closed\n    timeout:\n      minutes: 2\n    continue_on_timeout: true # Ensure the automation continues to turn off the light even if it times out\n\n  - service: light.turn_off\n    target: !input light_switch\n    data: {} # No extra data needed for simple off\n```","light_on_door-test_door_open_close","Good",""
"light_on_door_light_on_door-light_on_door-0","gemini-2.5-flash","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: Light on Door Open\n  description: Turns on a light when a door opens, and turns it off when the door closes or after a 2-minute timeout.\n  domain: automation\n  input:\n    door_sensor:\n      name: Door Sensor\n      description: The binary sensor for the door (e.g., contact sensor).\n      selector:\n        entity:\n          domain: binary_sensor\n          # It's good practice to suggest device classes if applicable, but not restrict if user has custom ones\n          # device_class: [door, opening] # This can be too restrictive for some setups\n    light_switch:\n      name: Light to Control\n      description: One or more light entities to turn on/off.\n      selector:\n        target:\n          entity:\n            domain: light\n\nmode: single\nmax_exceeded: silent\n\ntrigger:\n  - platform: state\n    entity_id: !input door_sensor\n    from: 'off'\n    to: 'on'\n    id: door_opened\n\naction:\n  - service: light.turn_on\n    target: !input light_switch\n    data: {} # No extra data needed for simple on\n\n  - wait_for_trigger:\n      - platform: state\n        entity_id: !input door_sensor\n        from: 'on'\n        to: 'off'\n        id: door_closed\n    timeout:\n      minutes: 2\n    continue_on_timeout: true # Ensure the automation continues to turn off the light even if it times out\n\n  - service: light.turn_off\n    target: !input light_switch\n    data: {} # No extra data needed for simple off\n```","light_on_door-test_light_timeout","Good",""
"light_on_door_light_on_door-light_on_door-1","gemini-2.5-flash","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: Light on Door Open\n  description: Turns on a light when a door opens, and turns it off when the door closes or after a 2-minute timeout.\n  domain: automation\n  input:\n    door_sensor:\n      name: Door Sensor\n      description: The binary_sensor that detects the door opening/closing (e.g., a contact sensor).\n      selector:\n        entity:\n          domain: binary_sensor\n          device_class:\n            - door\n            - window\n            - garage_door # Common device classes for door/opening sensors\n    light_switch:\n      name: Light(s)\n      description: The light entity or entities to control.\n      selector:\n        target:\n          entity:\n            domain: light\n\n# This ensures that if the door opens multiple times quickly, only one instance of the automation runs at a time.\n# 'single' mode means if it's already running, subsequent triggers are ignored until the current one finishes.\nmode: single\nmax_exceeded: silent # Suppress warnings if a trigger is ignored due to 'single' mode.\n\ntrigger:\n  # The automation triggers when the specified door sensor changes state\n  # from 'off' (closed) to 'on' (opened).\n  - platform: state\n    entity_id: !input door_sensor\n    from: 'off'\n    to: 'on'\n    id: 'door_opened_trigger' # An optional ID for this trigger.\n\naction:\n  # 1. Turn on the light(s) immediately when the door opens.\n  - service: light.turn_on\n    target: !input light_switch\n\n  # 2. Wait for either the door to close OR a 2-minute timeout.\n  #    The automation will pause here until one of the conditions is met.\n  - wait_for_trigger:\n      # Condition 1: The door sensor changes from 'on' (open) to 'off' (closed).\n      - platform: state\n        entity_id: !input door_sensor\n        from: 'on'\n        to: 'off'\n    # Condition 2: If the door does not close within 2 minutes (120 seconds).\n    timeout: '00:02:00' # Format: HH:MM:SS\n    # This is crucial: if the timeout occurs, we still want the light to turn off.\n    # If set to false (default), the automation would stop here on timeout.\n    continue_on_timeout: true\n\n  # 3. Turn off the light(s) after the wait_for_trigger completes (either door closed or timeout).\n  - service: light.turn_off\n    target: !input light_switch\n```","light_on_door-test_blueprint_inputs","Good",""
"light_on_door_light_on_door-light_on_door-1","gemini-2.5-flash","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: Light on Door Open\n  description: Turns on a light when a door opens, and turns it off when the door closes or after a 2-minute timeout.\n  domain: automation\n  input:\n    door_sensor:\n      name: Door Sensor\n      description: The binary_sensor that detects the door opening/closing (e.g., a contact sensor).\n      selector:\n        entity:\n          domain: binary_sensor\n          device_class:\n            - door\n            - window\n            - garage_door # Common device classes for door/opening sensors\n    light_switch:\n      name: Light(s)\n      description: The light entity or entities to control.\n      selector:\n        target:\n          entity:\n            domain: light\n\n# This ensures that if the door opens multiple times quickly, only one instance of the automation runs at a time.\n# 'single' mode means if it's already running, subsequent triggers are ignored until the current one finishes.\nmode: single\nmax_exceeded: silent # Suppress warnings if a trigger is ignored due to 'single' mode.\n\ntrigger:\n  # The automation triggers when the specified door sensor changes state\n  # from 'off' (closed) to 'on' (opened).\n  - platform: state\n    entity_id: !input door_sensor\n    from: 'off'\n    to: 'on'\n    id: 'door_opened_trigger' # An optional ID for this trigger.\n\naction:\n  # 1. Turn on the light(s) immediately when the door opens.\n  - service: light.turn_on\n    target: !input light_switch\n\n  # 2. Wait for either the door to close OR a 2-minute timeout.\n  #    The automation will pause here until one of the conditions is met.\n  - wait_for_trigger:\n      # Condition 1: The door sensor changes from 'on' (open) to 'off' (closed).\n      - platform: state\n        entity_id: !input door_sensor\n        from: 'on'\n        to: 'off'\n    # Condition 2: If the door does not close within 2 minutes (120 seconds).\n    timeout: '00:02:00' # Format: HH:MM:SS\n    # This is crucial: if the timeout occurs, we still want the light to turn off.\n    # If set to false (default), the automation would stop here on timeout.\n    continue_on_timeout: true\n\n  # 3. Turn off the light(s) after the wait_for_trigger completes (either door closed or timeout).\n  - service: light.turn_off\n    target: !input light_switch\n```","light_on_door-test_door_open","Good",""
"light_on_door_light_on_door-light_on_door-1","gemini-2.5-flash","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: Light on Door Open\n  description: Turns on a light when a door opens, and turns it off when the door closes or after a 2-minute timeout.\n  domain: automation\n  input:\n    door_sensor:\n      name: Door Sensor\n      description: The binary_sensor that detects the door opening/closing (e.g., a contact sensor).\n      selector:\n        entity:\n          domain: binary_sensor\n          device_class:\n            - door\n            - window\n            - garage_door # Common device classes for door/opening sensors\n    light_switch:\n      name: Light(s)\n      description: The light entity or entities to control.\n      selector:\n        target:\n          entity:\n            domain: light\n\n# This ensures that if the door opens multiple times quickly, only one instance of the automation runs at a time.\n# 'single' mode means if it's already running, subsequent triggers are ignored until the current one finishes.\nmode: single\nmax_exceeded: silent # Suppress warnings if a trigger is ignored due to 'single' mode.\n\ntrigger:\n  # The automation triggers when the specified door sensor changes state\n  # from 'off' (closed) to 'on' (opened).\n  - platform: state\n    entity_id: !input door_sensor\n    from: 'off'\n    to: 'on'\n    id: 'door_opened_trigger' # An optional ID for this trigger.\n\naction:\n  # 1. Turn on the light(s) immediately when the door opens.\n  - service: light.turn_on\n    target: !input light_switch\n\n  # 2. Wait for either the door to close OR a 2-minute timeout.\n  #    The automation will pause here until one of the conditions is met.\n  - wait_for_trigger:\n      # Condition 1: The door sensor changes from 'on' (open) to 'off' (closed).\n      - platform: state\n        entity_id: !input door_sensor\n        from: 'on'\n        to: 'off'\n    # Condition 2: If the door does not close within 2 minutes (120 seconds).\n    timeout: '00:02:00' # Format: HH:MM:SS\n    # This is crucial: if the timeout occurs, we still want the light to turn off.\n    # If set to false (default), the automation would stop here on timeout.\n    continue_on_timeout: true\n\n  # 3. Turn off the light(s) after the wait_for_trigger completes (either door closed or timeout).\n  - service: light.turn_off\n    target: !input light_switch\n```","light_on_door-test_door_open_close","Good",""
"light_on_door_light_on_door-light_on_door-1","gemini-2.5-flash","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: Light on Door Open\n  description: Turns on a light when a door opens, and turns it off when the door closes or after a 2-minute timeout.\n  domain: automation\n  input:\n    door_sensor:\n      name: Door Sensor\n      description: The binary_sensor that detects the door opening/closing (e.g., a contact sensor).\n      selector:\n        entity:\n          domain: binary_sensor\n          device_class:\n            - door\n            - window\n            - garage_door # Common device classes for door/opening sensors\n    light_switch:\n      name: Light(s)\n      description: The light entity or entities to control.\n      selector:\n        target:\n          entity:\n            domain: light\n\n# This ensures that if the door opens multiple times quickly, only one instance of the automation runs at a time.\n# 'single' mode means if it's already running, subsequent triggers are ignored until the current one finishes.\nmode: single\nmax_exceeded: silent # Suppress warnings if a trigger is ignored due to 'single' mode.\n\ntrigger:\n  # The automation triggers when the specified door sensor changes state\n  # from 'off' (closed) to 'on' (opened).\n  - platform: state\n    entity_id: !input door_sensor\n    from: 'off'\n    to: 'on'\n    id: 'door_opened_trigger' # An optional ID for this trigger.\n\naction:\n  # 1. Turn on the light(s) immediately when the door opens.\n  - service: light.turn_on\n    target: !input light_switch\n\n  # 2. Wait for either the door to close OR a 2-minute timeout.\n  #    The automation will pause here until one of the conditions is met.\n  - wait_for_trigger:\n      # Condition 1: The door sensor changes from 'on' (open) to 'off' (closed).\n      - platform: state\n        entity_id: !input door_sensor\n        from: 'on'\n        to: 'off'\n    # Condition 2: If the door does not close within 2 minutes (120 seconds).\n    timeout: '00:02:00' # Format: HH:MM:SS\n    # This is crucial: if the timeout occurs, we still want the light to turn off.\n    # If set to false (default), the automation would stop here on timeout.\n    continue_on_timeout: true\n\n  # 3. Turn off the light(s) after the wait_for_trigger completes (either door closed or timeout).\n  - service: light.turn_off\n    target: !input light_switch\n```","light_on_door-test_light_timeout","Good",""
"light_on_door_light_on_door-light_on_door-2","gemini-2.5-flash","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: Light on Door Open\n  description: Turns on a light when a door opens and turns it off after a timeout or when the door closes.\n  domain: automation\n  # The source_url is optional but good practice for sharing blueprints.\n  # source_url: https://raw.githubusercontent.com/your-username/your-ha-blueprints/main/light_on_door_open.yaml\n\n  input:\n    door_sensor:\n      name: Door Sensor\n      description: The binary sensor entity for the door (e.g., a contact sensor).\n      selector:\n        entity:\n          domain: binary_sensor\n          # Recommend common device classes for door sensors\n          device_class:\n            - door\n            - window\n            - opening\n          multiple: false # Only one door sensor entity can be selected\n    light_target:\n      name: Light(s) to Control\n      description: One or more light entities to turn on/off.\n      selector:\n        target:\n          entity:\n            domain: light\n\nmode: single # Ensures only one instance of the automation runs at a time to prevent conflicts.\n\ntrigger:\n  # This automation triggers on any state change of the door sensor.\n  # The action then differentiates between 'on' (open) and 'off' (closed).\n  - platform: state\n    entity_id: !input door_sensor\n\naction:\n  - choose:\n      # Case 1: Door opens (door_sensor state becomes 'on')\n      - conditions:\n          - condition: state\n            entity_id: !input door_sensor\n            state: 'on' # Triggered when the door opens\n        sequence:\n          # Turn on the specified light(s)\n          - service: light.turn_on\n            target: !input light_target\n            data: {} # No additional data needed for a simple turn_on\n\n          # Wait for either the door to close OR a 2-minute timeout\n          - wait_for_trigger:\n              - platform: state\n                entity_id: !input door_sensor\n                to: 'off' # Condition 1: Door closes\n            timeout:\n              minutes: 2 # Condition 2: Timeout after 2 minutes\n            continue_on_timeout: true # Crucial: continue the automation flow even if the timeout occurs\n\n          # After the wait_for_trigger (either door closed or timeout), turn off the light(s)\n          - service: light.turn_off\n            target: !input light_target\n            data: {} # No additional data needed for a simple turn_off\n\n    # No default action is needed. If the door sensor goes 'off' without first being 'on'\n    # (e.g., it was already off), nothing needs to happen from this blueprint.\n```","light_on_door-test_blueprint_inputs","Bad","AssertionError: Required input 'light_switch' missing from blueprint"
"light_on_door_light_on_door-light_on_door-2","gemini-2.5-flash","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: Light on Door Open\n  description: Turns on a light when a door opens and turns it off after a timeout or when the door closes.\n  domain: automation\n  # The source_url is optional but good practice for sharing blueprints.\n  # source_url: https://raw.githubusercontent.com/your-username/your-ha-blueprints/main/light_on_door_open.yaml\n\n  input:\n    door_sensor:\n      name: Door Sensor\n      description: The binary sensor entity for the door (e.g., a contact sensor).\n      selector:\n        entity:\n          domain: binary_sensor\n          # Recommend common device classes for door sensors\n          device_class:\n            - door\n            - window\n            - opening\n          multiple: false # Only one door sensor entity can be selected\n    light_target:\n      name: Light(s) to Control\n      description: One or more light entities to turn on/off.\n      selector:\n        target:\n          entity:\n            domain: light\n\nmode: single # Ensures only one instance of the automation runs at a time to prevent conflicts.\n\ntrigger:\n  # This automation triggers on any state change of the door sensor.\n  # The action then differentiates between 'on' (open) and 'off' (closed).\n  - platform: state\n    entity_id: !input door_sensor\n\naction:\n  - choose:\n      # Case 1: Door opens (door_sensor state becomes 'on')\n      - conditions:\n          - condition: state\n            entity_id: !input door_sensor\n            state: 'on' # Triggered when the door opens\n        sequence:\n          # Turn on the specified light(s)\n          - service: light.turn_on\n            target: !input light_target\n            data: {} # No additional data needed for a simple turn_on\n\n          # Wait for either the door to close OR a 2-minute timeout\n          - wait_for_trigger:\n              - platform: state\n                entity_id: !input door_sensor\n                to: 'off' # Condition 1: Door closes\n            timeout:\n              minutes: 2 # Condition 2: Timeout after 2 minutes\n            continue_on_timeout: true # Crucial: continue the automation flow even if the timeout occurs\n\n          # After the wait_for_trigger (either door closed or timeout), turn off the light(s)\n          - service: light.turn_off\n            target: !input light_target\n            data: {} # No additional data needed for a simple turn_off\n\n    # No default action is needed. If the door sensor goes 'off' without first being 'on'\n    # (e.g., it was already off), nothing needs to happen from this blueprint.\n```","light_on_door-test_door_open","Bad","AssertionError: Unable to load automation."
"light_on_door_light_on_door-light_on_door-2","gemini-2.5-flash","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: Light on Door Open\n  description: Turns on a light when a door opens and turns it off after a timeout or when the door closes.\n  domain: automation\n  # The source_url is optional but good practice for sharing blueprints.\n  # source_url: https://raw.githubusercontent.com/your-username/your-ha-blueprints/main/light_on_door_open.yaml\n\n  input:\n    door_sensor:\n      name: Door Sensor\n      description: The binary sensor entity for the door (e.g., a contact sensor).\n      selector:\n        entity:\n          domain: binary_sensor\n          # Recommend common device classes for door sensors\n          device_class:\n            - door\n            - window\n            - opening\n          multiple: false # Only one door sensor entity can be selected\n    light_target:\n      name: Light(s) to Control\n      description: One or more light entities to turn on/off.\n      selector:\n        target:\n          entity:\n            domain: light\n\nmode: single # Ensures only one instance of the automation runs at a time to prevent conflicts.\n\ntrigger:\n  # This automation triggers on any state change of the door sensor.\n  # The action then differentiates between 'on' (open) and 'off' (closed).\n  - platform: state\n    entity_id: !input door_sensor\n\naction:\n  - choose:\n      # Case 1: Door opens (door_sensor state becomes 'on')\n      - conditions:\n          - condition: state\n            entity_id: !input door_sensor\n            state: 'on' # Triggered when the door opens\n        sequence:\n          # Turn on the specified light(s)\n          - service: light.turn_on\n            target: !input light_target\n            data: {} # No additional data needed for a simple turn_on\n\n          # Wait for either the door to close OR a 2-minute timeout\n          - wait_for_trigger:\n              - platform: state\n                entity_id: !input door_sensor\n                to: 'off' # Condition 1: Door closes\n            timeout:\n              minutes: 2 # Condition 2: Timeout after 2 minutes\n            continue_on_timeout: true # Crucial: continue the automation flow even if the timeout occurs\n\n          # After the wait_for_trigger (either door closed or timeout), turn off the light(s)\n          - service: light.turn_off\n            target: !input light_target\n            data: {} # No additional data needed for a simple turn_off\n\n    # No default action is needed. If the door sensor goes 'off' without first being 'on'\n    # (e.g., it was already off), nothing needs to happen from this blueprint.\n```","light_on_door-test_door_open_close","Bad","AssertionError: Unable to load automation."
"light_on_door_light_on_door-light_on_door-2","gemini-2.5-flash","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: Light on Door Open\n  description: Turns on a light when a door opens and turns it off after a timeout or when the door closes.\n  domain: automation\n  # The source_url is optional but good practice for sharing blueprints.\n  # source_url: https://raw.githubusercontent.com/your-username/your-ha-blueprints/main/light_on_door_open.yaml\n\n  input:\n    door_sensor:\n      name: Door Sensor\n      description: The binary sensor entity for the door (e.g., a contact sensor).\n      selector:\n        entity:\n          domain: binary_sensor\n          # Recommend common device classes for door sensors\n          device_class:\n            - door\n            - window\n            - opening\n          multiple: false # Only one door sensor entity can be selected\n    light_target:\n      name: Light(s) to Control\n      description: One or more light entities to turn on/off.\n      selector:\n        target:\n          entity:\n            domain: light\n\nmode: single # Ensures only one instance of the automation runs at a time to prevent conflicts.\n\ntrigger:\n  # This automation triggers on any state change of the door sensor.\n  # The action then differentiates between 'on' (open) and 'off' (closed).\n  - platform: state\n    entity_id: !input door_sensor\n\naction:\n  - choose:\n      # Case 1: Door opens (door_sensor state becomes 'on')\n      - conditions:\n          - condition: state\n            entity_id: !input door_sensor\n            state: 'on' # Triggered when the door opens\n        sequence:\n          # Turn on the specified light(s)\n          - service: light.turn_on\n            target: !input light_target\n            data: {} # No additional data needed for a simple turn_on\n\n          # Wait for either the door to close OR a 2-minute timeout\n          - wait_for_trigger:\n              - platform: state\n                entity_id: !input door_sensor\n                to: 'off' # Condition 1: Door closes\n            timeout:\n              minutes: 2 # Condition 2: Timeout after 2 minutes\n            continue_on_timeout: true # Crucial: continue the automation flow even if the timeout occurs\n\n          # After the wait_for_trigger (either door closed or timeout), turn off the light(s)\n          - service: light.turn_off\n            target: !input light_target\n            data: {} # No additional data needed for a simple turn_off\n\n    # No default action is needed. If the door sensor goes 'off' without first being 'on'\n    # (e.g., it was already off), nothing needs to happen from this blueprint.\n```","light_on_door-test_light_timeout","Bad","AssertionError: Unable to load automation."
"light_on_door_light_on_door-light_on_door-3","gemini-2.5-flash","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: Light on door\n  description: Turn on a light when a door opens, and turn it off when the door closes or after a timeout.\n  domain: automation\n  source_url: https://github.com/home-assistant/core/blob/dev/homeassistant/components/automation/blueprints/light_on_door.yaml # This is a placeholder, replace with actual URL if published\n\ninput:\n  door_sensor:\n    name: Door sensor\n    description: The binary sensor for the door (e.g., contact sensor).\n    selector:\n      entity:\n        domain: binary_sensor\n        device_class: # Suggest common device classes for doors\n          - door\n          - window\n          - garage_door\n          - opening\n          - motion # Sometimes motion sensors are used to detect opening\n          - occupancy # Also for presence in a room after door opens\n  light_switch:\n    name: Light(s) to control\n    description: One or more light entities to turn on/off.\n    selector:\n      target:\n        entity:\n          domain: light\n\nmode: restart\n\ntrigger:\n  - platform: state\n    entity_id: !input door_sensor\n    from: 'off'\n    to: 'on'\n    id: 'door_opened' # Assign an ID for clarity and potential future expansion\n\naction:\n  - choose:\n      - conditions:\n          - condition: trigger\n            id: 'door_opened'\n        sequence:\n          - service: light.turn_on\n            target: !input light_switch\n          - wait_for_trigger:\n              - platform: state\n                entity_id: !input door_sensor\n                to: 'off'\n            timeout: '00:02:00' # 2-minute timeout\n            continue_on_timeout: true # Ensure the automation continues to turn off the light even if timeout occurs\n          - service: light.turn_off\n            target: !input light_switch\n```","light_on_door-test_blueprint_inputs","Bad","AssertionError"
"light_on_door_light_on_door-light_on_door-3","gemini-2.5-flash","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: Light on door\n  description: Turn on a light when a door opens, and turn it off when the door closes or after a timeout.\n  domain: automation\n  source_url: https://github.com/home-assistant/core/blob/dev/homeassistant/components/automation/blueprints/light_on_door.yaml # This is a placeholder, replace with actual URL if published\n\ninput:\n  door_sensor:\n    name: Door sensor\n    description: The binary sensor for the door (e.g., contact sensor).\n    selector:\n      entity:\n        domain: binary_sensor\n        device_class: # Suggest common device classes for doors\n          - door\n          - window\n          - garage_door\n          - opening\n          - motion # Sometimes motion sensors are used to detect opening\n          - occupancy # Also for presence in a room after door opens\n  light_switch:\n    name: Light(s) to control\n    description: One or more light entities to turn on/off.\n    selector:\n      target:\n        entity:\n          domain: light\n\nmode: restart\n\ntrigger:\n  - platform: state\n    entity_id: !input door_sensor\n    from: 'off'\n    to: 'on'\n    id: 'door_opened' # Assign an ID for clarity and potential future expansion\n\naction:\n  - choose:\n      - conditions:\n          - condition: trigger\n            id: 'door_opened'\n        sequence:\n          - service: light.turn_on\n            target: !input light_switch\n          - wait_for_trigger:\n              - platform: state\n                entity_id: !input door_sensor\n                to: 'off'\n            timeout: '00:02:00' # 2-minute timeout\n            continue_on_timeout: true # Ensure the automation continues to turn off the light even if timeout occurs\n          - service: light.turn_off\n            target: !input light_switch\n```","light_on_door-test_door_open","Bad","AssertionError: Unable to load automation."
"light_on_door_light_on_door-light_on_door-3","gemini-2.5-flash","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: Light on door\n  description: Turn on a light when a door opens, and turn it off when the door closes or after a timeout.\n  domain: automation\n  source_url: https://github.com/home-assistant/core/blob/dev/homeassistant/components/automation/blueprints/light_on_door.yaml # This is a placeholder, replace with actual URL if published\n\ninput:\n  door_sensor:\n    name: Door sensor\n    description: The binary sensor for the door (e.g., contact sensor).\n    selector:\n      entity:\n        domain: binary_sensor\n        device_class: # Suggest common device classes for doors\n          - door\n          - window\n          - garage_door\n          - opening\n          - motion # Sometimes motion sensors are used to detect opening\n          - occupancy # Also for presence in a room after door opens\n  light_switch:\n    name: Light(s) to control\n    description: One or more light entities to turn on/off.\n    selector:\n      target:\n        entity:\n          domain: light\n\nmode: restart\n\ntrigger:\n  - platform: state\n    entity_id: !input door_sensor\n    from: 'off'\n    to: 'on'\n    id: 'door_opened' # Assign an ID for clarity and potential future expansion\n\naction:\n  - choose:\n      - conditions:\n          - condition: trigger\n            id: 'door_opened'\n        sequence:\n          - service: light.turn_on\n            target: !input light_switch\n          - wait_for_trigger:\n              - platform: state\n                entity_id: !input door_sensor\n                to: 'off'\n            timeout: '00:02:00' # 2-minute timeout\n            continue_on_timeout: true # Ensure the automation continues to turn off the light even if timeout occurs\n          - service: light.turn_off\n            target: !input light_switch\n```","light_on_door-test_door_open_close","Bad","AssertionError: Unable to load automation."
"light_on_door_light_on_door-light_on_door-3","gemini-2.5-flash","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: Light on door\n  description: Turn on a light when a door opens, and turn it off when the door closes or after a timeout.\n  domain: automation\n  source_url: https://github.com/home-assistant/core/blob/dev/homeassistant/components/automation/blueprints/light_on_door.yaml # This is a placeholder, replace with actual URL if published\n\ninput:\n  door_sensor:\n    name: Door sensor\n    description: The binary sensor for the door (e.g., contact sensor).\n    selector:\n      entity:\n        domain: binary_sensor\n        device_class: # Suggest common device classes for doors\n          - door\n          - window\n          - garage_door\n          - opening\n          - motion # Sometimes motion sensors are used to detect opening\n          - occupancy # Also for presence in a room after door opens\n  light_switch:\n    name: Light(s) to control\n    description: One or more light entities to turn on/off.\n    selector:\n      target:\n        entity:\n          domain: light\n\nmode: restart\n\ntrigger:\n  - platform: state\n    entity_id: !input door_sensor\n    from: 'off'\n    to: 'on'\n    id: 'door_opened' # Assign an ID for clarity and potential future expansion\n\naction:\n  - choose:\n      - conditions:\n          - condition: trigger\n            id: 'door_opened'\n        sequence:\n          - service: light.turn_on\n            target: !input light_switch\n          - wait_for_trigger:\n              - platform: state\n                entity_id: !input door_sensor\n                to: 'off'\n            timeout: '00:02:00' # 2-minute timeout\n            continue_on_timeout: true # Ensure the automation continues to turn off the light even if timeout occurs\n          - service: light.turn_off\n            target: !input light_switch\n```","light_on_door-test_light_timeout","Bad","AssertionError: Unable to load automation."
"light_on_door_light_on_door-light_on_door-4","gemini-2.5-flash","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: Light on Door Open\n  description: Turns on a light when a door opens, and turns it off when the door closes or after a 2-minute timeout.\n  domain: automation\n  source_url: https://community.home-assistant.io/t/light-on-door-open/xxxxx # Placeholder for community topic URL\n\n  input:\n    door_sensor:\n      name: Door Sensor\n      description: The binary sensor for the door (e.g., contact sensor, motion sensor).\n      selector:\n        entity:\n          domain: binary_sensor\n    light_switch:\n      name: Light(s) to Control\n      description: The light entity or entities to turn on/off.\n      selector:\n        target:\n          entity:\n            domain: light\n\nmode: single\n\ntrigger:\n  - platform: state\n    entity_id: !input door_sensor\n    from: 'off'\n    to: 'on'\n    id: 'door_opened'\n\naction:\n  - service: light.turn_on\n    target: !input light_switch\n    data: {} # No specific data needed for simple turn_on\n\n  - wait_for_trigger:\n      - platform: state\n        entity_id: !input door_sensor\n        from: 'on'\n        to: 'off'\n        id: 'door_closed'\n    timeout: '00:02:00' # 2-minute timeout\n    continue_on_timeout: true # Important: Ensures the automation proceeds to turn off the light even if it times out\n\n  - service: light.turn_off\n    target: !input light_switch\n    data: {} # No specific data needed for simple turn_off\n```","light_on_door-test_blueprint_inputs","Good",""
"light_on_door_light_on_door-light_on_door-4","gemini-2.5-flash","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: Light on Door Open\n  description: Turns on a light when a door opens, and turns it off when the door closes or after a 2-minute timeout.\n  domain: automation\n  source_url: https://community.home-assistant.io/t/light-on-door-open/xxxxx # Placeholder for community topic URL\n\n  input:\n    door_sensor:\n      name: Door Sensor\n      description: The binary sensor for the door (e.g., contact sensor, motion sensor).\n      selector:\n        entity:\n          domain: binary_sensor\n    light_switch:\n      name: Light(s) to Control\n      description: The light entity or entities to turn on/off.\n      selector:\n        target:\n          entity:\n            domain: light\n\nmode: single\n\ntrigger:\n  - platform: state\n    entity_id: !input door_sensor\n    from: 'off'\n    to: 'on'\n    id: 'door_opened'\n\naction:\n  - service: light.turn_on\n    target: !input light_switch\n    data: {} # No specific data needed for simple turn_on\n\n  - wait_for_trigger:\n      - platform: state\n        entity_id: !input door_sensor\n        from: 'on'\n        to: 'off'\n        id: 'door_closed'\n    timeout: '00:02:00' # 2-minute timeout\n    continue_on_timeout: true # Important: Ensures the automation proceeds to turn off the light even if it times out\n\n  - service: light.turn_off\n    target: !input light_switch\n    data: {} # No specific data needed for simple turn_off\n```","light_on_door-test_door_open","Good",""
"light_on_door_light_on_door-light_on_door-4","gemini-2.5-flash","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: Light on Door Open\n  description: Turns on a light when a door opens, and turns it off when the door closes or after a 2-minute timeout.\n  domain: automation\n  source_url: https://community.home-assistant.io/t/light-on-door-open/xxxxx # Placeholder for community topic URL\n\n  input:\n    door_sensor:\n      name: Door Sensor\n      description: The binary sensor for the door (e.g., contact sensor, motion sensor).\n      selector:\n        entity:\n          domain: binary_sensor\n    light_switch:\n      name: Light(s) to Control\n      description: The light entity or entities to turn on/off.\n      selector:\n        target:\n          entity:\n            domain: light\n\nmode: single\n\ntrigger:\n  - platform: state\n    entity_id: !input door_sensor\n    from: 'off'\n    to: 'on'\n    id: 'door_opened'\n\naction:\n  - service: light.turn_on\n    target: !input light_switch\n    data: {} # No specific data needed for simple turn_on\n\n  - wait_for_trigger:\n      - platform: state\n        entity_id: !input door_sensor\n        from: 'on'\n        to: 'off'\n        id: 'door_closed'\n    timeout: '00:02:00' # 2-minute timeout\n    continue_on_timeout: true # Important: Ensures the automation proceeds to turn off the light even if it times out\n\n  - service: light.turn_off\n    target: !input light_switch\n    data: {} # No specific data needed for simple turn_off\n```","light_on_door-test_door_open_close","Good",""
"light_on_door_light_on_door-light_on_door-4","gemini-2.5-flash","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: Light on Door Open\n  description: Turns on a light when a door opens, and turns it off when the door closes or after a 2-minute timeout.\n  domain: automation\n  source_url: https://community.home-assistant.io/t/light-on-door-open/xxxxx # Placeholder for community topic URL\n\n  input:\n    door_sensor:\n      name: Door Sensor\n      description: The binary sensor for the door (e.g., contact sensor, motion sensor).\n      selector:\n        entity:\n          domain: binary_sensor\n    light_switch:\n      name: Light(s) to Control\n      description: The light entity or entities to turn on/off.\n      selector:\n        target:\n          entity:\n            domain: light\n\nmode: single\n\ntrigger:\n  - platform: state\n    entity_id: !input door_sensor\n    from: 'off'\n    to: 'on'\n    id: 'door_opened'\n\naction:\n  - service: light.turn_on\n    target: !input light_switch\n    data: {} # No specific data needed for simple turn_on\n\n  - wait_for_trigger:\n      - platform: state\n        entity_id: !input door_sensor\n        from: 'on'\n        to: 'off'\n        id: 'door_closed'\n    timeout: '00:02:00' # 2-minute timeout\n    continue_on_timeout: true # Important: Ensures the automation proceeds to turn off the light even if it times out\n\n  - service: light.turn_off\n    target: !input light_switch\n    data: {} # No specific data needed for simple turn_off\n```","light_on_door-test_light_timeout","Good",""
"light_on_door_light_on_door-light_on_door-0","gemini-2.5-flash-lite","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: Light on door\n  description: Turns on a light when a door opens, and turns it off after a timeout or when the door closes.\n  domain: automation\n  input:\n    door_sensor:\n      name: Door Sensor\n      description: The binary sensor that indicates if the door is open.\n      selector:\n        entity:\n          domain: binary_sensor\n    light_switch:\n      name: Light to control\n      description: The light entity (or entities) to turn on when the door opens.\n      selector:\n        target:\n          entity:\n            domain: light\n\n# Trigger when the door sensor changes state\ntrigger:\n  - platform: state\n    entity_id: !input door_sensor\n    to: 'on' # Trigger when the door sensor state changes to 'on' (representing open)\n\n# Action to perform when triggered\naction:\n  - service: light.turn_on\n    target: !input light_switch\n  # Wait for the door to close or for a timeout\n  - wait_for_trigger:\n      - platform: state\n        entity_id: !input door_sensor\n        to: 'off' # Wait until the door sensor state changes to 'off' (representing closed)\n    timeout: '00:02:00' # Set a timeout of 2 minutes\n  # Turn off the light\n  - service: light.turn_off\n    target: !input light_switch\n\n# This condition ensures the blueprint will only run if the door sensor is not already 'on' before the trigger.\n# Although the trigger explicitly looks for 'on', this can prevent unexpected behavior if the sensor state is changed rapidly.\n# It's a good practice for robustness.\n# condition: [] # No specific conditions needed beyond the trigger\n\n# Mode: single ensures that if the automation is triggered again while it's already running,\n# the new trigger will be ignored. This is usually desirable for this type of automation\n# to avoid multiple instances of the light turning on/off erratically.\nmode: single\n```","light_on_door-test_blueprint_inputs","Good",""
"light_on_door_light_on_door-light_on_door-0","gemini-2.5-flash-lite","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: Light on door\n  description: Turns on a light when a door opens, and turns it off after a timeout or when the door closes.\n  domain: automation\n  input:\n    door_sensor:\n      name: Door Sensor\n      description: The binary sensor that indicates if the door is open.\n      selector:\n        entity:\n          domain: binary_sensor\n    light_switch:\n      name: Light to control\n      description: The light entity (or entities) to turn on when the door opens.\n      selector:\n        target:\n          entity:\n            domain: light\n\n# Trigger when the door sensor changes state\ntrigger:\n  - platform: state\n    entity_id: !input door_sensor\n    to: 'on' # Trigger when the door sensor state changes to 'on' (representing open)\n\n# Action to perform when triggered\naction:\n  - service: light.turn_on\n    target: !input light_switch\n  # Wait for the door to close or for a timeout\n  - wait_for_trigger:\n      - platform: state\n        entity_id: !input door_sensor\n        to: 'off' # Wait until the door sensor state changes to 'off' (representing closed)\n    timeout: '00:02:00' # Set a timeout of 2 minutes\n  # Turn off the light\n  - service: light.turn_off\n    target: !input light_switch\n\n# This condition ensures the blueprint will only run if the door sensor is not already 'on' before the trigger.\n# Although the trigger explicitly looks for 'on', this can prevent unexpected behavior if the sensor state is changed rapidly.\n# It's a good practice for robustness.\n# condition: [] # No specific conditions needed beyond the trigger\n\n# Mode: single ensures that if the automation is triggered again while it's already running,\n# the new trigger will be ignored. This is usually desirable for this type of automation\n# to avoid multiple instances of the light turning on/off erratically.\nmode: single\n```","light_on_door-test_door_open","Good",""
"light_on_door_light_on_door-light_on_door-0","gemini-2.5-flash-lite","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: Light on door\n  description: Turns on a light when a door opens, and turns it off after a timeout or when the door closes.\n  domain: automation\n  input:\n    door_sensor:\n      name: Door Sensor\n      description: The binary sensor that indicates if the door is open.\n      selector:\n        entity:\n          domain: binary_sensor\n    light_switch:\n      name: Light to control\n      description: The light entity (or entities) to turn on when the door opens.\n      selector:\n        target:\n          entity:\n            domain: light\n\n# Trigger when the door sensor changes state\ntrigger:\n  - platform: state\n    entity_id: !input door_sensor\n    to: 'on' # Trigger when the door sensor state changes to 'on' (representing open)\n\n# Action to perform when triggered\naction:\n  - service: light.turn_on\n    target: !input light_switch\n  # Wait for the door to close or for a timeout\n  - wait_for_trigger:\n      - platform: state\n        entity_id: !input door_sensor\n        to: 'off' # Wait until the door sensor state changes to 'off' (representing closed)\n    timeout: '00:02:00' # Set a timeout of 2 minutes\n  # Turn off the light\n  - service: light.turn_off\n    target: !input light_switch\n\n# This condition ensures the blueprint will only run if the door sensor is not already 'on' before the trigger.\n# Although the trigger explicitly looks for 'on', this can prevent unexpected behavior if the sensor state is changed rapidly.\n# It's a good practice for robustness.\n# condition: [] # No specific conditions needed beyond the trigger\n\n# Mode: single ensures that if the automation is triggered again while it's already running,\n# the new trigger will be ignored. This is usually desirable for this type of automation\n# to avoid multiple instances of the light turning on/off erratically.\nmode: single\n```","light_on_door-test_door_open_close","Good",""
"light_on_door_light_on_door-light_on_door-0","gemini-2.5-flash-lite","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: Light on door\n  description: Turns on a light when a door opens, and turns it off after a timeout or when the door closes.\n  domain: automation\n  input:\n    door_sensor:\n      name: Door Sensor\n      description: The binary sensor that indicates if the door is open.\n      selector:\n        entity:\n          domain: binary_sensor\n    light_switch:\n      name: Light to control\n      description: The light entity (or entities) to turn on when the door opens.\n      selector:\n        target:\n          entity:\n            domain: light\n\n# Trigger when the door sensor changes state\ntrigger:\n  - platform: state\n    entity_id: !input door_sensor\n    to: 'on' # Trigger when the door sensor state changes to 'on' (representing open)\n\n# Action to perform when triggered\naction:\n  - service: light.turn_on\n    target: !input light_switch\n  # Wait for the door to close or for a timeout\n  - wait_for_trigger:\n      - platform: state\n        entity_id: !input door_sensor\n        to: 'off' # Wait until the door sensor state changes to 'off' (representing closed)\n    timeout: '00:02:00' # Set a timeout of 2 minutes\n  # Turn off the light\n  - service: light.turn_off\n    target: !input light_switch\n\n# This condition ensures the blueprint will only run if the door sensor is not already 'on' before the trigger.\n# Although the trigger explicitly looks for 'on', this can prevent unexpected behavior if the sensor state is changed rapidly.\n# It's a good practice for robustness.\n# condition: [] # No specific conditions needed beyond the trigger\n\n# Mode: single ensures that if the automation is triggered again while it's already running,\n# the new trigger will be ignored. This is usually desirable for this type of automation\n# to avoid multiple instances of the light turning on/off erratically.\nmode: single\n```","light_on_door-test_light_timeout","Good",""
"light_on_door_light_on_door-light_on_door-1","gemini-2.5-flash-lite","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\n# Blueprint for turning on a light when a door opens.\nblueprint:\n  name: Light on door\n  description: Turns on a light when a door opens, and turns it off when the door closes or after a timeout.\n  domain: automation\n  input:\n    door_sensor:\n      name: Door Sensor\n      description: The binary sensor that detects if the door is open or closed.\n      selector:\n        entity:\n          domain: binary_sensor\n    light_switch:\n      name: Light(s) to Control\n      description: The light entity or entities to turn on and off.\n      selector:\n        target:\n          entity:\n            domain: light\n    # Added a timeout for the light to turn off, defaulting to 2 minutes.\n    # The user can adjust this if needed, but it's good to have a sensible default.\n    timeout:\n      name: Timeout\n      description: How long the light should stay on after the door closes.\n      default: 120 # seconds\n      selector:\n        number:\n          min: 10\n          max: 3600 # 1 hour\n          unit_of_measurement: seconds\n          step: 1\n          mode: slider\n\n# The trigger for the automation is when the door sensor changes state.\ntrigger:\n  - platform: state\n    entity_id: !input door_sensor\n    # This trigger will fire when the door_sensor state changes to 'on' (open).\n    to: 'on'\n\n# The actions to perform when the trigger fires.\naction:\n  # Turn on the selected light(s).\n  - service: light.turn_on\n    target: !input light_switch\n  # Wait for the door sensor to close ('off').\n  # This ensures the light stays on while the door is open.\n  - wait_for_trigger:\n      - platform: state\n        entity_id: !input door_sensor\n        to: 'off'\n  # After the door closes, wait for the specified timeout.\n  - delay: !input timeout\n  # Turn off the selected light(s).\n  - service: light.turn_off\n    target: !input light_switch\n# This condition ensures the automation only runs when the door sensor is 'on'.\n# It's redundant with the trigger `to: 'on'` but can be useful for clarity or\n# if the trigger was more complex (e.g., any state change).\n# For this specific case, the trigger is sufficient.\n# condition:\n#   - condition: state\n#     entity_id: !input door_sensor\n#     state: 'on'\n\n# The automation should only run if the door sensor is actually open when triggered.\n# This is implicitly handled by the trigger's `to: 'on'`.\n# The blueprint is designed to turn the light ON when the door OPENS.\n# The light will turn OFF after the door CLOSES and the timeout has passed.\n# This means the automation will complete its sequence and be ready for the next door open event.\n```","light_on_door-test_blueprint_inputs","Good",""
"light_on_door_light_on_door-light_on_door-1","gemini-2.5-flash-lite","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\n# Blueprint for turning on a light when a door opens.\nblueprint:\n  name: Light on door\n  description: Turns on a light when a door opens, and turns it off when the door closes or after a timeout.\n  domain: automation\n  input:\n    door_sensor:\n      name: Door Sensor\n      description: The binary sensor that detects if the door is open or closed.\n      selector:\n        entity:\n          domain: binary_sensor\n    light_switch:\n      name: Light(s) to Control\n      description: The light entity or entities to turn on and off.\n      selector:\n        target:\n          entity:\n            domain: light\n    # Added a timeout for the light to turn off, defaulting to 2 minutes.\n    # The user can adjust this if needed, but it's good to have a sensible default.\n    timeout:\n      name: Timeout\n      description: How long the light should stay on after the door closes.\n      default: 120 # seconds\n      selector:\n        number:\n          min: 10\n          max: 3600 # 1 hour\n          unit_of_measurement: seconds\n          step: 1\n          mode: slider\n\n# The trigger for the automation is when the door sensor changes state.\ntrigger:\n  - platform: state\n    entity_id: !input door_sensor\n    # This trigger will fire when the door_sensor state changes to 'on' (open).\n    to: 'on'\n\n# The actions to perform when the trigger fires.\naction:\n  # Turn on the selected light(s).\n  - service: light.turn_on\n    target: !input light_switch\n  # Wait for the door sensor to close ('off').\n  # This ensures the light stays on while the door is open.\n  - wait_for_trigger:\n      - platform: state\n        entity_id: !input door_sensor\n        to: 'off'\n  # After the door closes, wait for the specified timeout.\n  - delay: !input timeout\n  # Turn off the selected light(s).\n  - service: light.turn_off\n    target: !input light_switch\n# This condition ensures the automation only runs when the door sensor is 'on'.\n# It's redundant with the trigger `to: 'on'` but can be useful for clarity or\n# if the trigger was more complex (e.g., any state change).\n# For this specific case, the trigger is sufficient.\n# condition:\n#   - condition: state\n#     entity_id: !input door_sensor\n#     state: 'on'\n\n# The automation should only run if the door sensor is actually open when triggered.\n# This is implicitly handled by the trigger's `to: 'on'`.\n# The blueprint is designed to turn the light ON when the door OPENS.\n# The light will turn OFF after the door CLOSES and the timeout has passed.\n# This means the automation will complete its sequence and be ready for the next door open event.\n```","light_on_door-test_door_open","Good",""
"light_on_door_light_on_door-light_on_door-1","gemini-2.5-flash-lite","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\n# Blueprint for turning on a light when a door opens.\nblueprint:\n  name: Light on door\n  description: Turns on a light when a door opens, and turns it off when the door closes or after a timeout.\n  domain: automation\n  input:\n    door_sensor:\n      name: Door Sensor\n      description: The binary sensor that detects if the door is open or closed.\n      selector:\n        entity:\n          domain: binary_sensor\n    light_switch:\n      name: Light(s) to Control\n      description: The light entity or entities to turn on and off.\n      selector:\n        target:\n          entity:\n            domain: light\n    # Added a timeout for the light to turn off, defaulting to 2 minutes.\n    # The user can adjust this if needed, but it's good to have a sensible default.\n    timeout:\n      name: Timeout\n      description: How long the light should stay on after the door closes.\n      default: 120 # seconds\n      selector:\n        number:\n          min: 10\n          max: 3600 # 1 hour\n          unit_of_measurement: seconds\n          step: 1\n          mode: slider\n\n# The trigger for the automation is when the door sensor changes state.\ntrigger:\n  - platform: state\n    entity_id: !input door_sensor\n    # This trigger will fire when the door_sensor state changes to 'on' (open).\n    to: 'on'\n\n# The actions to perform when the trigger fires.\naction:\n  # Turn on the selected light(s).\n  - service: light.turn_on\n    target: !input light_switch\n  # Wait for the door sensor to close ('off').\n  # This ensures the light stays on while the door is open.\n  - wait_for_trigger:\n      - platform: state\n        entity_id: !input door_sensor\n        to: 'off'\n  # After the door closes, wait for the specified timeout.\n  - delay: !input timeout\n  # Turn off the selected light(s).\n  - service: light.turn_off\n    target: !input light_switch\n# This condition ensures the automation only runs when the door sensor is 'on'.\n# It's redundant with the trigger `to: 'on'` but can be useful for clarity or\n# if the trigger was more complex (e.g., any state change).\n# For this specific case, the trigger is sufficient.\n# condition:\n#   - condition: state\n#     entity_id: !input door_sensor\n#     state: 'on'\n\n# The automation should only run if the door sensor is actually open when triggered.\n# This is implicitly handled by the trigger's `to: 'on'`.\n# The blueprint is designed to turn the light ON when the door OPENS.\n# The light will turn OFF after the door CLOSES and the timeout has passed.\n# This means the automation will complete its sequence and be ready for the next door open event.\n```","light_on_door-test_door_open_close","Bad","TimeoutError,TimeoutError: Timeout waiting for light to turn off"
"light_on_door_light_on_door-light_on_door-1","gemini-2.5-flash-lite","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\n# Blueprint for turning on a light when a door opens.\nblueprint:\n  name: Light on door\n  description: Turns on a light when a door opens, and turns it off when the door closes or after a timeout.\n  domain: automation\n  input:\n    door_sensor:\n      name: Door Sensor\n      description: The binary sensor that detects if the door is open or closed.\n      selector:\n        entity:\n          domain: binary_sensor\n    light_switch:\n      name: Light(s) to Control\n      description: The light entity or entities to turn on and off.\n      selector:\n        target:\n          entity:\n            domain: light\n    # Added a timeout for the light to turn off, defaulting to 2 minutes.\n    # The user can adjust this if needed, but it's good to have a sensible default.\n    timeout:\n      name: Timeout\n      description: How long the light should stay on after the door closes.\n      default: 120 # seconds\n      selector:\n        number:\n          min: 10\n          max: 3600 # 1 hour\n          unit_of_measurement: seconds\n          step: 1\n          mode: slider\n\n# The trigger for the automation is when the door sensor changes state.\ntrigger:\n  - platform: state\n    entity_id: !input door_sensor\n    # This trigger will fire when the door_sensor state changes to 'on' (open).\n    to: 'on'\n\n# The actions to perform when the trigger fires.\naction:\n  # Turn on the selected light(s).\n  - service: light.turn_on\n    target: !input light_switch\n  # Wait for the door sensor to close ('off').\n  # This ensures the light stays on while the door is open.\n  - wait_for_trigger:\n      - platform: state\n        entity_id: !input door_sensor\n        to: 'off'\n  # After the door closes, wait for the specified timeout.\n  - delay: !input timeout\n  # Turn off the selected light(s).\n  - service: light.turn_off\n    target: !input light_switch\n# This condition ensures the automation only runs when the door sensor is 'on'.\n# It's redundant with the trigger `to: 'on'` but can be useful for clarity or\n# if the trigger was more complex (e.g., any state change).\n# For this specific case, the trigger is sufficient.\n# condition:\n#   - condition: state\n#     entity_id: !input door_sensor\n#     state: 'on'\n\n# The automation should only run if the door sensor is actually open when triggered.\n# This is implicitly handled by the trigger's `to: 'on'`.\n# The blueprint is designed to turn the light ON when the door OPENS.\n# The light will turn OFF after the door CLOSES and the timeout has passed.\n# This means the automation will complete its sequence and be ready for the next door open event.\n```","light_on_door-test_light_timeout","Bad","TimeoutError,TimeoutError: Timeout waiting for light to turn off"
"light_on_door_light_on_door-light_on_door-2","gemini-2.5-flash-lite","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","Sorry, I had a problem getting a response from Google Generative AI. Reason: FinishReason.MAX_TOKENS","light_on_door-test_blueprint_inputs","Bad","AssertionError: Blueprint content is not available"
"light_on_door_light_on_door-light_on_door-2","gemini-2.5-flash-lite","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","Sorry, I had a problem getting a response from Google Generative AI. Reason: FinishReason.MAX_TOKENS","light_on_door-test_door_open","Bad","AssertionError: Could not extract YAML from model response: Sorry, I had a problem getting a response from Google Generative AI. Reason: FinishReason.MAX_TOKENS"
"light_on_door_light_on_door-light_on_door-2","gemini-2.5-flash-lite","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","Sorry, I had a problem getting a response from Google Generative AI. Reason: FinishReason.MAX_TOKENS","light_on_door-test_door_open_close","Bad","AssertionError: Could not extract YAML from model response: Sorry, I had a problem getting a response from Google Generative AI. Reason: FinishReason.MAX_TOKENS"
"light_on_door_light_on_door-light_on_door-2","gemini-2.5-flash-lite","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","Sorry, I had a problem getting a response from Google Generative AI. Reason: FinishReason.MAX_TOKENS","light_on_door-test_light_timeout","Bad","AssertionError: Could not extract YAML from model response: Sorry, I had a problem getting a response from Google Generative AI. Reason: FinishReason.MAX_TOKENS"
"light_on_door_light_on_door-light_on_door-3","gemini-2.5-flash-lite","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","Sorry, I had a problem getting a response from Google Generative AI. Reason: FinishReason.MAX_TOKENS","light_on_door-test_blueprint_inputs","Bad","AssertionError: Blueprint content is not available"
"light_on_door_light_on_door-light_on_door-3","gemini-2.5-flash-lite","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","Sorry, I had a problem getting a response from Google Generative AI. Reason: FinishReason.MAX_TOKENS","light_on_door-test_door_open","Bad","AssertionError: Could not extract YAML from model response: Sorry, I had a problem getting a response from Google Generative AI. Reason: FinishReason.MAX_TOKENS"
"light_on_door_light_on_door-light_on_door-3","gemini-2.5-flash-lite","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","Sorry, I had a problem getting a response from Google Generative AI. Reason: FinishReason.MAX_TOKENS","light_on_door-test_door_open_close","Bad","AssertionError: Could not extract YAML from model response: Sorry, I had a problem getting a response from Google Generative AI. Reason: FinishReason.MAX_TOKENS"
"light_on_door_light_on_door-light_on_door-3","gemini-2.5-flash-lite","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","Sorry, I had a problem getting a response from Google Generative AI. Reason: FinishReason.MAX_TOKENS","light_on_door-test_light_timeout","Bad","AssertionError: Could not extract YAML from model response: Sorry, I had a problem getting a response from Google Generative AI. Reason: FinishReason.MAX_TOKENS"
"light_on_door_light_on_door-light_on_door-4","gemini-2.5-flash-lite","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\n# Blueprint for turning on a light when a door opens\nblueprint:\n  name: Light on Door\n  description: Turns on a light when a door sensor opens, and turns it off when the door closes or after a timeout.\n  domain: automation\n  input:\n    door_sensor:\n      name: Door Sensor\n      description: The binary sensor that indicates if the door is open or closed.\n      selector:\n        entity:\n          domain: binary_sensor\n    light_switch:\n      name: Light(s) to control\n      description: The light entity or entities to turn on when the door opens.\n      selector:\n        target:\n          entity:\n            domain: light\n    # Adding an optional input for timeout duration\n    timeout:\n      name: Timeout Duration (minutes)\n      description: How long the light should stay on after the door closes before turning off. Leave empty for no timeout.\n      default: 2\n      selector:\n        number:\n          min: 1\n          max: 60\n          unit_of_measurement: min\n          mode: slider\n\n# The actual automation logic\nvariables:\n  # Use the input values directly\n  door_sensor_id: !input door_sensor\n  light_switch_id: !input light_switch\n  timeout_duration: !input timeout\n\n# Define the trigger for the automation.\n# This will be the door sensor opening.\ntrigger:\n  - platform: state\n    entity_id: !input door_sensor\n    to: 'on' # Trigger when the binary sensor state changes to 'on' (door opens)\n\n# Define the conditions for the automation.\n# No specific conditions are required for this basic blueprint,\n# but you could add them here if needed (e.g., only turn on light if it's dark).\ncondition: []\n\n# Define the actions to be performed when the trigger and conditions are met.\naction:\n  # Turn on the light(s)\n  - service: light.turn_on\n    target: !input light_switch\n\n  # Wait for the door to close OR for the timeout to occur.\n  # This part is a bit more complex as we need two potential paths to turn off the light.\n  # We'll use a wait_for_trigger and a delay.\n  # If the door closes first, the wait_for_trigger will complete.\n  # If the timeout happens first, the wait_for_trigger will time out.\n  # We'll then use a choose action to handle both scenarios.\n  - wait_for_trigger:\n      # Wait for the door to close\n      - platform: state\n        entity_id: !input door_sensor\n        to: 'off'\n      # Wait for the timeout\n      - platform: delay\n        # Convert minutes to seconds for the delay\n        seconds: '{{ timeout_duration * 60 }}'\n    timeout: '{{ timeout_duration * 60 }}' # Set the timeout for the wait_for_trigger itself\n\n  # Now, use a choose action to determine whether the door closed or the timeout occurred.\n  - choose:\n      # If the door sensor is 'off' (meaning it closed before the timeout)\n      - conditions:\n          - condition: state\n            entity_id: !input door_sensor\n            state: 'off'\n        sequence:\n          # Turn off the light\n          - service: light.turn_off\n            target: !input light_switch\n      # If the door sensor is still 'on' (meaning the timeout occurred before the door closed)\n      - conditions:\n          - condition: state\n            entity_id: !input door_sensor\n            state: 'on'\n        sequence:\n          # Turn off the light after the timeout\n          - service: light.turn_off\n            target: !input light_switch\n    # Default sequence if none of the above conditions are met (shouldn't happen in this logic)\n    default: []\n```","light_on_door-test_blueprint_inputs","Good",""
"light_on_door_light_on_door-light_on_door-4","gemini-2.5-flash-lite","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\n# Blueprint for turning on a light when a door opens\nblueprint:\n  name: Light on Door\n  description: Turns on a light when a door sensor opens, and turns it off when the door closes or after a timeout.\n  domain: automation\n  input:\n    door_sensor:\n      name: Door Sensor\n      description: The binary sensor that indicates if the door is open or closed.\n      selector:\n        entity:\n          domain: binary_sensor\n    light_switch:\n      name: Light(s) to control\n      description: The light entity or entities to turn on when the door opens.\n      selector:\n        target:\n          entity:\n            domain: light\n    # Adding an optional input for timeout duration\n    timeout:\n      name: Timeout Duration (minutes)\n      description: How long the light should stay on after the door closes before turning off. Leave empty for no timeout.\n      default: 2\n      selector:\n        number:\n          min: 1\n          max: 60\n          unit_of_measurement: min\n          mode: slider\n\n# The actual automation logic\nvariables:\n  # Use the input values directly\n  door_sensor_id: !input door_sensor\n  light_switch_id: !input light_switch\n  timeout_duration: !input timeout\n\n# Define the trigger for the automation.\n# This will be the door sensor opening.\ntrigger:\n  - platform: state\n    entity_id: !input door_sensor\n    to: 'on' # Trigger when the binary sensor state changes to 'on' (door opens)\n\n# Define the conditions for the automation.\n# No specific conditions are required for this basic blueprint,\n# but you could add them here if needed (e.g., only turn on light if it's dark).\ncondition: []\n\n# Define the actions to be performed when the trigger and conditions are met.\naction:\n  # Turn on the light(s)\n  - service: light.turn_on\n    target: !input light_switch\n\n  # Wait for the door to close OR for the timeout to occur.\n  # This part is a bit more complex as we need two potential paths to turn off the light.\n  # We'll use a wait_for_trigger and a delay.\n  # If the door closes first, the wait_for_trigger will complete.\n  # If the timeout happens first, the wait_for_trigger will time out.\n  # We'll then use a choose action to handle both scenarios.\n  - wait_for_trigger:\n      # Wait for the door to close\n      - platform: state\n        entity_id: !input door_sensor\n        to: 'off'\n      # Wait for the timeout\n      - platform: delay\n        # Convert minutes to seconds for the delay\n        seconds: '{{ timeout_duration * 60 }}'\n    timeout: '{{ timeout_duration * 60 }}' # Set the timeout for the wait_for_trigger itself\n\n  # Now, use a choose action to determine whether the door closed or the timeout occurred.\n  - choose:\n      # If the door sensor is 'off' (meaning it closed before the timeout)\n      - conditions:\n          - condition: state\n            entity_id: !input door_sensor\n            state: 'off'\n        sequence:\n          # Turn off the light\n          - service: light.turn_off\n            target: !input light_switch\n      # If the door sensor is still 'on' (meaning the timeout occurred before the door closed)\n      - conditions:\n          - condition: state\n            entity_id: !input door_sensor\n            state: 'on'\n        sequence:\n          # Turn off the light after the timeout\n          - service: light.turn_off\n            target: !input light_switch\n    # Default sequence if none of the above conditions are met (shouldn't happen in this logic)\n    default: []\n```","light_on_door-test_door_open","Bad","AssertionError: Unable to load automation."
"light_on_door_light_on_door-light_on_door-4","gemini-2.5-flash-lite","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\n# Blueprint for turning on a light when a door opens\nblueprint:\n  name: Light on Door\n  description: Turns on a light when a door sensor opens, and turns it off when the door closes or after a timeout.\n  domain: automation\n  input:\n    door_sensor:\n      name: Door Sensor\n      description: The binary sensor that indicates if the door is open or closed.\n      selector:\n        entity:\n          domain: binary_sensor\n    light_switch:\n      name: Light(s) to control\n      description: The light entity or entities to turn on when the door opens.\n      selector:\n        target:\n          entity:\n            domain: light\n    # Adding an optional input for timeout duration\n    timeout:\n      name: Timeout Duration (minutes)\n      description: How long the light should stay on after the door closes before turning off. Leave empty for no timeout.\n      default: 2\n      selector:\n        number:\n          min: 1\n          max: 60\n          unit_of_measurement: min\n          mode: slider\n\n# The actual automation logic\nvariables:\n  # Use the input values directly\n  door_sensor_id: !input door_sensor\n  light_switch_id: !input light_switch\n  timeout_duration: !input timeout\n\n# Define the trigger for the automation.\n# This will be the door sensor opening.\ntrigger:\n  - platform: state\n    entity_id: !input door_sensor\n    to: 'on' # Trigger when the binary sensor state changes to 'on' (door opens)\n\n# Define the conditions for the automation.\n# No specific conditions are required for this basic blueprint,\n# but you could add them here if needed (e.g., only turn on light if it's dark).\ncondition: []\n\n# Define the actions to be performed when the trigger and conditions are met.\naction:\n  # Turn on the light(s)\n  - service: light.turn_on\n    target: !input light_switch\n\n  # Wait for the door to close OR for the timeout to occur.\n  # This part is a bit more complex as we need two potential paths to turn off the light.\n  # We'll use a wait_for_trigger and a delay.\n  # If the door closes first, the wait_for_trigger will complete.\n  # If the timeout happens first, the wait_for_trigger will time out.\n  # We'll then use a choose action to handle both scenarios.\n  - wait_for_trigger:\n      # Wait for the door to close\n      - platform: state\n        entity_id: !input door_sensor\n        to: 'off'\n      # Wait for the timeout\n      - platform: delay\n        # Convert minutes to seconds for the delay\n        seconds: '{{ timeout_duration * 60 }}'\n    timeout: '{{ timeout_duration * 60 }}' # Set the timeout for the wait_for_trigger itself\n\n  # Now, use a choose action to determine whether the door closed or the timeout occurred.\n  - choose:\n      # If the door sensor is 'off' (meaning it closed before the timeout)\n      - conditions:\n          - condition: state\n            entity_id: !input door_sensor\n            state: 'off'\n        sequence:\n          # Turn off the light\n          - service: light.turn_off\n            target: !input light_switch\n      # If the door sensor is still 'on' (meaning the timeout occurred before the door closed)\n      - conditions:\n          - condition: state\n            entity_id: !input door_sensor\n            state: 'on'\n        sequence:\n          # Turn off the light after the timeout\n          - service: light.turn_off\n            target: !input light_switch\n    # Default sequence if none of the above conditions are met (shouldn't happen in this logic)\n    default: []\n```","light_on_door-test_door_open_close","Bad","AssertionError: Unable to load automation."
"light_on_door_light_on_door-light_on_door-4","gemini-2.5-flash-lite","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\n# Blueprint for turning on a light when a door opens\nblueprint:\n  name: Light on Door\n  description: Turns on a light when a door sensor opens, and turns it off when the door closes or after a timeout.\n  domain: automation\n  input:\n    door_sensor:\n      name: Door Sensor\n      description: The binary sensor that indicates if the door is open or closed.\n      selector:\n        entity:\n          domain: binary_sensor\n    light_switch:\n      name: Light(s) to control\n      description: The light entity or entities to turn on when the door opens.\n      selector:\n        target:\n          entity:\n            domain: light\n    # Adding an optional input for timeout duration\n    timeout:\n      name: Timeout Duration (minutes)\n      description: How long the light should stay on after the door closes before turning off. Leave empty for no timeout.\n      default: 2\n      selector:\n        number:\n          min: 1\n          max: 60\n          unit_of_measurement: min\n          mode: slider\n\n# The actual automation logic\nvariables:\n  # Use the input values directly\n  door_sensor_id: !input door_sensor\n  light_switch_id: !input light_switch\n  timeout_duration: !input timeout\n\n# Define the trigger for the automation.\n# This will be the door sensor opening.\ntrigger:\n  - platform: state\n    entity_id: !input door_sensor\n    to: 'on' # Trigger when the binary sensor state changes to 'on' (door opens)\n\n# Define the conditions for the automation.\n# No specific conditions are required for this basic blueprint,\n# but you could add them here if needed (e.g., only turn on light if it's dark).\ncondition: []\n\n# Define the actions to be performed when the trigger and conditions are met.\naction:\n  # Turn on the light(s)\n  - service: light.turn_on\n    target: !input light_switch\n\n  # Wait for the door to close OR for the timeout to occur.\n  # This part is a bit more complex as we need two potential paths to turn off the light.\n  # We'll use a wait_for_trigger and a delay.\n  # If the door closes first, the wait_for_trigger will complete.\n  # If the timeout happens first, the wait_for_trigger will time out.\n  # We'll then use a choose action to handle both scenarios.\n  - wait_for_trigger:\n      # Wait for the door to close\n      - platform: state\n        entity_id: !input door_sensor\n        to: 'off'\n      # Wait for the timeout\n      - platform: delay\n        # Convert minutes to seconds for the delay\n        seconds: '{{ timeout_duration * 60 }}'\n    timeout: '{{ timeout_duration * 60 }}' # Set the timeout for the wait_for_trigger itself\n\n  # Now, use a choose action to determine whether the door closed or the timeout occurred.\n  - choose:\n      # If the door sensor is 'off' (meaning it closed before the timeout)\n      - conditions:\n          - condition: state\n            entity_id: !input door_sensor\n            state: 'off'\n        sequence:\n          # Turn off the light\n          - service: light.turn_off\n            target: !input light_switch\n      # If the door sensor is still 'on' (meaning the timeout occurred before the door closed)\n      - conditions:\n          - condition: state\n            entity_id: !input door_sensor\n            state: 'on'\n        sequence:\n          # Turn off the light after the timeout\n          - service: light.turn_off\n            target: !input light_switch\n    # Default sequence if none of the above conditions are met (shouldn't happen in this logic)\n    default: []\n```","light_on_door-test_light_timeout","Bad","AssertionError: Unable to load automation."
"light_on_door_light_on_door-light_on_door-0","qwen3-1.7b","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","Timeout (after 3 tries)","light_on_door-test_blueprint_inputs","Bad","AssertionError: Blueprint content is not available"
"light_on_door_light_on_door-light_on_door-0","qwen3-1.7b","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","Timeout (after 3 tries)","light_on_door-test_door_open","Bad","AssertionError: Could not extract YAML from model response: Timeout (after 3 tries)"
"light_on_door_light_on_door-light_on_door-0","qwen3-1.7b","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","Timeout (after 3 tries)","light_on_door-test_door_open_close","Bad","AssertionError: Could not extract YAML from model response: Timeout (after 3 tries)"
"light_on_door_light_on_door-light_on_door-0","qwen3-1.7b","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","Timeout (after 3 tries)","light_on_door-test_light_timeout","Bad","AssertionError: Could not extract YAML from model response: Timeout (after 3 tries)"
"light_on_door_light_on_door-light_on_door-1","qwen3-1.7b","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\n# Home Assistant Blueprint: Light on door\n\n# Configuration for the automation\nautomation:\n  # Trigger the automation when the door opens\n  - trigger:\n    - platform: sensor\n      sensor:\n        platform: binary_sensor\n        sensor_id: door_sensor\n        value: true\n\n  # Action to turn on the light when the door opens\n  - action:\n    - platform: template\n      function: turn_on_light\n      data:\n        light_switch: '{{ states('light.pantry_light').state == 'on' ? 'light.pantry_light' : 'light.pantry_light' }'\n\n  # Timeout to shut off the light after 2 minutes\n  - action:\n    - platform: template\n      function: turn_off_light\n      data:\n        light_switch: '{{ states('light.pantry_light').state == 'on' ? 'light.pantry_light' : 'light.pantry_light' }}'\n        timeout: 120\n\n  # Conditional to check if the door is open\n  - condition:\n    - platform: template\n      function: is_door_open\n      data:\n        door_sensor: '{{ states('sensor.door_sensor').state == 'open' }}'\n\n  # Conditional to check if the door is closed or after timeout\n  - condition:\n    - platform: template\n      function: is_door_closed_or_timeout\n      data:\n        door_sensor: '{{ states('sensor.door_sensor').state == 'closed' }}'\n        timeout: 120\n```","light_on_door-test_blueprint_inputs","Bad","AssertionError: Blueprint yaml did not contain 'blueprint:' key"
"light_on_door_light_on_door-light_on_door-1","qwen3-1.7b","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\n# Home Assistant Blueprint: Light on door\n\n# Configuration for the automation\nautomation:\n  # Trigger the automation when the door opens\n  - trigger:\n    - platform: sensor\n      sensor:\n        platform: binary_sensor\n        sensor_id: door_sensor\n        value: true\n\n  # Action to turn on the light when the door opens\n  - action:\n    - platform: template\n      function: turn_on_light\n      data:\n        light_switch: '{{ states('light.pantry_light').state == 'on' ? 'light.pantry_light' : 'light.pantry_light' }'\n\n  # Timeout to shut off the light after 2 minutes\n  - action:\n    - platform: template\n      function: turn_off_light\n      data:\n        light_switch: '{{ states('light.pantry_light').state == 'on' ? 'light.pantry_light' : 'light.pantry_light' }}'\n        timeout: 120\n\n  # Conditional to check if the door is open\n  - condition:\n    - platform: template\n      function: is_door_open\n      data:\n        door_sensor: '{{ states('sensor.door_sensor').state == 'open' }}'\n\n  # Conditional to check if the door is closed or after timeout\n  - condition:\n    - platform: template\n      function: is_door_closed_or_timeout\n      data:\n        door_sensor: '{{ states('sensor.door_sensor').state == 'closed' }}'\n        timeout: 120\n```","light_on_door-test_door_open","Bad","AssertionError: Unable to load automation."
"light_on_door_light_on_door-light_on_door-1","qwen3-1.7b","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\n# Home Assistant Blueprint: Light on door\n\n# Configuration for the automation\nautomation:\n  # Trigger the automation when the door opens\n  - trigger:\n    - platform: sensor\n      sensor:\n        platform: binary_sensor\n        sensor_id: door_sensor\n        value: true\n\n  # Action to turn on the light when the door opens\n  - action:\n    - platform: template\n      function: turn_on_light\n      data:\n        light_switch: '{{ states('light.pantry_light').state == 'on' ? 'light.pantry_light' : 'light.pantry_light' }'\n\n  # Timeout to shut off the light after 2 minutes\n  - action:\n    - platform: template\n      function: turn_off_light\n      data:\n        light_switch: '{{ states('light.pantry_light').state == 'on' ? 'light.pantry_light' : 'light.pantry_light' }}'\n        timeout: 120\n\n  # Conditional to check if the door is open\n  - condition:\n    - platform: template\n      function: is_door_open\n      data:\n        door_sensor: '{{ states('sensor.door_sensor').state == 'open' }}'\n\n  # Conditional to check if the door is closed or after timeout\n  - condition:\n    - platform: template\n      function: is_door_closed_or_timeout\n      data:\n        door_sensor: '{{ states('sensor.door_sensor').state == 'closed' }}'\n        timeout: 120\n```","light_on_door-test_door_open_close","Bad","AssertionError: Unable to load automation."
"light_on_door_light_on_door-light_on_door-1","qwen3-1.7b","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\n# Home Assistant Blueprint: Light on door\n\n# Configuration for the automation\nautomation:\n  # Trigger the automation when the door opens\n  - trigger:\n    - platform: sensor\n      sensor:\n        platform: binary_sensor\n        sensor_id: door_sensor\n        value: true\n\n  # Action to turn on the light when the door opens\n  - action:\n    - platform: template\n      function: turn_on_light\n      data:\n        light_switch: '{{ states('light.pantry_light').state == 'on' ? 'light.pantry_light' : 'light.pantry_light' }'\n\n  # Timeout to shut off the light after 2 minutes\n  - action:\n    - platform: template\n      function: turn_off_light\n      data:\n        light_switch: '{{ states('light.pantry_light').state == 'on' ? 'light.pantry_light' : 'light.pantry_light' }}'\n        timeout: 120\n\n  # Conditional to check if the door is open\n  - condition:\n    - platform: template\n      function: is_door_open\n      data:\n        door_sensor: '{{ states('sensor.door_sensor').state == 'open' }}'\n\n  # Conditional to check if the door is closed or after timeout\n  - condition:\n    - platform: template\n      function: is_door_closed_or_timeout\n      data:\n        door_sensor: '{{ states('sensor.door_sensor').state == 'closed' }}'\n        timeout: 120\n```","light_on_door-test_light_timeout","Bad","AssertionError: Unable to load automation."
"light_on_door_light_on_door-light_on_door-2","qwen3-1.7b","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\n## Home Assistant Blueprint: Light on door\n\n## Automation\nautomation:\n  - trigger:\n    - platform: sensor\n      - sensor: door_sensor\n      - value: open\n  - action:\n    - service: light.turn_on\n    - target: [{entity_id: light_switch}]\n    - duration: 2\n    - timeout: 2\n    - delay: 1\n\n## Sensor\nsensor:\n  - platform: binary_sensor\n    - name: door_sensor\n    - entity_id: sensor.door_open\n    - value_template: '{{ states.sensor.door_open.state == 'open' }}'\n\n## Light\nlight:\n  - platform: template\n    - name: pantry_light\n    - entity_id: light.pantry\n    - state_template: 'on'\n    - duration: 2\n    - timeout: 2\n    - delay: 1\n```","light_on_door-test_blueprint_inputs","Bad","^,AssertionError: Blueprint was not valid yaml: while parsing a block mapping   in '<unicode string>', line 6, column 7:         - platform: sensor           ^ expected <block end>, but found '-'   in '<unicode string>', line 7, column 7:           - sensor: door_sensor           ^"
"light_on_door_light_on_door-light_on_door-2","qwen3-1.7b","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\n## Home Assistant Blueprint: Light on door\n\n## Automation\nautomation:\n  - trigger:\n    - platform: sensor\n      - sensor: door_sensor\n      - value: open\n  - action:\n    - service: light.turn_on\n    - target: [{entity_id: light_switch}]\n    - duration: 2\n    - timeout: 2\n    - delay: 1\n\n## Sensor\nsensor:\n  - platform: binary_sensor\n    - name: door_sensor\n    - entity_id: sensor.door_open\n    - value_template: '{{ states.sensor.door_open.state == 'open' }}'\n\n## Light\nlight:\n  - platform: template\n    - name: pantry_light\n    - entity_id: light.pantry\n    - state_template: 'on'\n    - duration: 2\n    - timeout: 2\n    - delay: 1\n```","light_on_door-test_door_open","Bad","AssertionError: Unable to load automation."
"light_on_door_light_on_door-light_on_door-2","qwen3-1.7b","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\n## Home Assistant Blueprint: Light on door\n\n## Automation\nautomation:\n  - trigger:\n    - platform: sensor\n      - sensor: door_sensor\n      - value: open\n  - action:\n    - service: light.turn_on\n    - target: [{entity_id: light_switch}]\n    - duration: 2\n    - timeout: 2\n    - delay: 1\n\n## Sensor\nsensor:\n  - platform: binary_sensor\n    - name: door_sensor\n    - entity_id: sensor.door_open\n    - value_template: '{{ states.sensor.door_open.state == 'open' }}'\n\n## Light\nlight:\n  - platform: template\n    - name: pantry_light\n    - entity_id: light.pantry\n    - state_template: 'on'\n    - duration: 2\n    - timeout: 2\n    - delay: 1\n```","light_on_door-test_door_open_close","Bad","AssertionError: Unable to load automation."
"light_on_door_light_on_door-light_on_door-2","qwen3-1.7b","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\n## Home Assistant Blueprint: Light on door\n\n## Automation\nautomation:\n  - trigger:\n    - platform: sensor\n      - sensor: door_sensor\n      - value: open\n  - action:\n    - service: light.turn_on\n    - target: [{entity_id: light_switch}]\n    - duration: 2\n    - timeout: 2\n    - delay: 1\n\n## Sensor\nsensor:\n  - platform: binary_sensor\n    - name: door_sensor\n    - entity_id: sensor.door_open\n    - value_template: '{{ states.sensor.door_open.state == 'open' }}'\n\n## Light\nlight:\n  - platform: template\n    - name: pantry_light\n    - entity_id: light.pantry\n    - state_template: 'on'\n    - duration: 2\n    - timeout: 2\n    - delay: 1\n```","light_on_door-test_light_timeout","Bad","AssertionError: Unable to load automation."
"light_on_door_light_on_door-light_on_door-3","qwen3-1.7b","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\n# Home Assistant Blueprint: Light on door\n\n# Configuration for the automation\nautomation:\n  - trigger:\n    - platform: sensor\n      - sensor: door_sensor\n      - value: open\n  - action:\n    - service: light.turn_on\n    - target: [{ entity_id: light.switch_name }]\n    - duration: 2\n    - delay: 2\n    - timeout: 2\n    - name: 'Turn on light when door opens'\n\n# Configuration for the sensor\nsensor:\n  - platform: binary_sensor\n    - name: 'door_sensor'\n    - entity_id: sensor.door_open\n    - value: open\n```","light_on_door-test_blueprint_inputs","Bad","^,AssertionError: Blueprint was not valid yaml: while parsing a block mapping   in '<unicode string>', line 6, column 7:         - platform: sensor           ^ expected <block end>, but found '-'   in '<unicode string>', line 7, column 7:           - sensor: door_sensor           ^"
"light_on_door_light_on_door-light_on_door-3","qwen3-1.7b","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\n# Home Assistant Blueprint: Light on door\n\n# Configuration for the automation\nautomation:\n  - trigger:\n    - platform: sensor\n      - sensor: door_sensor\n      - value: open\n  - action:\n    - service: light.turn_on\n    - target: [{ entity_id: light.switch_name }]\n    - duration: 2\n    - delay: 2\n    - timeout: 2\n    - name: 'Turn on light when door opens'\n\n# Configuration for the sensor\nsensor:\n  - platform: binary_sensor\n    - name: 'door_sensor'\n    - entity_id: sensor.door_open\n    - value: open\n```","light_on_door-test_door_open","Bad","AssertionError: Unable to load automation."
"light_on_door_light_on_door-light_on_door-3","qwen3-1.7b","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\n# Home Assistant Blueprint: Light on door\n\n# Configuration for the automation\nautomation:\n  - trigger:\n    - platform: sensor\n      - sensor: door_sensor\n      - value: open\n  - action:\n    - service: light.turn_on\n    - target: [{ entity_id: light.switch_name }]\n    - duration: 2\n    - delay: 2\n    - timeout: 2\n    - name: 'Turn on light when door opens'\n\n# Configuration for the sensor\nsensor:\n  - platform: binary_sensor\n    - name: 'door_sensor'\n    - entity_id: sensor.door_open\n    - value: open\n```","light_on_door-test_door_open_close","Bad","AssertionError: Unable to load automation."
"light_on_door_light_on_door-light_on_door-3","qwen3-1.7b","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\n# Home Assistant Blueprint: Light on door\n\n# Configuration for the automation\nautomation:\n  - trigger:\n    - platform: sensor\n      - sensor: door_sensor\n      - value: open\n  - action:\n    - service: light.turn_on\n    - target: [{ entity_id: light.switch_name }]\n    - duration: 2\n    - delay: 2\n    - timeout: 2\n    - name: 'Turn on light when door opens'\n\n# Configuration for the sensor\nsensor:\n  - platform: binary_sensor\n    - name: 'door_sensor'\n    - entity_id: sensor.door_open\n    - value: open\n```","light_on_door-test_light_timeout","Bad","AssertionError: Unable to load automation."
"light_on_door_light_on_door-light_on_door-4","qwen3-1.7b","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\n# Home Assistant Blueprint: Light on door\n\n# Blueprint configuration\nname: 'Light on door'\nversion: 1\ndescription: 'Turns on the light when the door opens and shuts it off after 2 minutes.'\n\n# Inputs\ninputs:\n  door_sensor:\n    type: binary_sensor\n    name: 'Door Sensor'\n    description: 'Trigger the automation when the door opens.'\n  light_switch:\n    type: light\n    name: 'Pantry Light'\n    description: 'The light to turn on when the door opens.'\n\n# Automation\nautomations:\n  - name: 'Turn on light when door opens'\n    description: 'Turn on the light when the door opens.'\n    trigger:\n      - platform: event\n        device: door_sensor\n        event: opened\n    action:\n      - service: light.turn_on\n        data:\n          entity_id: '{{ light_switch.entity_id }}'\n    conditions:\n      - condition: template\n        value: |\n          state.matches.light_switch.state == 'on'\n    duration: 2 minutes\n```","light_on_door-test_blueprint_inputs","Bad","AssertionError: Blueprint yaml did not contain 'blueprint:' key"
"light_on_door_light_on_door-light_on_door-4","qwen3-1.7b","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\n# Home Assistant Blueprint: Light on door\n\n# Blueprint configuration\nname: 'Light on door'\nversion: 1\ndescription: 'Turns on the light when the door opens and shuts it off after 2 minutes.'\n\n# Inputs\ninputs:\n  door_sensor:\n    type: binary_sensor\n    name: 'Door Sensor'\n    description: 'Trigger the automation when the door opens.'\n  light_switch:\n    type: light\n    name: 'Pantry Light'\n    description: 'The light to turn on when the door opens.'\n\n# Automation\nautomations:\n  - name: 'Turn on light when door opens'\n    description: 'Turn on the light when the door opens.'\n    trigger:\n      - platform: event\n        device: door_sensor\n        event: opened\n    action:\n      - service: light.turn_on\n        data:\n          entity_id: '{{ light_switch.entity_id }}'\n    conditions:\n      - condition: template\n        value: |\n          state.matches.light_switch.state == 'on'\n    duration: 2 minutes\n```","light_on_door-test_door_open","Bad","AssertionError: Unable to load automation."
"light_on_door_light_on_door-light_on_door-4","qwen3-1.7b","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\n# Home Assistant Blueprint: Light on door\n\n# Blueprint configuration\nname: 'Light on door'\nversion: 1\ndescription: 'Turns on the light when the door opens and shuts it off after 2 minutes.'\n\n# Inputs\ninputs:\n  door_sensor:\n    type: binary_sensor\n    name: 'Door Sensor'\n    description: 'Trigger the automation when the door opens.'\n  light_switch:\n    type: light\n    name: 'Pantry Light'\n    description: 'The light to turn on when the door opens.'\n\n# Automation\nautomations:\n  - name: 'Turn on light when door opens'\n    description: 'Turn on the light when the door opens.'\n    trigger:\n      - platform: event\n        device: door_sensor\n        event: opened\n    action:\n      - service: light.turn_on\n        data:\n          entity_id: '{{ light_switch.entity_id }}'\n    conditions:\n      - condition: template\n        value: |\n          state.matches.light_switch.state == 'on'\n    duration: 2 minutes\n```","light_on_door-test_door_open_close","Bad","AssertionError: Unable to load automation."
"light_on_door_light_on_door-light_on_door-4","qwen3-1.7b","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\n# Home Assistant Blueprint: Light on door\n\n# Blueprint configuration\nname: 'Light on door'\nversion: 1\ndescription: 'Turns on the light when the door opens and shuts it off after 2 minutes.'\n\n# Inputs\ninputs:\n  door_sensor:\n    type: binary_sensor\n    name: 'Door Sensor'\n    description: 'Trigger the automation when the door opens.'\n  light_switch:\n    type: light\n    name: 'Pantry Light'\n    description: 'The light to turn on when the door opens.'\n\n# Automation\nautomations:\n  - name: 'Turn on light when door opens'\n    description: 'Turn on the light when the door opens.'\n    trigger:\n      - platform: event\n        device: door_sensor\n        event: opened\n    action:\n      - service: light.turn_on\n        data:\n          entity_id: '{{ light_switch.entity_id }}'\n    conditions:\n      - condition: template\n        value: |\n          state.matches.light_switch.state == 'on'\n    duration: 2 minutes\n```","light_on_door-test_light_timeout","Bad","AssertionError: Unable to load automation."
"light_on_door_light_on_door-light_on_door-0","qwen3-4b","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: Light on door\n  description: Turn on a light when the door opens and turn it off when the door closes or after a 2 minute timeout.\n  inputs:\n    door_sensor:\n      friendly_name: Door Sensor\n      description: A binary_sensor that triggers the automation to start.\n    light_switch:\n      friendly_name: Light Switch\n      description: One or more light entity targets to turn on or off when the automation fires.\n  steps:\n    - action: turn_on\n      target: '{{ light_switch }}'\n      data:\n        brightness: 255\n      context:\n        input: door_sensor\n    - action: wait_for_state\n      target: '{{ door_sensor }}'\n      state: 'off'\n      timeout: 120\n      context:\n        input: door_sensor\n    - action: turn_off\n      target: '{{ light_switch }}'\n      context:\n        input: door_sensor\n```","light_on_door-test_blueprint_inputs","Bad","AssertionError"
"light_on_door_light_on_door-light_on_door-0","qwen3-4b","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: Light on door\n  description: Turn on a light when the door opens and turn it off when the door closes or after a 2 minute timeout.\n  inputs:\n    door_sensor:\n      friendly_name: Door Sensor\n      description: A binary_sensor that triggers the automation to start.\n    light_switch:\n      friendly_name: Light Switch\n      description: One or more light entity targets to turn on or off when the automation fires.\n  steps:\n    - action: turn_on\n      target: '{{ light_switch }}'\n      data:\n        brightness: 255\n      context:\n        input: door_sensor\n    - action: wait_for_state\n      target: '{{ door_sensor }}'\n      state: 'off'\n      timeout: 120\n      context:\n        input: door_sensor\n    - action: turn_off\n      target: '{{ light_switch }}'\n      context:\n        input: door_sensor\n```","light_on_door-test_door_open","Bad","AssertionError: Unable to load automation."
"light_on_door_light_on_door-light_on_door-0","qwen3-4b","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: Light on door\n  description: Turn on a light when the door opens and turn it off when the door closes or after a 2 minute timeout.\n  inputs:\n    door_sensor:\n      friendly_name: Door Sensor\n      description: A binary_sensor that triggers the automation to start.\n    light_switch:\n      friendly_name: Light Switch\n      description: One or more light entity targets to turn on or off when the automation fires.\n  steps:\n    - action: turn_on\n      target: '{{ light_switch }}'\n      data:\n        brightness: 255\n      context:\n        input: door_sensor\n    - action: wait_for_state\n      target: '{{ door_sensor }}'\n      state: 'off'\n      timeout: 120\n      context:\n        input: door_sensor\n    - action: turn_off\n      target: '{{ light_switch }}'\n      context:\n        input: door_sensor\n```","light_on_door-test_door_open_close","Bad","AssertionError: Unable to load automation."
"light_on_door_light_on_door-light_on_door-0","qwen3-4b","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: Light on door\n  description: Turn on a light when the door opens and turn it off when the door closes or after a 2 minute timeout.\n  inputs:\n    door_sensor:\n      friendly_name: Door Sensor\n      description: A binary_sensor that triggers the automation to start.\n    light_switch:\n      friendly_name: Light Switch\n      description: One or more light entity targets to turn on or off when the automation fires.\n  steps:\n    - action: turn_on\n      target: '{{ light_switch }}'\n      data:\n        brightness: 255\n      context:\n        input: door_sensor\n    - action: wait_for_state\n      target: '{{ door_sensor }}'\n      state: 'off'\n      timeout: 120\n      context:\n        input: door_sensor\n    - action: turn_off\n      target: '{{ light_switch }}'\n      context:\n        input: door_sensor\n```","light_on_door-test_light_timeout","Bad","AssertionError: Unable to load automation."
"light_on_door_light_on_door-light_on_door-1","qwen3-4b","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: Light on door\n  description: Turn on a light when the door opens and turn it off when the door closes or after a 2 minute timeout.\n  inputs:\n    door_sensor:\n      friendly_name: Door sensor\n      type: binary_sensor\n    light_switch:\n      friendly_name: Light switch\n      type: light\n      multiple: true\n  steps:\n    - id: trigger\n      title: Trigger automation when the door opens\n      initial_state: true\n      action:\n        service: trigger_event\n        data:\n          event: door_open\n    - id: turn_on_light\n      title: Turn on the light\n      action:\n        service: light.turn_on\n        data:\n          entity_id: >\n            {{ light_switch | join(', ') }}\n    - id: wait_for_door_close\n      title: Wait for the door to close\n      action:\n        service: trigger_event\n        data:\n          event: door_close\n    - id: turn_off_light\n      title: Turn off the light\n      action:\n        service: light.turn_off\n        data:\n          entity_id: >\n            {{ light_switch | join(', ') }}\n    - id: timeout\n      title: Turn off the light after 2 minutes if the door hasn't closed\n      action:\n        delay: 120\n        service: light.turn_off\n        data:\n          entity_id: >\n            {{ light_switch | join(', ') }}\n```","light_on_door-test_blueprint_inputs","Bad","AssertionError"
"light_on_door_light_on_door-light_on_door-1","qwen3-4b","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: Light on door\n  description: Turn on a light when the door opens and turn it off when the door closes or after a 2 minute timeout.\n  inputs:\n    door_sensor:\n      friendly_name: Door sensor\n      type: binary_sensor\n    light_switch:\n      friendly_name: Light switch\n      type: light\n      multiple: true\n  steps:\n    - id: trigger\n      title: Trigger automation when the door opens\n      initial_state: true\n      action:\n        service: trigger_event\n        data:\n          event: door_open\n    - id: turn_on_light\n      title: Turn on the light\n      action:\n        service: light.turn_on\n        data:\n          entity_id: >\n            {{ light_switch | join(', ') }}\n    - id: wait_for_door_close\n      title: Wait for the door to close\n      action:\n        service: trigger_event\n        data:\n          event: door_close\n    - id: turn_off_light\n      title: Turn off the light\n      action:\n        service: light.turn_off\n        data:\n          entity_id: >\n            {{ light_switch | join(', ') }}\n    - id: timeout\n      title: Turn off the light after 2 minutes if the door hasn't closed\n      action:\n        delay: 120\n        service: light.turn_off\n        data:\n          entity_id: >\n            {{ light_switch | join(', ') }}\n```","light_on_door-test_door_open","Bad","AssertionError: Unable to load automation."
"light_on_door_light_on_door-light_on_door-1","qwen3-4b","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: Light on door\n  description: Turn on a light when the door opens and turn it off when the door closes or after a 2 minute timeout.\n  inputs:\n    door_sensor:\n      friendly_name: Door sensor\n      type: binary_sensor\n    light_switch:\n      friendly_name: Light switch\n      type: light\n      multiple: true\n  steps:\n    - id: trigger\n      title: Trigger automation when the door opens\n      initial_state: true\n      action:\n        service: trigger_event\n        data:\n          event: door_open\n    - id: turn_on_light\n      title: Turn on the light\n      action:\n        service: light.turn_on\n        data:\n          entity_id: >\n            {{ light_switch | join(', ') }}\n    - id: wait_for_door_close\n      title: Wait for the door to close\n      action:\n        service: trigger_event\n        data:\n          event: door_close\n    - id: turn_off_light\n      title: Turn off the light\n      action:\n        service: light.turn_off\n        data:\n          entity_id: >\n            {{ light_switch | join(', ') }}\n    - id: timeout\n      title: Turn off the light after 2 minutes if the door hasn't closed\n      action:\n        delay: 120\n        service: light.turn_off\n        data:\n          entity_id: >\n            {{ light_switch | join(', ') }}\n```","light_on_door-test_door_open_close","Bad","AssertionError: Unable to load automation."
"light_on_door_light_on_door-light_on_door-1","qwen3-4b","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: Light on door\n  description: Turn on a light when the door opens and turn it off when the door closes or after a 2 minute timeout.\n  inputs:\n    door_sensor:\n      friendly_name: Door sensor\n      type: binary_sensor\n    light_switch:\n      friendly_name: Light switch\n      type: light\n      multiple: true\n  steps:\n    - id: trigger\n      title: Trigger automation when the door opens\n      initial_state: true\n      action:\n        service: trigger_event\n        data:\n          event: door_open\n    - id: turn_on_light\n      title: Turn on the light\n      action:\n        service: light.turn_on\n        data:\n          entity_id: >\n            {{ light_switch | join(', ') }}\n    - id: wait_for_door_close\n      title: Wait for the door to close\n      action:\n        service: trigger_event\n        data:\n          event: door_close\n    - id: turn_off_light\n      title: Turn off the light\n      action:\n        service: light.turn_off\n        data:\n          entity_id: >\n            {{ light_switch | join(', ') }}\n    - id: timeout\n      title: Turn off the light after 2 minutes if the door hasn't closed\n      action:\n        delay: 120\n        service: light.turn_off\n        data:\n          entity_id: >\n            {{ light_switch | join(', ') }}\n```","light_on_door-test_light_timeout","Bad","AssertionError: Unable to load automation."
"light_on_door_light_on_door-light_on_door-2","qwen3-4b","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: Light on door\n  description: Turn on a light when the door opens and turn it off when the door closes or after a 2 minute timeout.\n  inputs:\n    door_sensor:\n      friendly_name: Door Sensor\n      type: binary_sensor\n    light_switch:\n      friendly_name: Light Switch\n      type: light\n      multiple: true\n  steps:\n    - id: door_open\n      title: Door Open\n      initial_state: false\n      when:\n        - condition: state\n          entity_id: '{{ inputs.door_sensor }}'\n          from: 'off'\n          to: 'on'\n      then:\n        - service: light.turn_on\n          target:\n            entity_id: '{{ inputs.light_switch }}'\n    - id: door_close\n      title: Door Close\n      initial_state: false\n      when:\n        - condition: state\n          entity_id: '{{ inputs.door_sensor }}'\n          from: 'on'\n          to: 'off'\n      then:\n        - service: light.turn_off\n          target:\n            entity_id: '{{ inputs.light_switch }}'\n    - id: timeout\n      title: Timeout\n      initial_state: false\n      delay: 120\n      when:\n        - condition: state\n          entity_id: '{{ inputs.door_sensor }}'\n          from: 'on'\n          to: 'off'\n      then:\n        - service: light.turn_off\n          target:\n            entity_id: '{{ inputs.light_switch }}'\n```","light_on_door-test_blueprint_inputs","Bad","AssertionError"
"light_on_door_light_on_door-light_on_door-2","qwen3-4b","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: Light on door\n  description: Turn on a light when the door opens and turn it off when the door closes or after a 2 minute timeout.\n  inputs:\n    door_sensor:\n      friendly_name: Door Sensor\n      type: binary_sensor\n    light_switch:\n      friendly_name: Light Switch\n      type: light\n      multiple: true\n  steps:\n    - id: door_open\n      title: Door Open\n      initial_state: false\n      when:\n        - condition: state\n          entity_id: '{{ inputs.door_sensor }}'\n          from: 'off'\n          to: 'on'\n      then:\n        - service: light.turn_on\n          target:\n            entity_id: '{{ inputs.light_switch }}'\n    - id: door_close\n      title: Door Close\n      initial_state: false\n      when:\n        - condition: state\n          entity_id: '{{ inputs.door_sensor }}'\n          from: 'on'\n          to: 'off'\n      then:\n        - service: light.turn_off\n          target:\n            entity_id: '{{ inputs.light_switch }}'\n    - id: timeout\n      title: Timeout\n      initial_state: false\n      delay: 120\n      when:\n        - condition: state\n          entity_id: '{{ inputs.door_sensor }}'\n          from: 'on'\n          to: 'off'\n      then:\n        - service: light.turn_off\n          target:\n            entity_id: '{{ inputs.light_switch }}'\n```","light_on_door-test_door_open","Bad","AssertionError: Unable to load automation."
"light_on_door_light_on_door-light_on_door-2","qwen3-4b","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: Light on door\n  description: Turn on a light when the door opens and turn it off when the door closes or after a 2 minute timeout.\n  inputs:\n    door_sensor:\n      friendly_name: Door Sensor\n      type: binary_sensor\n    light_switch:\n      friendly_name: Light Switch\n      type: light\n      multiple: true\n  steps:\n    - id: door_open\n      title: Door Open\n      initial_state: false\n      when:\n        - condition: state\n          entity_id: '{{ inputs.door_sensor }}'\n          from: 'off'\n          to: 'on'\n      then:\n        - service: light.turn_on\n          target:\n            entity_id: '{{ inputs.light_switch }}'\n    - id: door_close\n      title: Door Close\n      initial_state: false\n      when:\n        - condition: state\n          entity_id: '{{ inputs.door_sensor }}'\n          from: 'on'\n          to: 'off'\n      then:\n        - service: light.turn_off\n          target:\n            entity_id: '{{ inputs.light_switch }}'\n    - id: timeout\n      title: Timeout\n      initial_state: false\n      delay: 120\n      when:\n        - condition: state\n          entity_id: '{{ inputs.door_sensor }}'\n          from: 'on'\n          to: 'off'\n      then:\n        - service: light.turn_off\n          target:\n            entity_id: '{{ inputs.light_switch }}'\n```","light_on_door-test_door_open_close","Bad","AssertionError: Unable to load automation."
"light_on_door_light_on_door-light_on_door-2","qwen3-4b","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: Light on door\n  description: Turn on a light when the door opens and turn it off when the door closes or after a 2 minute timeout.\n  inputs:\n    door_sensor:\n      friendly_name: Door Sensor\n      type: binary_sensor\n    light_switch:\n      friendly_name: Light Switch\n      type: light\n      multiple: true\n  steps:\n    - id: door_open\n      title: Door Open\n      initial_state: false\n      when:\n        - condition: state\n          entity_id: '{{ inputs.door_sensor }}'\n          from: 'off'\n          to: 'on'\n      then:\n        - service: light.turn_on\n          target:\n            entity_id: '{{ inputs.light_switch }}'\n    - id: door_close\n      title: Door Close\n      initial_state: false\n      when:\n        - condition: state\n          entity_id: '{{ inputs.door_sensor }}'\n          from: 'on'\n          to: 'off'\n      then:\n        - service: light.turn_off\n          target:\n            entity_id: '{{ inputs.light_switch }}'\n    - id: timeout\n      title: Timeout\n      initial_state: false\n      delay: 120\n      when:\n        - condition: state\n          entity_id: '{{ inputs.door_sensor }}'\n          from: 'on'\n          to: 'off'\n      then:\n        - service: light.turn_off\n          target:\n            entity_id: '{{ inputs.light_switch }}'\n```","light_on_door-test_light_timeout","Bad","AssertionError: Unable to load automation."
"light_on_door_light_on_door-light_on_door-3","qwen3-4b","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: Light on door\n  description: An automation to turn on a light when the door opens.\n  inputs:\n    door_sensor:\n      friendly_name: Door sensor\n      type: binary_sensor\n    light_switch:\n      friendly_name: Light switch\n      type: light\n      multiple: true\n  steps:\n    - title: Turn on the light\n      action: switch\n      target_type: entity\n      target: '{{ input.light_switch }}'\n      data:\n        entity_id: '{{ input.light_switch }}'\n        brightness: 255\n        transition: 0.5\n    - title: Wait for door to close or timeout\n      action: wait\n      target_type: none\n      target: '{{ input.door_sensor }}'\n      data:\n        timeout: 120\n    - title: Turn off the light\n      action: switch\n      target_type: entity\n      target: '{{ input.light_switch }}'\n      data:\n        entity_id: '{{ input.light_switch }}'\n        brightness: 0\n        transition: 0.5\n```","light_on_door-test_blueprint_inputs","Bad","AssertionError"
"light_on_door_light_on_door-light_on_door-3","qwen3-4b","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: Light on door\n  description: An automation to turn on a light when the door opens.\n  inputs:\n    door_sensor:\n      friendly_name: Door sensor\n      type: binary_sensor\n    light_switch:\n      friendly_name: Light switch\n      type: light\n      multiple: true\n  steps:\n    - title: Turn on the light\n      action: switch\n      target_type: entity\n      target: '{{ input.light_switch }}'\n      data:\n        entity_id: '{{ input.light_switch }}'\n        brightness: 255\n        transition: 0.5\n    - title: Wait for door to close or timeout\n      action: wait\n      target_type: none\n      target: '{{ input.door_sensor }}'\n      data:\n        timeout: 120\n    - title: Turn off the light\n      action: switch\n      target_type: entity\n      target: '{{ input.light_switch }}'\n      data:\n        entity_id: '{{ input.light_switch }}'\n        brightness: 0\n        transition: 0.5\n```","light_on_door-test_door_open","Bad","AssertionError: Unable to load automation."
"light_on_door_light_on_door-light_on_door-3","qwen3-4b","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: Light on door\n  description: An automation to turn on a light when the door opens.\n  inputs:\n    door_sensor:\n      friendly_name: Door sensor\n      type: binary_sensor\n    light_switch:\n      friendly_name: Light switch\n      type: light\n      multiple: true\n  steps:\n    - title: Turn on the light\n      action: switch\n      target_type: entity\n      target: '{{ input.light_switch }}'\n      data:\n        entity_id: '{{ input.light_switch }}'\n        brightness: 255\n        transition: 0.5\n    - title: Wait for door to close or timeout\n      action: wait\n      target_type: none\n      target: '{{ input.door_sensor }}'\n      data:\n        timeout: 120\n    - title: Turn off the light\n      action: switch\n      target_type: entity\n      target: '{{ input.light_switch }}'\n      data:\n        entity_id: '{{ input.light_switch }}'\n        brightness: 0\n        transition: 0.5\n```","light_on_door-test_door_open_close","Bad","AssertionError: Unable to load automation."
"light_on_door_light_on_door-light_on_door-3","qwen3-4b","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: Light on door\n  description: An automation to turn on a light when the door opens.\n  inputs:\n    door_sensor:\n      friendly_name: Door sensor\n      type: binary_sensor\n    light_switch:\n      friendly_name: Light switch\n      type: light\n      multiple: true\n  steps:\n    - title: Turn on the light\n      action: switch\n      target_type: entity\n      target: '{{ input.light_switch }}'\n      data:\n        entity_id: '{{ input.light_switch }}'\n        brightness: 255\n        transition: 0.5\n    - title: Wait for door to close or timeout\n      action: wait\n      target_type: none\n      target: '{{ input.door_sensor }}'\n      data:\n        timeout: 120\n    - title: Turn off the light\n      action: switch\n      target_type: entity\n      target: '{{ input.light_switch }}'\n      data:\n        entity_id: '{{ input.light_switch }}'\n        brightness: 0\n        transition: 0.5\n```","light_on_door-test_light_timeout","Bad","AssertionError: Unable to load automation."
"light_on_door_light_on_door-light_on_door-4","qwen3-4b","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: Light on door\n  description: Turn on a light when the door opens and turn it off when the door closes or after a 2 minute timeout.\n  inputs:\n    door_sensor:\n      friendly_name: Door Sensor\n      type: binary_sensor\n    light_switch:\n      friendly_name: Light Switch\n      type: light\n      multiple: true\n  steps:\n    - action: toggle\n      target: '{{ light_switch }}'\n      data:\n        entity_id: '{{ light_switch }}'\n    - action: delay\n      target: '{{ light_switch }}'\n      data:\n        seconds: 120\n    - action: toggle\n      target: '{{ light_switch }}'\n      data:\n        entity_id: '{{ light_switch }}'\n```","light_on_door-test_blueprint_inputs","Bad","AssertionError"
"light_on_door_light_on_door-light_on_door-4","qwen3-4b","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: Light on door\n  description: Turn on a light when the door opens and turn it off when the door closes or after a 2 minute timeout.\n  inputs:\n    door_sensor:\n      friendly_name: Door Sensor\n      type: binary_sensor\n    light_switch:\n      friendly_name: Light Switch\n      type: light\n      multiple: true\n  steps:\n    - action: toggle\n      target: '{{ light_switch }}'\n      data:\n        entity_id: '{{ light_switch }}'\n    - action: delay\n      target: '{{ light_switch }}'\n      data:\n        seconds: 120\n    - action: toggle\n      target: '{{ light_switch }}'\n      data:\n        entity_id: '{{ light_switch }}'\n```","light_on_door-test_door_open","Bad","AssertionError: Unable to load automation."
"light_on_door_light_on_door-light_on_door-4","qwen3-4b","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: Light on door\n  description: Turn on a light when the door opens and turn it off when the door closes or after a 2 minute timeout.\n  inputs:\n    door_sensor:\n      friendly_name: Door Sensor\n      type: binary_sensor\n    light_switch:\n      friendly_name: Light Switch\n      type: light\n      multiple: true\n  steps:\n    - action: toggle\n      target: '{{ light_switch }}'\n      data:\n        entity_id: '{{ light_switch }}'\n    - action: delay\n      target: '{{ light_switch }}'\n      data:\n        seconds: 120\n    - action: toggle\n      target: '{{ light_switch }}'\n      data:\n        entity_id: '{{ light_switch }}'\n```","light_on_door-test_door_open_close","Bad","AssertionError: Unable to load automation."
"light_on_door_light_on_door-light_on_door-4","qwen3-4b","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: Light on door\n  description: Turn on a light when the door opens and turn it off when the door closes or after a 2 minute timeout.\n  inputs:\n    door_sensor:\n      friendly_name: Door Sensor\n      type: binary_sensor\n    light_switch:\n      friendly_name: Light Switch\n      type: light\n      multiple: true\n  steps:\n    - action: toggle\n      target: '{{ light_switch }}'\n      data:\n        entity_id: '{{ light_switch }}'\n    - action: delay\n      target: '{{ light_switch }}'\n      data:\n        seconds: 120\n    - action: toggle\n      target: '{{ light_switch }}'\n      data:\n        entity_id: '{{ light_switch }}'\n```","light_on_door-test_light_timeout","Bad","AssertionError: Unable to load automation."
"light_on_door_light_on_door-light_on_door-0","qwen3-8b","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: light_on_door_open\n  description: Turns on a light when a door opens and turns it off when the door closes or after a 2-minute timeout.\n  input:\n    door_sensor:\n      description: A binary_sensor that triggers the automation to start.\n      type: device\n      required: true\n    light_switch:\n      description: One or more light entity targets to turn on or off when the automation fires.\n      type: device\n      required: true\n  trigger:\n    - platform: state\n      entity_id: !input.door_sensor\n      to: 'on'\n  condition: []\n  action:\n    - service: light.turn_on\n      data:\n        entity_id: !input.light_switch\n  mode: single\n  condition: []\n  automation:\n    - alias: Turn on light when door opens\n      trigger:\n        - platform: state\n          entity_id: !input.door_sensor\n          to: 'on'\n      action:\n        - service: light.turn_on\n          data:\n            entity_id: !input.light_switch\n      mode: single\n    - alias: Turn off light when door closes or after 2 minutes\n      trigger:\n        - platform: state\n          entity_id: !input.door_sensor\n          to: 'off'\n        - platform: timer\n          duration: 00:02:00\n      condition:\n        - condition: state\n          entity_id: !input.door_sensor\n          state: 'on'\n      action:\n        - service: light.turn_off\n          data:\n            entity_id: !input.light_switch\n```","light_on_door-test_blueprint_inputs","Good",""
"light_on_door_light_on_door-light_on_door-0","qwen3-8b","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: light_on_door_open\n  description: Turns on a light when a door opens and turns it off when the door closes or after a 2-minute timeout.\n  input:\n    door_sensor:\n      description: A binary_sensor that triggers the automation to start.\n      type: device\n      required: true\n    light_switch:\n      description: One or more light entity targets to turn on or off when the automation fires.\n      type: device\n      required: true\n  trigger:\n    - platform: state\n      entity_id: !input.door_sensor\n      to: 'on'\n  condition: []\n  action:\n    - service: light.turn_on\n      data:\n        entity_id: !input.light_switch\n  mode: single\n  condition: []\n  automation:\n    - alias: Turn on light when door opens\n      trigger:\n        - platform: state\n          entity_id: !input.door_sensor\n          to: 'on'\n      action:\n        - service: light.turn_on\n          data:\n            entity_id: !input.light_switch\n      mode: single\n    - alias: Turn off light when door closes or after 2 minutes\n      trigger:\n        - platform: state\n          entity_id: !input.door_sensor\n          to: 'off'\n        - platform: timer\n          duration: 00:02:00\n      condition:\n        - condition: state\n          entity_id: !input.door_sensor\n          state: 'on'\n      action:\n        - service: light.turn_off\n          data:\n            entity_id: !input.light_switch\n```","light_on_door-test_door_open","Bad","AssertionError: Unable to load automation."
"light_on_door_light_on_door-light_on_door-0","qwen3-8b","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: light_on_door_open\n  description: Turns on a light when a door opens and turns it off when the door closes or after a 2-minute timeout.\n  input:\n    door_sensor:\n      description: A binary_sensor that triggers the automation to start.\n      type: device\n      required: true\n    light_switch:\n      description: One or more light entity targets to turn on or off when the automation fires.\n      type: device\n      required: true\n  trigger:\n    - platform: state\n      entity_id: !input.door_sensor\n      to: 'on'\n  condition: []\n  action:\n    - service: light.turn_on\n      data:\n        entity_id: !input.light_switch\n  mode: single\n  condition: []\n  automation:\n    - alias: Turn on light when door opens\n      trigger:\n        - platform: state\n          entity_id: !input.door_sensor\n          to: 'on'\n      action:\n        - service: light.turn_on\n          data:\n            entity_id: !input.light_switch\n      mode: single\n    - alias: Turn off light when door closes or after 2 minutes\n      trigger:\n        - platform: state\n          entity_id: !input.door_sensor\n          to: 'off'\n        - platform: timer\n          duration: 00:02:00\n      condition:\n        - condition: state\n          entity_id: !input.door_sensor\n          state: 'on'\n      action:\n        - service: light.turn_off\n          data:\n            entity_id: !input.light_switch\n```","light_on_door-test_door_open_close","Bad","AssertionError: Unable to load automation."
"light_on_door_light_on_door-light_on_door-0","qwen3-8b","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: light_on_door_open\n  description: Turns on a light when a door opens and turns it off when the door closes or after a 2-minute timeout.\n  input:\n    door_sensor:\n      description: A binary_sensor that triggers the automation to start.\n      type: device\n      required: true\n    light_switch:\n      description: One or more light entity targets to turn on or off when the automation fires.\n      type: device\n      required: true\n  trigger:\n    - platform: state\n      entity_id: !input.door_sensor\n      to: 'on'\n  condition: []\n  action:\n    - service: light.turn_on\n      data:\n        entity_id: !input.light_switch\n  mode: single\n  condition: []\n  automation:\n    - alias: Turn on light when door opens\n      trigger:\n        - platform: state\n          entity_id: !input.door_sensor\n          to: 'on'\n      action:\n        - service: light.turn_on\n          data:\n            entity_id: !input.light_switch\n      mode: single\n    - alias: Turn off light when door closes or after 2 minutes\n      trigger:\n        - platform: state\n          entity_id: !input.door_sensor\n          to: 'off'\n        - platform: timer\n          duration: 00:02:00\n      condition:\n        - condition: state\n          entity_id: !input.door_sensor\n          state: 'on'\n      action:\n        - service: light.turn_off\n          data:\n            entity_id: !input.light_switch\n```","light_on_door-test_light_timeout","Bad","AssertionError: Unable to load automation."
"light_on_door_light_on_door-light_on_door-1","qwen3-8b","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: light_on_door_open\n  description: Turn on a light when a door opens and turn it off when the door closes or after a 2-minute timeout.\n  inputs:\n    door_sensor:\n      description: A binary_sensor that triggers the automation to start.\n      default: binary_sensor.door\n      type: entity\n    light_switch:\n      description: One or more light entity targets to turn on or off when the automation fires.\n      default: light.pantry_light\n      type: entity\n  triggers:\n    - platform: state\n      entity_id: '{{ door_sensor }}'\n      to: 'on'\n  actions:\n    - service: light.turn_on\n      data:\n        entity_id: '{{ light_switch }}'\n  mode: single\n  conditions: []\n  constraints: []\n  title: Light on Door Open\n  icon: 'mdi:lightbulb-outline'\n```","light_on_door-test_blueprint_inputs","Bad","AssertionError"
"light_on_door_light_on_door-light_on_door-1","qwen3-8b","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: light_on_door_open\n  description: Turn on a light when a door opens and turn it off when the door closes or after a 2-minute timeout.\n  inputs:\n    door_sensor:\n      description: A binary_sensor that triggers the automation to start.\n      default: binary_sensor.door\n      type: entity\n    light_switch:\n      description: One or more light entity targets to turn on or off when the automation fires.\n      default: light.pantry_light\n      type: entity\n  triggers:\n    - platform: state\n      entity_id: '{{ door_sensor }}'\n      to: 'on'\n  actions:\n    - service: light.turn_on\n      data:\n        entity_id: '{{ light_switch }}'\n  mode: single\n  conditions: []\n  constraints: []\n  title: Light on Door Open\n  icon: 'mdi:lightbulb-outline'\n```","light_on_door-test_door_open","Bad","AssertionError: Unable to load automation."
"light_on_door_light_on_door-light_on_door-1","qwen3-8b","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: light_on_door_open\n  description: Turn on a light when a door opens and turn it off when the door closes or after a 2-minute timeout.\n  inputs:\n    door_sensor:\n      description: A binary_sensor that triggers the automation to start.\n      default: binary_sensor.door\n      type: entity\n    light_switch:\n      description: One or more light entity targets to turn on or off when the automation fires.\n      default: light.pantry_light\n      type: entity\n  triggers:\n    - platform: state\n      entity_id: '{{ door_sensor }}'\n      to: 'on'\n  actions:\n    - service: light.turn_on\n      data:\n        entity_id: '{{ light_switch }}'\n  mode: single\n  conditions: []\n  constraints: []\n  title: Light on Door Open\n  icon: 'mdi:lightbulb-outline'\n```","light_on_door-test_door_open_close","Bad","AssertionError: Unable to load automation."
"light_on_door_light_on_door-light_on_door-1","qwen3-8b","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: light_on_door_open\n  description: Turn on a light when a door opens and turn it off when the door closes or after a 2-minute timeout.\n  inputs:\n    door_sensor:\n      description: A binary_sensor that triggers the automation to start.\n      default: binary_sensor.door\n      type: entity\n    light_switch:\n      description: One or more light entity targets to turn on or off when the automation fires.\n      default: light.pantry_light\n      type: entity\n  triggers:\n    - platform: state\n      entity_id: '{{ door_sensor }}'\n      to: 'on'\n  actions:\n    - service: light.turn_on\n      data:\n        entity_id: '{{ light_switch }}'\n  mode: single\n  conditions: []\n  constraints: []\n  title: Light on Door Open\n  icon: 'mdi:lightbulb-outline'\n```","light_on_door-test_light_timeout","Bad","AssertionError: Unable to load automation."
"light_on_door_light_on_door-light_on_door-2","qwen3-8b","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: light_on_door_open\n  description: Turn on a light when a door opens and turn it off when the door closes or after a 2-minute timeout.\n  inputs:\n    door_sensor:\n      description: A binary_sensor that triggers the automation to start.\n      default: binary_sensor.door\n      type: device\n    light_switch:\n      description: One or more light entity targets to turn on or off when the automation fires.\n      default: light.pantry_light\n      type: device\n  triggers:\n    - platform: state\n      entity_id: !input.door_sensor\n      to: 'on'\n  actions:\n    - service: light.turn_on\n      data:\n        entity_id: !input.light_switch\n  mode: single\n  conditions: []\n  output:\n    light_switch:\n      description: The light entity that was turned on.\n      value: light_switch\n  sensors:\n    light_switch:\n      description: The light entity that was turned on.\n      value: light_switch\n  title: Light on door open\n  icon: 'mdi:lightbulb'\n```","light_on_door-test_blueprint_inputs","Bad","AssertionError"
"light_on_door_light_on_door-light_on_door-2","qwen3-8b","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: light_on_door_open\n  description: Turn on a light when a door opens and turn it off when the door closes or after a 2-minute timeout.\n  inputs:\n    door_sensor:\n      description: A binary_sensor that triggers the automation to start.\n      default: binary_sensor.door\n      type: device\n    light_switch:\n      description: One or more light entity targets to turn on or off when the automation fires.\n      default: light.pantry_light\n      type: device\n  triggers:\n    - platform: state\n      entity_id: !input.door_sensor\n      to: 'on'\n  actions:\n    - service: light.turn_on\n      data:\n        entity_id: !input.light_switch\n  mode: single\n  conditions: []\n  output:\n    light_switch:\n      description: The light entity that was turned on.\n      value: light_switch\n  sensors:\n    light_switch:\n      description: The light entity that was turned on.\n      value: light_switch\n  title: Light on door open\n  icon: 'mdi:lightbulb'\n```","light_on_door-test_door_open","Bad","AssertionError: Unable to load automation."
"light_on_door_light_on_door-light_on_door-2","qwen3-8b","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: light_on_door_open\n  description: Turn on a light when a door opens and turn it off when the door closes or after a 2-minute timeout.\n  inputs:\n    door_sensor:\n      description: A binary_sensor that triggers the automation to start.\n      default: binary_sensor.door\n      type: device\n    light_switch:\n      description: One or more light entity targets to turn on or off when the automation fires.\n      default: light.pantry_light\n      type: device\n  triggers:\n    - platform: state\n      entity_id: !input.door_sensor\n      to: 'on'\n  actions:\n    - service: light.turn_on\n      data:\n        entity_id: !input.light_switch\n  mode: single\n  conditions: []\n  output:\n    light_switch:\n      description: The light entity that was turned on.\n      value: light_switch\n  sensors:\n    light_switch:\n      description: The light entity that was turned on.\n      value: light_switch\n  title: Light on door open\n  icon: 'mdi:lightbulb'\n```","light_on_door-test_door_open_close","Bad","AssertionError: Unable to load automation."
"light_on_door_light_on_door-light_on_door-2","qwen3-8b","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: light_on_door_open\n  description: Turn on a light when a door opens and turn it off when the door closes or after a 2-minute timeout.\n  inputs:\n    door_sensor:\n      description: A binary_sensor that triggers the automation to start.\n      default: binary_sensor.door\n      type: device\n    light_switch:\n      description: One or more light entity targets to turn on or off when the automation fires.\n      default: light.pantry_light\n      type: device\n  triggers:\n    - platform: state\n      entity_id: !input.door_sensor\n      to: 'on'\n  actions:\n    - service: light.turn_on\n      data:\n        entity_id: !input.light_switch\n  mode: single\n  conditions: []\n  output:\n    light_switch:\n      description: The light entity that was turned on.\n      value: light_switch\n  sensors:\n    light_switch:\n      description: The light entity that was turned on.\n      value: light_switch\n  title: Light on door open\n  icon: 'mdi:lightbulb'\n```","light_on_door-test_light_timeout","Bad","AssertionError: Unable to load automation."
"light_on_door_light_on_door-light_on_door-3","qwen3-8b","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: light_on_door_open\n  description: Turn on a light when a door opens and turn it off when the door closes or after a 2-minute timeout.\n  inputs:\n    door_sensor:\n      description: A binary_sensor that triggers the automation to start.\n      type: binary_sensor\n      required: true\n    light_switch:\n      description: One or more light entity targets to turn on or off when the automation fires.\n      type: list\n      required: true\n      entities:\n        - light\n  sensors:\n    door_state:\n      friendly_name: 'Door State'\n      unit_of_measurement: ''\n      value_template: '{{ is_state(door_sensor, 'on') }}'\n  switches:\n    light_switch:\n      friendly_name: 'Light Switch'\n      value_template: '{{ is_state(light_switch, 'on') }}'\n  triggers:\n    - platform: state\n      entity_id: !input.door_sensor\n      to: 'on'\n  actions:\n    - service: light.turn_on\n      data:\n        entity_id: !input.light_switch\n  conditions:\n    - condition: template\n      value_template: '{{ is_state(door_sensor, 'on') }}'\n  modes:\n    - platform: state\n      entity_id: !input.door_sensor\n      to: 'off'\n      for:\n        minutes: 2\n```","light_on_door-test_blueprint_inputs","Bad","AssertionError"
"light_on_door_light_on_door-light_on_door-3","qwen3-8b","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: light_on_door_open\n  description: Turn on a light when a door opens and turn it off when the door closes or after a 2-minute timeout.\n  inputs:\n    door_sensor:\n      description: A binary_sensor that triggers the automation to start.\n      type: binary_sensor\n      required: true\n    light_switch:\n      description: One or more light entity targets to turn on or off when the automation fires.\n      type: list\n      required: true\n      entities:\n        - light\n  sensors:\n    door_state:\n      friendly_name: 'Door State'\n      unit_of_measurement: ''\n      value_template: '{{ is_state(door_sensor, 'on') }}'\n  switches:\n    light_switch:\n      friendly_name: 'Light Switch'\n      value_template: '{{ is_state(light_switch, 'on') }}'\n  triggers:\n    - platform: state\n      entity_id: !input.door_sensor\n      to: 'on'\n  actions:\n    - service: light.turn_on\n      data:\n        entity_id: !input.light_switch\n  conditions:\n    - condition: template\n      value_template: '{{ is_state(door_sensor, 'on') }}'\n  modes:\n    - platform: state\n      entity_id: !input.door_sensor\n      to: 'off'\n      for:\n        minutes: 2\n```","light_on_door-test_door_open","Bad","AssertionError: Unable to load automation."
"light_on_door_light_on_door-light_on_door-3","qwen3-8b","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: light_on_door_open\n  description: Turn on a light when a door opens and turn it off when the door closes or after a 2-minute timeout.\n  inputs:\n    door_sensor:\n      description: A binary_sensor that triggers the automation to start.\n      type: binary_sensor\n      required: true\n    light_switch:\n      description: One or more light entity targets to turn on or off when the automation fires.\n      type: list\n      required: true\n      entities:\n        - light\n  sensors:\n    door_state:\n      friendly_name: 'Door State'\n      unit_of_measurement: ''\n      value_template: '{{ is_state(door_sensor, 'on') }}'\n  switches:\n    light_switch:\n      friendly_name: 'Light Switch'\n      value_template: '{{ is_state(light_switch, 'on') }}'\n  triggers:\n    - platform: state\n      entity_id: !input.door_sensor\n      to: 'on'\n  actions:\n    - service: light.turn_on\n      data:\n        entity_id: !input.light_switch\n  conditions:\n    - condition: template\n      value_template: '{{ is_state(door_sensor, 'on') }}'\n  modes:\n    - platform: state\n      entity_id: !input.door_sensor\n      to: 'off'\n      for:\n        minutes: 2\n```","light_on_door-test_door_open_close","Bad","AssertionError: Unable to load automation."
"light_on_door_light_on_door-light_on_door-3","qwen3-8b","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: light_on_door_open\n  description: Turn on a light when a door opens and turn it off when the door closes or after a 2-minute timeout.\n  inputs:\n    door_sensor:\n      description: A binary_sensor that triggers the automation to start.\n      type: binary_sensor\n      required: true\n    light_switch:\n      description: One or more light entity targets to turn on or off when the automation fires.\n      type: list\n      required: true\n      entities:\n        - light\n  sensors:\n    door_state:\n      friendly_name: 'Door State'\n      unit_of_measurement: ''\n      value_template: '{{ is_state(door_sensor, 'on') }}'\n  switches:\n    light_switch:\n      friendly_name: 'Light Switch'\n      value_template: '{{ is_state(light_switch, 'on') }}'\n  triggers:\n    - platform: state\n      entity_id: !input.door_sensor\n      to: 'on'\n  actions:\n    - service: light.turn_on\n      data:\n        entity_id: !input.light_switch\n  conditions:\n    - condition: template\n      value_template: '{{ is_state(door_sensor, 'on') }}'\n  modes:\n    - platform: state\n      entity_id: !input.door_sensor\n      to: 'off'\n      for:\n        minutes: 2\n```","light_on_door-test_light_timeout","Bad","AssertionError: Unable to load automation."
"light_on_door_light_on_door-light_on_door-4","qwen3-8b","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: light_on_door_open\n  description: Turn on a light when a door opens and turn it off when the door closes or after a 2-minute timeout.\n  inputs:\n    door_sensor:\n      description: A binary sensor that triggers the automation when the door opens.\n      type: binary_sensor\n    light_switch:\n      description: One or more light entities to turn on or off when the automation fires.\n      type: light\n      required: true\n  automation:\n    - alias: Turn on light when door opens\n      trigger:\n        - platform: state\n          entity_id: !input.door_sensor\n          to: 'on'\n      action:\n        - device_trait:\n            - light\n            - turn_on\n          data:\n            entity_id: !input.light_switch\n    - alias: Turn off light when door closes or after 2-minute timeout\n      trigger:\n        - platform: state\n          entity_id: !input.door_sensor\n          to: 'off'\n        - platform: timer\n          duration: 00:02:00\n      condition: []\n      action:\n        - device_trait:\n            - light\n            - turn_off\n          data:\n            entity_id: !input.light_switch\n```","light_on_door-test_blueprint_inputs","Bad","AssertionError"
"light_on_door_light_on_door-light_on_door-4","qwen3-8b","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: light_on_door_open\n  description: Turn on a light when a door opens and turn it off when the door closes or after a 2-minute timeout.\n  inputs:\n    door_sensor:\n      description: A binary sensor that triggers the automation when the door opens.\n      type: binary_sensor\n    light_switch:\n      description: One or more light entities to turn on or off when the automation fires.\n      type: light\n      required: true\n  automation:\n    - alias: Turn on light when door opens\n      trigger:\n        - platform: state\n          entity_id: !input.door_sensor\n          to: 'on'\n      action:\n        - device_trait:\n            - light\n            - turn_on\n          data:\n            entity_id: !input.light_switch\n    - alias: Turn off light when door closes or after 2-minute timeout\n      trigger:\n        - platform: state\n          entity_id: !input.door_sensor\n          to: 'off'\n        - platform: timer\n          duration: 00:02:00\n      condition: []\n      action:\n        - device_trait:\n            - light\n            - turn_off\n          data:\n            entity_id: !input.light_switch\n```","light_on_door-test_door_open","Bad","AssertionError: Unable to load automation."
"light_on_door_light_on_door-light_on_door-4","qwen3-8b","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: light_on_door_open\n  description: Turn on a light when a door opens and turn it off when the door closes or after a 2-minute timeout.\n  inputs:\n    door_sensor:\n      description: A binary sensor that triggers the automation when the door opens.\n      type: binary_sensor\n    light_switch:\n      description: One or more light entities to turn on or off when the automation fires.\n      type: light\n      required: true\n  automation:\n    - alias: Turn on light when door opens\n      trigger:\n        - platform: state\n          entity_id: !input.door_sensor\n          to: 'on'\n      action:\n        - device_trait:\n            - light\n            - turn_on\n          data:\n            entity_id: !input.light_switch\n    - alias: Turn off light when door closes or after 2-minute timeout\n      trigger:\n        - platform: state\n          entity_id: !input.door_sensor\n          to: 'off'\n        - platform: timer\n          duration: 00:02:00\n      condition: []\n      action:\n        - device_trait:\n            - light\n            - turn_off\n          data:\n            entity_id: !input.light_switch\n```","light_on_door-test_door_open_close","Bad","AssertionError: Unable to load automation."
"light_on_door_light_on_door-light_on_door-4","qwen3-8b","light","# Light on door\n\n## Problem statement\n\nCreate an blueprint automation to turn on a light when the door opens.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Turn on the pantry light when the pantry door opens\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input          | Description                                                                     |\n| -------------- | ------------------------------------------------------------------------------- |\n| `door_sensor`  | A `binary_sensor` that triggers the automation to start.                        |\n| `light_switch` | One or more `light` entity targets to turn on or off when the automation fires. |\n\nThe automation should trigger when the door opens, and turn the light on. The\nlight should be shut off when the door closes or after a 2 minute timeout.\n","","```yaml\nblueprint:\n  name: light_on_door_open\n  description: Turn on a light when a door opens and turn it off when the door closes or after a 2-minute timeout.\n  inputs:\n    door_sensor:\n      description: A binary sensor that triggers the automation when the door opens.\n      type: binary_sensor\n    light_switch:\n      description: One or more light entities to turn on or off when the automation fires.\n      type: light\n      required: true\n  automation:\n    - alias: Turn on light when door opens\n      trigger:\n        - platform: state\n          entity_id: !input.door_sensor\n          to: 'on'\n      action:\n        - device_trait:\n            - light\n            - turn_on\n          data:\n            entity_id: !input.light_switch\n    - alias: Turn off light when door closes or after 2-minute timeout\n      trigger:\n        - platform: state\n          entity_id: !input.door_sensor\n          to: 'off'\n        - platform: timer\n          duration: 00:02:00\n      condition: []\n      action:\n        - device_trait:\n            - light\n            - turn_off\n          data:\n            entity_id: !input.light_switch\n```","light_on_door-test_light_timeout","Bad","AssertionError: Unable to load automation."
"vacuum_pause_vacuum_pause-vacuum_pause-0","gemini-2.5-flash","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\nblueprint:\n  name: Vacuum Pause on Phone Call\n  description: Pauses the vacuum when a phone call is detected by a binary sensor.\n  domain: automation\n  input:\n    phone_call_sensor:\n      name: Phone Call Sensor\n      description: A binary sensor that turns 'on' when a phone call is received.\n      selector:\n        entity:\n          domain: binary_sensor\n    vacuum_entity:\n      name: Vacuum Entity\n      description: The vacuum entity to pause.\n      selector:\n        entity:\n          domain: vacuum\n\nmode: single\nmax_exceeded: silent # Prevent multiple triggers from queuing up if calls are frequent\n\ntrigger:\n  - platform: state\n    entity_id: !input phone_call_sensor\n    from: 'off'\n    to: 'on'\n    id: 'phone_call_received'\n\ncondition:\n  - condition: state\n    entity_id: !input vacuum_entity\n    state: 'cleaning' # The vacuum should only be paused if it is actively cleaning\n\naction:\n  - service: vacuum.pause\n    target:\n      entity_id: !input vacuum_entity\n    data: {} # No additional data required for pause service\n  - service: system_log.write\n    data:\n      message: 'Vacuum {{ states(vacuum_entity) }} paused due to phone call detection.'\n      level: info\n      logger: vacuum_pause_blueprint\n```","vacuum_pause-test_blueprint_inputs","Good",""
"vacuum_pause_vacuum_pause-vacuum_pause-0","gemini-2.5-flash","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\nblueprint:\n  name: Vacuum Pause on Phone Call\n  description: Pauses the vacuum when a phone call is detected by a binary sensor.\n  domain: automation\n  input:\n    phone_call_sensor:\n      name: Phone Call Sensor\n      description: A binary sensor that turns 'on' when a phone call is received.\n      selector:\n        entity:\n          domain: binary_sensor\n    vacuum_entity:\n      name: Vacuum Entity\n      description: The vacuum entity to pause.\n      selector:\n        entity:\n          domain: vacuum\n\nmode: single\nmax_exceeded: silent # Prevent multiple triggers from queuing up if calls are frequent\n\ntrigger:\n  - platform: state\n    entity_id: !input phone_call_sensor\n    from: 'off'\n    to: 'on'\n    id: 'phone_call_received'\n\ncondition:\n  - condition: state\n    entity_id: !input vacuum_entity\n    state: 'cleaning' # The vacuum should only be paused if it is actively cleaning\n\naction:\n  - service: vacuum.pause\n    target:\n      entity_id: !input vacuum_entity\n    data: {} # No additional data required for pause service\n  - service: system_log.write\n    data:\n      message: 'Vacuum {{ states(vacuum_entity) }} paused due to phone call detection.'\n      level: info\n      logger: vacuum_pause_blueprint\n```","vacuum_pause-test_vacuum_running_and_paused","Good",""
"vacuum_pause_vacuum_pause-vacuum_pause-0","gemini-2.5-flash","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\nblueprint:\n  name: Vacuum Pause on Phone Call\n  description: Pauses the vacuum when a phone call is detected by a binary sensor.\n  domain: automation\n  input:\n    phone_call_sensor:\n      name: Phone Call Sensor\n      description: A binary sensor that turns 'on' when a phone call is received.\n      selector:\n        entity:\n          domain: binary_sensor\n    vacuum_entity:\n      name: Vacuum Entity\n      description: The vacuum entity to pause.\n      selector:\n        entity:\n          domain: vacuum\n\nmode: single\nmax_exceeded: silent # Prevent multiple triggers from queuing up if calls are frequent\n\ntrigger:\n  - platform: state\n    entity_id: !input phone_call_sensor\n    from: 'off'\n    to: 'on'\n    id: 'phone_call_received'\n\ncondition:\n  - condition: state\n    entity_id: !input vacuum_entity\n    state: 'cleaning' # The vacuum should only be paused if it is actively cleaning\n\naction:\n  - service: vacuum.pause\n    target:\n      entity_id: !input vacuum_entity\n    data: {} # No additional data required for pause service\n  - service: system_log.write\n    data:\n      message: 'Vacuum {{ states(vacuum_entity) }} paused due to phone call detection.'\n      level: info\n      logger: vacuum_pause_blueprint\n```","vacuum_pause-test_vacuum_not_changed_when_idle","Good",""
"vacuum_pause_vacuum_pause-vacuum_pause-1","gemini-2.5-flash","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\nblueprint:\n  name: Vacuum Pause\n  description: Pause the vacuum when a phone call is received, preventing interruption during conversations or meetings.\n  domain: automation\n  source_url: https://github.com/your_github_repo/vacuum_pause.yaml # Optional: Replace with your blueprint's GitHub URL\n\n  input:\n    phone_call_sensor:\n      name: Phone Call Sensor\n      description: A binary sensor that turns 'on' when a phone call is received or active.\n      selector:\n        entity:\n          domain: binary_sensor\n    \n    vacuum_entity:\n      name: Vacuum Entity\n      description: The vacuum entity to be paused when a phone call starts.\n      selector:\n        entity:\n          domain: vacuum\n\ntrigger:\n  - platform: state\n    entity_id: !input phone_call_sensor\n    to: 'on' # Trigger when the phone call sensor turns 'on' (indicating an incoming or active call)\n\ncondition:\n  # Only pause the vacuum if it is currently in a 'cleaning' state.\n  # Common vacuum states for 'running' include 'cleaning'.\n  - condition: state\n    entity_id: !input vacuum_entity\n    state: 'cleaning'\n\naction:\n  # Call the vacuum.pause service on the specified vacuum entity.\n  - service: vacuum.pause\n    target:\n      entity_id: !input vacuum_entity\n\nmode: single\n# 'single' mode ensures that if the binary sensor rapidly flips on/off/on,\n# the automation won't try to execute multiple pause commands concurrently.\n```","vacuum_pause-test_blueprint_inputs","Good",""
"vacuum_pause_vacuum_pause-vacuum_pause-1","gemini-2.5-flash","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\nblueprint:\n  name: Vacuum Pause\n  description: Pause the vacuum when a phone call is received, preventing interruption during conversations or meetings.\n  domain: automation\n  source_url: https://github.com/your_github_repo/vacuum_pause.yaml # Optional: Replace with your blueprint's GitHub URL\n\n  input:\n    phone_call_sensor:\n      name: Phone Call Sensor\n      description: A binary sensor that turns 'on' when a phone call is received or active.\n      selector:\n        entity:\n          domain: binary_sensor\n    \n    vacuum_entity:\n      name: Vacuum Entity\n      description: The vacuum entity to be paused when a phone call starts.\n      selector:\n        entity:\n          domain: vacuum\n\ntrigger:\n  - platform: state\n    entity_id: !input phone_call_sensor\n    to: 'on' # Trigger when the phone call sensor turns 'on' (indicating an incoming or active call)\n\ncondition:\n  # Only pause the vacuum if it is currently in a 'cleaning' state.\n  # Common vacuum states for 'running' include 'cleaning'.\n  - condition: state\n    entity_id: !input vacuum_entity\n    state: 'cleaning'\n\naction:\n  # Call the vacuum.pause service on the specified vacuum entity.\n  - service: vacuum.pause\n    target:\n      entity_id: !input vacuum_entity\n\nmode: single\n# 'single' mode ensures that if the binary sensor rapidly flips on/off/on,\n# the automation won't try to execute multiple pause commands concurrently.\n```","vacuum_pause-test_vacuum_running_and_paused","Good",""
"vacuum_pause_vacuum_pause-vacuum_pause-1","gemini-2.5-flash","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\nblueprint:\n  name: Vacuum Pause\n  description: Pause the vacuum when a phone call is received, preventing interruption during conversations or meetings.\n  domain: automation\n  source_url: https://github.com/your_github_repo/vacuum_pause.yaml # Optional: Replace with your blueprint's GitHub URL\n\n  input:\n    phone_call_sensor:\n      name: Phone Call Sensor\n      description: A binary sensor that turns 'on' when a phone call is received or active.\n      selector:\n        entity:\n          domain: binary_sensor\n    \n    vacuum_entity:\n      name: Vacuum Entity\n      description: The vacuum entity to be paused when a phone call starts.\n      selector:\n        entity:\n          domain: vacuum\n\ntrigger:\n  - platform: state\n    entity_id: !input phone_call_sensor\n    to: 'on' # Trigger when the phone call sensor turns 'on' (indicating an incoming or active call)\n\ncondition:\n  # Only pause the vacuum if it is currently in a 'cleaning' state.\n  # Common vacuum states for 'running' include 'cleaning'.\n  - condition: state\n    entity_id: !input vacuum_entity\n    state: 'cleaning'\n\naction:\n  # Call the vacuum.pause service on the specified vacuum entity.\n  - service: vacuum.pause\n    target:\n      entity_id: !input vacuum_entity\n\nmode: single\n# 'single' mode ensures that if the binary sensor rapidly flips on/off/on,\n# the automation won't try to execute multiple pause commands concurrently.\n```","vacuum_pause-test_vacuum_not_changed_when_idle","Good",""
"vacuum_pause_vacuum_pause-vacuum_pause-2","gemini-2.5-flash","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\nblueprint:\n  name: Vacuum Pause on Phone Call\n  description: Pauses a vacuum cleaner when a specified phone call sensor triggers.\n  domain: automation\n  input:\n    phone_call_sensor:\n      name: Phone Call Sensor\n      description: A binary sensor that turns 'on' when a phone call is received.\n      selector:\n        entity:\n          domain: binary_sensor\n          multiple: false\n      required: true\n    vacuum_entity:\n      name: Vacuum Entity\n      description: The vacuum cleaner entity to pause.\n      selector:\n        entity:\n          domain: vacuum\n          multiple: false\n      required: true\n\nmode: single\nmax_exceeded: silent\n\ntrigger:\n  - platform: state\n    entity_id: !input phone_call_sensor\n    to: 'on'\n    id: phone_call_started\n\ncondition:\n  - condition: template\n    value_template: '{{ is_state_attr(input_vacuum_entity, 'state', 'cleaning') or is_state_attr(input_vacuum_entity, 'state', 'running') }}'\n    # Note: Some vacuum integrations report 'cleaning' while others report 'running'.\n    # It's safer to check for both. If your vacuum uses a different state, adjust here.\n\naction:\n  - service: vacuum.pause\n    target:\n      entity_id: !input vacuum_entity\n  - service: system_log.write\n    data:\n      message: 'Vacuum {{ states(input_vacuum_entity) }} paused due to phone call from {{ states(input_phone_call_sensor) }}'\n      level: info\n      logger: vacuum_pause_blueprint\n```","vacuum_pause-test_blueprint_inputs","Good",""
"vacuum_pause_vacuum_pause-vacuum_pause-2","gemini-2.5-flash","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\nblueprint:\n  name: Vacuum Pause on Phone Call\n  description: Pauses a vacuum cleaner when a specified phone call sensor triggers.\n  domain: automation\n  input:\n    phone_call_sensor:\n      name: Phone Call Sensor\n      description: A binary sensor that turns 'on' when a phone call is received.\n      selector:\n        entity:\n          domain: binary_sensor\n          multiple: false\n      required: true\n    vacuum_entity:\n      name: Vacuum Entity\n      description: The vacuum cleaner entity to pause.\n      selector:\n        entity:\n          domain: vacuum\n          multiple: false\n      required: true\n\nmode: single\nmax_exceeded: silent\n\ntrigger:\n  - platform: state\n    entity_id: !input phone_call_sensor\n    to: 'on'\n    id: phone_call_started\n\ncondition:\n  - condition: template\n    value_template: '{{ is_state_attr(input_vacuum_entity, 'state', 'cleaning') or is_state_attr(input_vacuum_entity, 'state', 'running') }}'\n    # Note: Some vacuum integrations report 'cleaning' while others report 'running'.\n    # It's safer to check for both. If your vacuum uses a different state, adjust here.\n\naction:\n  - service: vacuum.pause\n    target:\n      entity_id: !input vacuum_entity\n  - service: system_log.write\n    data:\n      message: 'Vacuum {{ states(input_vacuum_entity) }} paused due to phone call from {{ states(input_phone_call_sensor) }}'\n      level: info\n      logger: vacuum_pause_blueprint\n```","vacuum_pause-test_vacuum_running_and_paused","Bad","AssertionError: Unable to load automation."
"vacuum_pause_vacuum_pause-vacuum_pause-2","gemini-2.5-flash","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\nblueprint:\n  name: Vacuum Pause on Phone Call\n  description: Pauses a vacuum cleaner when a specified phone call sensor triggers.\n  domain: automation\n  input:\n    phone_call_sensor:\n      name: Phone Call Sensor\n      description: A binary sensor that turns 'on' when a phone call is received.\n      selector:\n        entity:\n          domain: binary_sensor\n          multiple: false\n      required: true\n    vacuum_entity:\n      name: Vacuum Entity\n      description: The vacuum cleaner entity to pause.\n      selector:\n        entity:\n          domain: vacuum\n          multiple: false\n      required: true\n\nmode: single\nmax_exceeded: silent\n\ntrigger:\n  - platform: state\n    entity_id: !input phone_call_sensor\n    to: 'on'\n    id: phone_call_started\n\ncondition:\n  - condition: template\n    value_template: '{{ is_state_attr(input_vacuum_entity, 'state', 'cleaning') or is_state_attr(input_vacuum_entity, 'state', 'running') }}'\n    # Note: Some vacuum integrations report 'cleaning' while others report 'running'.\n    # It's safer to check for both. If your vacuum uses a different state, adjust here.\n\naction:\n  - service: vacuum.pause\n    target:\n      entity_id: !input vacuum_entity\n  - service: system_log.write\n    data:\n      message: 'Vacuum {{ states(input_vacuum_entity) }} paused due to phone call from {{ states(input_phone_call_sensor) }}'\n      level: info\n      logger: vacuum_pause_blueprint\n```","vacuum_pause-test_vacuum_not_changed_when_idle","Bad","AssertionError: Unable to load automation."
"vacuum_pause_vacuum_pause-vacuum_pause-3","gemini-2.5-flash","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\nblueprint:\n  name: Vacuum Pause\n  description: Pause the vacuum when a phone call is received to avoid noise interruption.\n  domain: automation\n  source_url: https://gist.github.com/example/vacuum_pause.yaml # Placeholder, replace with actual URL if hosted\n\n  input:\n    phone_call_sensor:\n      name: Phone Call Sensor\n      description: A binary_sensor entity that turns 'on' when a phone call is received.\n      selector:\n        entity:\n          domain: binary_sensor\n\n    vacuum_entity:\n      name: Vacuum Entity\n      description: The vacuum entity to pause when a phone call is detected.\n      selector:\n        entity:\n          domain: vacuum\n\nmode: single\nmax_exceeded: silent\n\ntrigger:\n  - platform: state\n    entity_id: !input phone_call_sensor\n    to: 'on'\n    id: phone_call_started\n\ncondition:\n  - condition: state\n    entity_id: !input vacuum_entity\n    # Common 'running' states for a vacuum are 'cleaning'.\n    # Some vacuums might also use 'moving' or other states.\n    state: 'cleaning'\n\naction:\n  - service: vacuum.pause\n    target:\n      entity_id: !input vacuum_entity\n  - if:\n      - condition: trigger\n        id: phone_call_started\n    then:\n      - alias: 'Log Automation Trigger'\n        service: system_log.write\n        data:\n          message: 'Vacuum pause automation triggered by {{ states(trigger.entity_id) }} turning {{ trigger.to_state.state }}. Pausing {{ states(vacuum_entity) }}.'\n          level: debug\n\n```","vacuum_pause-test_blueprint_inputs","Good",""
"vacuum_pause_vacuum_pause-vacuum_pause-3","gemini-2.5-flash","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\nblueprint:\n  name: Vacuum Pause\n  description: Pause the vacuum when a phone call is received to avoid noise interruption.\n  domain: automation\n  source_url: https://gist.github.com/example/vacuum_pause.yaml # Placeholder, replace with actual URL if hosted\n\n  input:\n    phone_call_sensor:\n      name: Phone Call Sensor\n      description: A binary_sensor entity that turns 'on' when a phone call is received.\n      selector:\n        entity:\n          domain: binary_sensor\n\n    vacuum_entity:\n      name: Vacuum Entity\n      description: The vacuum entity to pause when a phone call is detected.\n      selector:\n        entity:\n          domain: vacuum\n\nmode: single\nmax_exceeded: silent\n\ntrigger:\n  - platform: state\n    entity_id: !input phone_call_sensor\n    to: 'on'\n    id: phone_call_started\n\ncondition:\n  - condition: state\n    entity_id: !input vacuum_entity\n    # Common 'running' states for a vacuum are 'cleaning'.\n    # Some vacuums might also use 'moving' or other states.\n    state: 'cleaning'\n\naction:\n  - service: vacuum.pause\n    target:\n      entity_id: !input vacuum_entity\n  - if:\n      - condition: trigger\n        id: phone_call_started\n    then:\n      - alias: 'Log Automation Trigger'\n        service: system_log.write\n        data:\n          message: 'Vacuum pause automation triggered by {{ states(trigger.entity_id) }} turning {{ trigger.to_state.state }}. Pausing {{ states(vacuum_entity) }}.'\n          level: debug\n\n```","vacuum_pause-test_vacuum_running_and_paused","Good",""
"vacuum_pause_vacuum_pause-vacuum_pause-3","gemini-2.5-flash","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\nblueprint:\n  name: Vacuum Pause\n  description: Pause the vacuum when a phone call is received to avoid noise interruption.\n  domain: automation\n  source_url: https://gist.github.com/example/vacuum_pause.yaml # Placeholder, replace with actual URL if hosted\n\n  input:\n    phone_call_sensor:\n      name: Phone Call Sensor\n      description: A binary_sensor entity that turns 'on' when a phone call is received.\n      selector:\n        entity:\n          domain: binary_sensor\n\n    vacuum_entity:\n      name: Vacuum Entity\n      description: The vacuum entity to pause when a phone call is detected.\n      selector:\n        entity:\n          domain: vacuum\n\nmode: single\nmax_exceeded: silent\n\ntrigger:\n  - platform: state\n    entity_id: !input phone_call_sensor\n    to: 'on'\n    id: phone_call_started\n\ncondition:\n  - condition: state\n    entity_id: !input vacuum_entity\n    # Common 'running' states for a vacuum are 'cleaning'.\n    # Some vacuums might also use 'moving' or other states.\n    state: 'cleaning'\n\naction:\n  - service: vacuum.pause\n    target:\n      entity_id: !input vacuum_entity\n  - if:\n      - condition: trigger\n        id: phone_call_started\n    then:\n      - alias: 'Log Automation Trigger'\n        service: system_log.write\n        data:\n          message: 'Vacuum pause automation triggered by {{ states(trigger.entity_id) }} turning {{ trigger.to_state.state }}. Pausing {{ states(vacuum_entity) }}.'\n          level: debug\n\n```","vacuum_pause-test_vacuum_not_changed_when_idle","Good",""
"vacuum_pause_vacuum_pause-vacuum_pause-4","gemini-2.5-flash","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\nblueprint:\n  name: Vacuum Pause on Phone Call\n  description: Pauses a vacuum when a phone call is detected by a binary sensor.\n  domain: automation\n  author: Your Name (or leave blank)\n\n  input:\n    phone_call_sensor:\n      name: Phone Call Sensor\n      description: A binary sensor that turns 'on' when a phone call is received.\n      selector:\n        entity:\n          domain: binary_sensor\n          multiple: false\n          \n    vacuum_entity:\n      name: Vacuum Entity\n      description: The vacuum entity to pause.\n      selector:\n        entity:\n          domain: vacuum\n          multiple: false\n\nmode: single\n\ntrigger:\n  - platform: state\n    entity_id: !input phone_call_sensor\n    from: 'off'\n    to: 'on'\n    id: phone_call_started\n\ncondition:\n  # Check if the vacuum is currently cleaning when the phone call starts\n  - condition: state\n    entity_id: !input vacuum_entity\n    state: 'cleaning' # Common state for a vacuum that is actively running.\n\naction:\n  - service: vacuum.pause\n    target:\n      entity_id: !input vacuum_entity\n    metadata: {}\n  - service: persistent_notification.create\n    data:\n      title: Vacuum Paused\n      message: 'Vacuum {{ states(!input vacuum_entity).name }} has been paused because a phone call was detected.'\n      notification_id: vacuum__pause_phone_call_notification\n```","vacuum_pause-test_blueprint_inputs","Good",""
"vacuum_pause_vacuum_pause-vacuum_pause-4","gemini-2.5-flash","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\nblueprint:\n  name: Vacuum Pause on Phone Call\n  description: Pauses a vacuum when a phone call is detected by a binary sensor.\n  domain: automation\n  author: Your Name (or leave blank)\n\n  input:\n    phone_call_sensor:\n      name: Phone Call Sensor\n      description: A binary sensor that turns 'on' when a phone call is received.\n      selector:\n        entity:\n          domain: binary_sensor\n          multiple: false\n          \n    vacuum_entity:\n      name: Vacuum Entity\n      description: The vacuum entity to pause.\n      selector:\n        entity:\n          domain: vacuum\n          multiple: false\n\nmode: single\n\ntrigger:\n  - platform: state\n    entity_id: !input phone_call_sensor\n    from: 'off'\n    to: 'on'\n    id: phone_call_started\n\ncondition:\n  # Check if the vacuum is currently cleaning when the phone call starts\n  - condition: state\n    entity_id: !input vacuum_entity\n    state: 'cleaning' # Common state for a vacuum that is actively running.\n\naction:\n  - service: vacuum.pause\n    target:\n      entity_id: !input vacuum_entity\n    metadata: {}\n  - service: persistent_notification.create\n    data:\n      title: Vacuum Paused\n      message: 'Vacuum {{ states(!input vacuum_entity).name }} has been paused because a phone call was detected.'\n      notification_id: vacuum__pause_phone_call_notification\n```","vacuum_pause-test_vacuum_running_and_paused","Bad","AssertionError: Unable to load automation."
"vacuum_pause_vacuum_pause-vacuum_pause-4","gemini-2.5-flash","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\nblueprint:\n  name: Vacuum Pause on Phone Call\n  description: Pauses a vacuum when a phone call is detected by a binary sensor.\n  domain: automation\n  author: Your Name (or leave blank)\n\n  input:\n    phone_call_sensor:\n      name: Phone Call Sensor\n      description: A binary sensor that turns 'on' when a phone call is received.\n      selector:\n        entity:\n          domain: binary_sensor\n          multiple: false\n          \n    vacuum_entity:\n      name: Vacuum Entity\n      description: The vacuum entity to pause.\n      selector:\n        entity:\n          domain: vacuum\n          multiple: false\n\nmode: single\n\ntrigger:\n  - platform: state\n    entity_id: !input phone_call_sensor\n    from: 'off'\n    to: 'on'\n    id: phone_call_started\n\ncondition:\n  # Check if the vacuum is currently cleaning when the phone call starts\n  - condition: state\n    entity_id: !input vacuum_entity\n    state: 'cleaning' # Common state for a vacuum that is actively running.\n\naction:\n  - service: vacuum.pause\n    target:\n      entity_id: !input vacuum_entity\n    metadata: {}\n  - service: persistent_notification.create\n    data:\n      title: Vacuum Paused\n      message: 'Vacuum {{ states(!input vacuum_entity).name }} has been paused because a phone call was detected.'\n      notification_id: vacuum__pause_phone_call_notification\n```","vacuum_pause-test_vacuum_not_changed_when_idle","Bad","AssertionError: Unable to load automation."
"vacuum_pause_vacuum_pause-vacuum_pause-0","gemini-2.5-flash-lite","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\n# Blueprint for pausing a vacuum during phone calls\nblueprint:\n  name: Vacuum Pause\n  description: Pauses a vacuum robot when a phone call is received.\n  domain: automation\n  input:\n    phone_call_sensor:\n      name: Phone Call Sensor\n      description: A binary sensor that triggers when a phone call is received.\n      selector:\n        entity:\n          domain: binary_sensor\n    vacuum_entity:\n      name: Vacuum Entity\n      description: The vacuum robot entity to control.\n      selector:\n        entity:\n          domain: vacuum\n\n# Define the automation\ntrigger:\n  # Trigger when the phone call sensor turns on (indicating an incoming call)\n  - platform: state\n    entity_id: !input phone_call_sensor\n    to: 'on'\n\ncondition:\n  # Only proceed if the vacuum is currently running\n  - condition: state\n    entity_id: !input vacuum_entity\n    state: 'cleaning' # Assuming 'cleaning' is the state for a running vacuum\n\naction:\n  # Service call to pause the vacuum\n  - service: vacuum.pause\n    target:\n      entity_id: !input vacuum_entity\nmode: single\n```","vacuum_pause-test_blueprint_inputs","Good",""
"vacuum_pause_vacuum_pause-vacuum_pause-0","gemini-2.5-flash-lite","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\n# Blueprint for pausing a vacuum during phone calls\nblueprint:\n  name: Vacuum Pause\n  description: Pauses a vacuum robot when a phone call is received.\n  domain: automation\n  input:\n    phone_call_sensor:\n      name: Phone Call Sensor\n      description: A binary sensor that triggers when a phone call is received.\n      selector:\n        entity:\n          domain: binary_sensor\n    vacuum_entity:\n      name: Vacuum Entity\n      description: The vacuum robot entity to control.\n      selector:\n        entity:\n          domain: vacuum\n\n# Define the automation\ntrigger:\n  # Trigger when the phone call sensor turns on (indicating an incoming call)\n  - platform: state\n    entity_id: !input phone_call_sensor\n    to: 'on'\n\ncondition:\n  # Only proceed if the vacuum is currently running\n  - condition: state\n    entity_id: !input vacuum_entity\n    state: 'cleaning' # Assuming 'cleaning' is the state for a running vacuum\n\naction:\n  # Service call to pause the vacuum\n  - service: vacuum.pause\n    target:\n      entity_id: !input vacuum_entity\nmode: single\n```","vacuum_pause-test_vacuum_running_and_paused","Good",""
"vacuum_pause_vacuum_pause-vacuum_pause-0","gemini-2.5-flash-lite","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\n# Blueprint for pausing a vacuum during phone calls\nblueprint:\n  name: Vacuum Pause\n  description: Pauses a vacuum robot when a phone call is received.\n  domain: automation\n  input:\n    phone_call_sensor:\n      name: Phone Call Sensor\n      description: A binary sensor that triggers when a phone call is received.\n      selector:\n        entity:\n          domain: binary_sensor\n    vacuum_entity:\n      name: Vacuum Entity\n      description: The vacuum robot entity to control.\n      selector:\n        entity:\n          domain: vacuum\n\n# Define the automation\ntrigger:\n  # Trigger when the phone call sensor turns on (indicating an incoming call)\n  - platform: state\n    entity_id: !input phone_call_sensor\n    to: 'on'\n\ncondition:\n  # Only proceed if the vacuum is currently running\n  - condition: state\n    entity_id: !input vacuum_entity\n    state: 'cleaning' # Assuming 'cleaning' is the state for a running vacuum\n\naction:\n  # Service call to pause the vacuum\n  - service: vacuum.pause\n    target:\n      entity_id: !input vacuum_entity\nmode: single\n```","vacuum_pause-test_vacuum_not_changed_when_idle","Good",""
"vacuum_pause_vacuum_pause-vacuum_pause-1","gemini-2.5-flash-lite","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\n# Blueprint for pausing a vacuum during a phone call\nblueprint:\n  name: Vacuum Pause\n  description: Pauses a vacuum cleaner when a phone call is received.\n  domain: automation\n  input:\n    # The binary sensor entity that indicates an incoming phone call.\n    phone_call_sensor:\n      name: Phone Call Sensor\n      description: A binary sensor entity that triggers when a phone call is received.\n      selector:\n        entity:\n          domain: binary_sensor\n    # The vacuum entity that should be paused.\n    vacuum_entity:\n      name: Vacuum Entity\n      description: The vacuum cleaner entity to pause.\n      selector:\n        entity:\n          domain: vacuum\n\n# The automation itself\ntrigger:\n  # Trigger when the phone call sensor changes to 'on' (meaning a call is received).\n  - platform: state\n    entity_id: !input phone_call_sensor\n    to: 'on'\n\ncondition:\n  # Only run the automation if the vacuum is currently running.\n  - condition: state\n    entity_id: !input vacuum_entity\n    state: 'cleaning' # Assuming 'cleaning' is the state for a running vacuum\n\naction:\n  # Call the 'media_player.media_pause' service on the selected vacuum entity.\n  - service: vacuum.pause\n    target:\n      entity_id: !input vacuum_entity\n\nmode: single\n```","vacuum_pause-test_blueprint_inputs","Good",""
"vacuum_pause_vacuum_pause-vacuum_pause-1","gemini-2.5-flash-lite","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\n# Blueprint for pausing a vacuum during a phone call\nblueprint:\n  name: Vacuum Pause\n  description: Pauses a vacuum cleaner when a phone call is received.\n  domain: automation\n  input:\n    # The binary sensor entity that indicates an incoming phone call.\n    phone_call_sensor:\n      name: Phone Call Sensor\n      description: A binary sensor entity that triggers when a phone call is received.\n      selector:\n        entity:\n          domain: binary_sensor\n    # The vacuum entity that should be paused.\n    vacuum_entity:\n      name: Vacuum Entity\n      description: The vacuum cleaner entity to pause.\n      selector:\n        entity:\n          domain: vacuum\n\n# The automation itself\ntrigger:\n  # Trigger when the phone call sensor changes to 'on' (meaning a call is received).\n  - platform: state\n    entity_id: !input phone_call_sensor\n    to: 'on'\n\ncondition:\n  # Only run the automation if the vacuum is currently running.\n  - condition: state\n    entity_id: !input vacuum_entity\n    state: 'cleaning' # Assuming 'cleaning' is the state for a running vacuum\n\naction:\n  # Call the 'media_player.media_pause' service on the selected vacuum entity.\n  - service: vacuum.pause\n    target:\n      entity_id: !input vacuum_entity\n\nmode: single\n```","vacuum_pause-test_vacuum_running_and_paused","Good",""
"vacuum_pause_vacuum_pause-vacuum_pause-1","gemini-2.5-flash-lite","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\n# Blueprint for pausing a vacuum during a phone call\nblueprint:\n  name: Vacuum Pause\n  description: Pauses a vacuum cleaner when a phone call is received.\n  domain: automation\n  input:\n    # The binary sensor entity that indicates an incoming phone call.\n    phone_call_sensor:\n      name: Phone Call Sensor\n      description: A binary sensor entity that triggers when a phone call is received.\n      selector:\n        entity:\n          domain: binary_sensor\n    # The vacuum entity that should be paused.\n    vacuum_entity:\n      name: Vacuum Entity\n      description: The vacuum cleaner entity to pause.\n      selector:\n        entity:\n          domain: vacuum\n\n# The automation itself\ntrigger:\n  # Trigger when the phone call sensor changes to 'on' (meaning a call is received).\n  - platform: state\n    entity_id: !input phone_call_sensor\n    to: 'on'\n\ncondition:\n  # Only run the automation if the vacuum is currently running.\n  - condition: state\n    entity_id: !input vacuum_entity\n    state: 'cleaning' # Assuming 'cleaning' is the state for a running vacuum\n\naction:\n  # Call the 'media_player.media_pause' service on the selected vacuum entity.\n  - service: vacuum.pause\n    target:\n      entity_id: !input vacuum_entity\n\nmode: single\n```","vacuum_pause-test_vacuum_not_changed_when_idle","Good",""
"vacuum_pause_vacuum_pause-vacuum_pause-2","gemini-2.5-flash-lite","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\n# Home Assistant Vacuum Pause Blueprint\n#\n# Trigger vacuum pause when a phone call is received.\n#\n# Example\n#   - alias: Pause Vacuum on Phone Call\n#     description: 'Pauses the vacuum when I receive a phone call.'\n#     trigger:\n#       - platform: blueprint\n#         blueprint: vacuum_pause.yaml\n#         input:\n#           phone_call_sensor: binary_sensor.phone_call\n#           vacuum_entity: vacuum.xiaomi_robot_vacuum\n\nblueprint:\n  name: Vacuum Pause\n  description: Pauses a vacuum when a phone call is received.\n  domain: automation\n  source_url: https://gist.github.com/your_github_username/your_blueprint_repo/blob/main/vacuum_pause.yaml # Replace with your actual URL if you host it\n  input:\n    phone_call_sensor:\n      name: Phone Call Sensor\n      description: 'Select the binary sensor that indicates an incoming phone call.'\n      default: []\n      selector:\n        entity:\n          domain: binary_sensor\n          # Ensure we only allow binary sensors as input\n          # No explicit exclusion needed here as we're only allowing binary_sensor\n    vacuum_entity:\n      name: Vacuum Entity\n      description: 'Select the vacuum cleaner entity to pause.'\n      default: []\n      selector:\n        entity:\n          domain: vacuum\n          # Ensure we only allow vacuum domain entities\n\ntrigger:\n  # Trigger the automation when the phone call sensor changes to 'on' (detects a call)\n  - platform: state\n    entity_id: !input phone_call_sensor\n    to: 'on'\n\ncondition:\n  # Only proceed if the vacuum entity is currently running\n  - condition: state\n    entity_id: !input vacuum_entity\n    state: 'cleaning' # Assuming 'cleaning' is the state for a running vacuum. Adjust if your vacuum uses a different state like 'on' or 'vacuuming'.\n\naction:\n  # Pause the selected vacuum entity\n  - service: vacuum.pause\n    target:\n      entity_id: !input vacuum_entity\n\nmode: single # This ensures that if multiple calls come in quickly, the automation doesn't run multiple times simultaneously.\n```","vacuum_pause-test_blueprint_inputs","Good",""
"vacuum_pause_vacuum_pause-vacuum_pause-2","gemini-2.5-flash-lite","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\n# Home Assistant Vacuum Pause Blueprint\n#\n# Trigger vacuum pause when a phone call is received.\n#\n# Example\n#   - alias: Pause Vacuum on Phone Call\n#     description: 'Pauses the vacuum when I receive a phone call.'\n#     trigger:\n#       - platform: blueprint\n#         blueprint: vacuum_pause.yaml\n#         input:\n#           phone_call_sensor: binary_sensor.phone_call\n#           vacuum_entity: vacuum.xiaomi_robot_vacuum\n\nblueprint:\n  name: Vacuum Pause\n  description: Pauses a vacuum when a phone call is received.\n  domain: automation\n  source_url: https://gist.github.com/your_github_username/your_blueprint_repo/blob/main/vacuum_pause.yaml # Replace with your actual URL if you host it\n  input:\n    phone_call_sensor:\n      name: Phone Call Sensor\n      description: 'Select the binary sensor that indicates an incoming phone call.'\n      default: []\n      selector:\n        entity:\n          domain: binary_sensor\n          # Ensure we only allow binary sensors as input\n          # No explicit exclusion needed here as we're only allowing binary_sensor\n    vacuum_entity:\n      name: Vacuum Entity\n      description: 'Select the vacuum cleaner entity to pause.'\n      default: []\n      selector:\n        entity:\n          domain: vacuum\n          # Ensure we only allow vacuum domain entities\n\ntrigger:\n  # Trigger the automation when the phone call sensor changes to 'on' (detects a call)\n  - platform: state\n    entity_id: !input phone_call_sensor\n    to: 'on'\n\ncondition:\n  # Only proceed if the vacuum entity is currently running\n  - condition: state\n    entity_id: !input vacuum_entity\n    state: 'cleaning' # Assuming 'cleaning' is the state for a running vacuum. Adjust if your vacuum uses a different state like 'on' or 'vacuuming'.\n\naction:\n  # Pause the selected vacuum entity\n  - service: vacuum.pause\n    target:\n      entity_id: !input vacuum_entity\n\nmode: single # This ensures that if multiple calls come in quickly, the automation doesn't run multiple times simultaneously.\n```","vacuum_pause-test_vacuum_running_and_paused","Good",""
"vacuum_pause_vacuum_pause-vacuum_pause-2","gemini-2.5-flash-lite","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\n# Home Assistant Vacuum Pause Blueprint\n#\n# Trigger vacuum pause when a phone call is received.\n#\n# Example\n#   - alias: Pause Vacuum on Phone Call\n#     description: 'Pauses the vacuum when I receive a phone call.'\n#     trigger:\n#       - platform: blueprint\n#         blueprint: vacuum_pause.yaml\n#         input:\n#           phone_call_sensor: binary_sensor.phone_call\n#           vacuum_entity: vacuum.xiaomi_robot_vacuum\n\nblueprint:\n  name: Vacuum Pause\n  description: Pauses a vacuum when a phone call is received.\n  domain: automation\n  source_url: https://gist.github.com/your_github_username/your_blueprint_repo/blob/main/vacuum_pause.yaml # Replace with your actual URL if you host it\n  input:\n    phone_call_sensor:\n      name: Phone Call Sensor\n      description: 'Select the binary sensor that indicates an incoming phone call.'\n      default: []\n      selector:\n        entity:\n          domain: binary_sensor\n          # Ensure we only allow binary sensors as input\n          # No explicit exclusion needed here as we're only allowing binary_sensor\n    vacuum_entity:\n      name: Vacuum Entity\n      description: 'Select the vacuum cleaner entity to pause.'\n      default: []\n      selector:\n        entity:\n          domain: vacuum\n          # Ensure we only allow vacuum domain entities\n\ntrigger:\n  # Trigger the automation when the phone call sensor changes to 'on' (detects a call)\n  - platform: state\n    entity_id: !input phone_call_sensor\n    to: 'on'\n\ncondition:\n  # Only proceed if the vacuum entity is currently running\n  - condition: state\n    entity_id: !input vacuum_entity\n    state: 'cleaning' # Assuming 'cleaning' is the state for a running vacuum. Adjust if your vacuum uses a different state like 'on' or 'vacuuming'.\n\naction:\n  # Pause the selected vacuum entity\n  - service: vacuum.pause\n    target:\n      entity_id: !input vacuum_entity\n\nmode: single # This ensures that if multiple calls come in quickly, the automation doesn't run multiple times simultaneously.\n```","vacuum_pause-test_vacuum_not_changed_when_idle","Good",""
"vacuum_pause_vacuum_pause-vacuum_pause-3","gemini-2.5-flash-lite","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\n# Blueprint for pausing a vacuum cleaner during phone calls\nblueprint:\n  name: Vacuum Pause\n  description: Pauses your vacuum cleaner when a phone call is received.\n  domain: automation\n  input:\n    phone_call_sensor:\n      name: Phone Call Sensor\n      description: A binary sensor entity that triggers when a phone call is received.\n      selector:\n        entity:\n          domain: binary_sensor\n    vacuum_entity:\n      name: Vacuum Entity\n      description: The vacuum cleaner entity to pause.\n      selector:\n        entity:\n          domain: vacuum\n\n# The automation that will be created from this blueprint\ntrigger:\n  # Trigger when the phone call sensor changes to 'on' (indicating a call has started)\n  - platform: state\n    entity_id: !input phone_call_sensor\n    to: 'on'\n\ncondition:\n  # Only run the automation if the vacuum cleaner is currently running\n  - condition: state\n    entity_id: !input vacuum_entity\n    state: 'cleaning' # Assuming 'cleaning' is the state for a running vacuum\n\naction:\n  # Call the 'media_player.media_pause' service to pause the vacuum cleaner\n  - service: vacuum.pause\n    target:\n      entity_id: !input vacuum_entity\n\nmode: single # Ensures the automation doesn't run multiple times concurrently\n```","vacuum_pause-test_blueprint_inputs","Good",""
"vacuum_pause_vacuum_pause-vacuum_pause-3","gemini-2.5-flash-lite","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\n# Blueprint for pausing a vacuum cleaner during phone calls\nblueprint:\n  name: Vacuum Pause\n  description: Pauses your vacuum cleaner when a phone call is received.\n  domain: automation\n  input:\n    phone_call_sensor:\n      name: Phone Call Sensor\n      description: A binary sensor entity that triggers when a phone call is received.\n      selector:\n        entity:\n          domain: binary_sensor\n    vacuum_entity:\n      name: Vacuum Entity\n      description: The vacuum cleaner entity to pause.\n      selector:\n        entity:\n          domain: vacuum\n\n# The automation that will be created from this blueprint\ntrigger:\n  # Trigger when the phone call sensor changes to 'on' (indicating a call has started)\n  - platform: state\n    entity_id: !input phone_call_sensor\n    to: 'on'\n\ncondition:\n  # Only run the automation if the vacuum cleaner is currently running\n  - condition: state\n    entity_id: !input vacuum_entity\n    state: 'cleaning' # Assuming 'cleaning' is the state for a running vacuum\n\naction:\n  # Call the 'media_player.media_pause' service to pause the vacuum cleaner\n  - service: vacuum.pause\n    target:\n      entity_id: !input vacuum_entity\n\nmode: single # Ensures the automation doesn't run multiple times concurrently\n```","vacuum_pause-test_vacuum_running_and_paused","Good",""
"vacuum_pause_vacuum_pause-vacuum_pause-3","gemini-2.5-flash-lite","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\n# Blueprint for pausing a vacuum cleaner during phone calls\nblueprint:\n  name: Vacuum Pause\n  description: Pauses your vacuum cleaner when a phone call is received.\n  domain: automation\n  input:\n    phone_call_sensor:\n      name: Phone Call Sensor\n      description: A binary sensor entity that triggers when a phone call is received.\n      selector:\n        entity:\n          domain: binary_sensor\n    vacuum_entity:\n      name: Vacuum Entity\n      description: The vacuum cleaner entity to pause.\n      selector:\n        entity:\n          domain: vacuum\n\n# The automation that will be created from this blueprint\ntrigger:\n  # Trigger when the phone call sensor changes to 'on' (indicating a call has started)\n  - platform: state\n    entity_id: !input phone_call_sensor\n    to: 'on'\n\ncondition:\n  # Only run the automation if the vacuum cleaner is currently running\n  - condition: state\n    entity_id: !input vacuum_entity\n    state: 'cleaning' # Assuming 'cleaning' is the state for a running vacuum\n\naction:\n  # Call the 'media_player.media_pause' service to pause the vacuum cleaner\n  - service: vacuum.pause\n    target:\n      entity_id: !input vacuum_entity\n\nmode: single # Ensures the automation doesn't run multiple times concurrently\n```","vacuum_pause-test_vacuum_not_changed_when_idle","Good",""
"vacuum_pause_vacuum_pause-vacuum_pause-4","gemini-2.5-flash-lite","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\n# Blueprint for pausing a vacuum cleaner during a phone call.\n# This automation pauses the vacuum when a specific binary sensor (indicating a phone call)\n# becomes 'on'. It also ensures the vacuum is running before attempting to pause it,\n# preventing unnecessary service calls.\n\nblueprint:\n  name: Vacuum Pause on Phone Call\n  description: Pauses your vacuum cleaner when you receive a phone call.\n  domain: automation\n  input:\n    phone_call_sensor:\n      name: Phone Call Sensor\n      description: The binary sensor that triggers when a phone call is received.\n      selector:\n        entity:\n          domain: binary_sensor\n    vacuum_entity:\n      name: Vacuum Entity\n      description: The vacuum cleaner entity to pause.\n      selector:\n        entity:\n          domain: vacuum\n\n# The trigger for this automation is the phone call sensor turning on.\ntrigger:\n  - platform: state\n    entity_id: !input phone_call_sensor\n    to: 'on'\n\n# The action to perform when the trigger condition is met.\naction:\n  # This condition ensures that the vacuum is actually running before attempting to pause it.\n  # This avoids unnecessary service calls if the vacuum is already off or paused.\n  - condition:\n      state: 'cleaning' # or 'returning' if your vacuum indicates it's running in that state\n      entity_id: !input vacuum_entity\n  # If the condition is met, call the 'media_player.pause' service on the vacuum entity.\n  - service: vacuum.pause\n    target:\n      entity_id: !input vacuum_entity\n\n# Metadata for the blueprint, providing information about its purpose.\nmetadata:\n  source: 'blueprint_vacuum_pause_on_phone_call'\n  version: '1.0.0'\n  license: 'Apache License 2.0'\n  # Example usage details for clarity to the user.\n  context:\n    description: 'Pauses the vacuum when a phone call is detected.'\n    domain: vacuum\n    action: pause\n    trigger:\n      platform: state\n      entity_id: !input phone_call_sensor\n      to: 'on'\n    condition:\n      state: 'cleaning'\n      entity_id: !input vacuum_entity\n    service: vacuum.pause\n    service_data:\n      entity_id: !input vacuum_entity\n\n```","vacuum_pause-test_blueprint_inputs","Good",""
"vacuum_pause_vacuum_pause-vacuum_pause-4","gemini-2.5-flash-lite","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\n# Blueprint for pausing a vacuum cleaner during a phone call.\n# This automation pauses the vacuum when a specific binary sensor (indicating a phone call)\n# becomes 'on'. It also ensures the vacuum is running before attempting to pause it,\n# preventing unnecessary service calls.\n\nblueprint:\n  name: Vacuum Pause on Phone Call\n  description: Pauses your vacuum cleaner when you receive a phone call.\n  domain: automation\n  input:\n    phone_call_sensor:\n      name: Phone Call Sensor\n      description: The binary sensor that triggers when a phone call is received.\n      selector:\n        entity:\n          domain: binary_sensor\n    vacuum_entity:\n      name: Vacuum Entity\n      description: The vacuum cleaner entity to pause.\n      selector:\n        entity:\n          domain: vacuum\n\n# The trigger for this automation is the phone call sensor turning on.\ntrigger:\n  - platform: state\n    entity_id: !input phone_call_sensor\n    to: 'on'\n\n# The action to perform when the trigger condition is met.\naction:\n  # This condition ensures that the vacuum is actually running before attempting to pause it.\n  # This avoids unnecessary service calls if the vacuum is already off or paused.\n  - condition:\n      state: 'cleaning' # or 'returning' if your vacuum indicates it's running in that state\n      entity_id: !input vacuum_entity\n  # If the condition is met, call the 'media_player.pause' service on the vacuum entity.\n  - service: vacuum.pause\n    target:\n      entity_id: !input vacuum_entity\n\n# Metadata for the blueprint, providing information about its purpose.\nmetadata:\n  source: 'blueprint_vacuum_pause_on_phone_call'\n  version: '1.0.0'\n  license: 'Apache License 2.0'\n  # Example usage details for clarity to the user.\n  context:\n    description: 'Pauses the vacuum when a phone call is detected.'\n    domain: vacuum\n    action: pause\n    trigger:\n      platform: state\n      entity_id: !input phone_call_sensor\n      to: 'on'\n    condition:\n      state: 'cleaning'\n      entity_id: !input vacuum_entity\n    service: vacuum.pause\n    service_data:\n      entity_id: !input vacuum_entity\n\n```","vacuum_pause-test_vacuum_running_and_paused","Bad","AssertionError: Unable to load automation."
"vacuum_pause_vacuum_pause-vacuum_pause-4","gemini-2.5-flash-lite","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\n# Blueprint for pausing a vacuum cleaner during a phone call.\n# This automation pauses the vacuum when a specific binary sensor (indicating a phone call)\n# becomes 'on'. It also ensures the vacuum is running before attempting to pause it,\n# preventing unnecessary service calls.\n\nblueprint:\n  name: Vacuum Pause on Phone Call\n  description: Pauses your vacuum cleaner when you receive a phone call.\n  domain: automation\n  input:\n    phone_call_sensor:\n      name: Phone Call Sensor\n      description: The binary sensor that triggers when a phone call is received.\n      selector:\n        entity:\n          domain: binary_sensor\n    vacuum_entity:\n      name: Vacuum Entity\n      description: The vacuum cleaner entity to pause.\n      selector:\n        entity:\n          domain: vacuum\n\n# The trigger for this automation is the phone call sensor turning on.\ntrigger:\n  - platform: state\n    entity_id: !input phone_call_sensor\n    to: 'on'\n\n# The action to perform when the trigger condition is met.\naction:\n  # This condition ensures that the vacuum is actually running before attempting to pause it.\n  # This avoids unnecessary service calls if the vacuum is already off or paused.\n  - condition:\n      state: 'cleaning' # or 'returning' if your vacuum indicates it's running in that state\n      entity_id: !input vacuum_entity\n  # If the condition is met, call the 'media_player.pause' service on the vacuum entity.\n  - service: vacuum.pause\n    target:\n      entity_id: !input vacuum_entity\n\n# Metadata for the blueprint, providing information about its purpose.\nmetadata:\n  source: 'blueprint_vacuum_pause_on_phone_call'\n  version: '1.0.0'\n  license: 'Apache License 2.0'\n  # Example usage details for clarity to the user.\n  context:\n    description: 'Pauses the vacuum when a phone call is detected.'\n    domain: vacuum\n    action: pause\n    trigger:\n      platform: state\n      entity_id: !input phone_call_sensor\n      to: 'on'\n    condition:\n      state: 'cleaning'\n      entity_id: !input vacuum_entity\n    service: vacuum.pause\n    service_data:\n      entity_id: !input vacuum_entity\n\n```","vacuum_pause-test_vacuum_not_changed_when_idle","Bad","AssertionError: Unable to load automation."
"vacuum_pause_vacuum_pause-vacuum_pause-0","qwen3-1.7b","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\n## Vacuum Pause Automation\n\n## Overview\nThis automation pauses the vacuum when a phone call is received. It ensures that the vacuum is paused only when a phone call is detected and can be resumed manually.\n\n## Configuration\n\n### Entities\n- `phone_call_sensor`: A `binary_sensor` entity that triggers when a phone call is received.\n- `vacuum_entity`: A `vacuum` entity to pause when the automation fires.\n\n### Automation\n- Trigger: When `phone_call_sensor` is turned on.\n- Condition: When `vacuum_entity` is in a running state.\n- Action: Pause the `vacuum_entity`.\n\n### YAML Configuration\n```yaml\nautomation:\n  - trigger:\n    - platform: sensor\n      - entity_id: sensor.phone_call_sensor\n  - condition:\n    - condition: custom:vacuum_is_running\n      - entity_id: vacuum_entity\n  - action:\n    - service: vacuum.pause\n      - entity_id: vacuum_entity\n```\n```yaml\n```","vacuum_pause-test_blueprint_inputs","Bad","AttributeError: 'NoneType' object has no attribute 'get'"
"vacuum_pause_vacuum_pause-vacuum_pause-0","qwen3-1.7b","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\n## Vacuum Pause Automation\n\n## Overview\nThis automation pauses the vacuum when a phone call is received. It ensures that the vacuum is paused only when a phone call is detected and can be resumed manually.\n\n## Configuration\n\n### Entities\n- `phone_call_sensor`: A `binary_sensor` entity that triggers when a phone call is received.\n- `vacuum_entity`: A `vacuum` entity to pause when the automation fires.\n\n### Automation\n- Trigger: When `phone_call_sensor` is turned on.\n- Condition: When `vacuum_entity` is in a running state.\n- Action: Pause the `vacuum_entity`.\n\n### YAML Configuration\n```yaml\nautomation:\n  - trigger:\n    - platform: sensor\n      - entity_id: sensor.phone_call_sensor\n  - condition:\n    - condition: custom:vacuum_is_running\n      - entity_id: vacuum_entity\n  - action:\n    - service: vacuum.pause\n      - entity_id: vacuum_entity\n```\n```yaml\n```","vacuum_pause-test_vacuum_running_and_paused","Bad","AssertionError: Unable to load automation."
"vacuum_pause_vacuum_pause-vacuum_pause-0","qwen3-1.7b","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\n## Vacuum Pause Automation\n\n## Overview\nThis automation pauses the vacuum when a phone call is received. It ensures that the vacuum is paused only when a phone call is detected and can be resumed manually.\n\n## Configuration\n\n### Entities\n- `phone_call_sensor`: A `binary_sensor` entity that triggers when a phone call is received.\n- `vacuum_entity`: A `vacuum` entity to pause when the automation fires.\n\n### Automation\n- Trigger: When `phone_call_sensor` is turned on.\n- Condition: When `vacuum_entity` is in a running state.\n- Action: Pause the `vacuum_entity`.\n\n### YAML Configuration\n```yaml\nautomation:\n  - trigger:\n    - platform: sensor\n      - entity_id: sensor.phone_call_sensor\n  - condition:\n    - condition: custom:vacuum_is_running\n      - entity_id: vacuum_entity\n  - action:\n    - service: vacuum.pause\n      - entity_id: vacuum_entity\n```\n```yaml\n```","vacuum_pause-test_vacuum_not_changed_when_idle","Bad","AssertionError: Unable to load automation."
"vacuum_pause_vacuum_pause-vacuum_pause-1","qwen3-1.7b","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\n## Vacuum Pause Automation\n\n## Configuration\n\n## Blueprint Automation\nautomation:\n  - trigger:\n    - platform: sensor\n      sensor:\n        platform: binary_sensor\n        entity_id: sensor.phone_call_sensor\n        value: true\n        name: 'Phone Call Received'\n\n  - action:\n    - service: vacuum.pause\n      data:\n        entity_id: '{{ vacuum_entity }}'\n```","vacuum_pause-test_blueprint_inputs","Bad","AssertionError: Blueprint yaml did not contain 'blueprint:' key"
"vacuum_pause_vacuum_pause-vacuum_pause-1","qwen3-1.7b","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\n## Vacuum Pause Automation\n\n## Configuration\n\n## Blueprint Automation\nautomation:\n  - trigger:\n    - platform: sensor\n      sensor:\n        platform: binary_sensor\n        entity_id: sensor.phone_call_sensor\n        value: true\n        name: 'Phone Call Received'\n\n  - action:\n    - service: vacuum.pause\n      data:\n        entity_id: '{{ vacuum_entity }}'\n```","vacuum_pause-test_vacuum_running_and_paused","Bad","AssertionError: Unable to load automation."
"vacuum_pause_vacuum_pause-vacuum_pause-1","qwen3-1.7b","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\n## Vacuum Pause Automation\n\n## Configuration\n\n## Blueprint Automation\nautomation:\n  - trigger:\n    - platform: sensor\n      sensor:\n        platform: binary_sensor\n        entity_id: sensor.phone_call_sensor\n        value: true\n        name: 'Phone Call Received'\n\n  - action:\n    - service: vacuum.pause\n      data:\n        entity_id: '{{ vacuum_entity }}'\n```","vacuum_pause-test_vacuum_not_changed_when_idle","Bad","AssertionError: Unable to load automation."
"vacuum_pause_vacuum_pause-vacuum_pause-2","qwen3-1.7b","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\n## Vacuum Pause Automation\n\n## Overview\nThis automation pauses the vacuum when a phone call is detected, and resumes it manually.\n\n## Configuration\n\n## Sensor\n- A binary sensor to detect phone calls\n- Name: phone_call_sensor\n- Entity: phone_call_sensor\n- State: on = phone call received, off = no phone call\n\n## Automation\n- Trigger: When the phone_call_sensor is turned on\n- Condition: The vacuum is running\n- Action: Pause the vacuum\n\n## Vacuum Entity\n- Name: vacuum_entity\n- Entity: vacuum\n- State: running\n\n## Automation Configuration\n\nautomation:\n  sequence:\n    - trigger:\n        platform: sensor\n        sensor: phone_call_sensor\n    - condition:\n        condition: states.sensor.phone_call_sensor.state == 'on'\n        condition: states.vacuum_entity.state == 'running'\n    - action:\n        service: vacuum.pause\n        target: { entity_id: vacuum_entity }\n        data:\n          pause: true\n```","vacuum_pause-test_blueprint_inputs","Bad","^,AssertionError: Blueprint was not valid yaml: expected '<document start>', but found '<block sequence start>'   in '<unicode string>', line 9, column 1:     - A binary sensor to detect phon ...      ^"
"vacuum_pause_vacuum_pause-vacuum_pause-2","qwen3-1.7b","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\n## Vacuum Pause Automation\n\n## Overview\nThis automation pauses the vacuum when a phone call is detected, and resumes it manually.\n\n## Configuration\n\n## Sensor\n- A binary sensor to detect phone calls\n- Name: phone_call_sensor\n- Entity: phone_call_sensor\n- State: on = phone call received, off = no phone call\n\n## Automation\n- Trigger: When the phone_call_sensor is turned on\n- Condition: The vacuum is running\n- Action: Pause the vacuum\n\n## Vacuum Entity\n- Name: vacuum_entity\n- Entity: vacuum\n- State: running\n\n## Automation Configuration\n\nautomation:\n  sequence:\n    - trigger:\n        platform: sensor\n        sensor: phone_call_sensor\n    - condition:\n        condition: states.sensor.phone_call_sensor.state == 'on'\n        condition: states.vacuum_entity.state == 'running'\n    - action:\n        service: vacuum.pause\n        target: { entity_id: vacuum_entity }\n        data:\n          pause: true\n```","vacuum_pause-test_vacuum_running_and_paused","Bad","AssertionError: Unable to load automation."
"vacuum_pause_vacuum_pause-vacuum_pause-2","qwen3-1.7b","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\n## Vacuum Pause Automation\n\n## Overview\nThis automation pauses the vacuum when a phone call is detected, and resumes it manually.\n\n## Configuration\n\n## Sensor\n- A binary sensor to detect phone calls\n- Name: phone_call_sensor\n- Entity: phone_call_sensor\n- State: on = phone call received, off = no phone call\n\n## Automation\n- Trigger: When the phone_call_sensor is turned on\n- Condition: The vacuum is running\n- Action: Pause the vacuum\n\n## Vacuum Entity\n- Name: vacuum_entity\n- Entity: vacuum\n- State: running\n\n## Automation Configuration\n\nautomation:\n  sequence:\n    - trigger:\n        platform: sensor\n        sensor: phone_call_sensor\n    - condition:\n        condition: states.sensor.phone_call_sensor.state == 'on'\n        condition: states.vacuum_entity.state == 'running'\n    - action:\n        service: vacuum.pause\n        target: { entity_id: vacuum_entity }\n        data:\n          pause: true\n```","vacuum_pause-test_vacuum_not_changed_when_idle","Bad","AssertionError: Unable to load automation."
"vacuum_pause_vacuum_pause-vacuum_pause-3","qwen3-1.7b","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\n## Vacuum Pause Automation\n\n## Overview\nThis automation pauses the vacuum when a phone call is detected, and resumes it manually.\n\n## Configuration\n\nautomation:\n  alias: 'Vacuum Pause on Phone Call'\n  triggers:\n    - platform: sensor\n      sensor:\n        platform: binary_sensor\n        sensor_id: phone_call_sensor\n        value_than: 1\n  actions:\n    - service: vacuum.pause\n      data:\n        entity_id: vacuum_entity\n      then:\n        - service: media_player.play_media\n          data:\n            media_content_type: audio\n            media_content_id: 'vacuum_pauses'\n            media_title: 'Vacuum Paused'\n            media_description: 'Vacuum paused due to phone call'\n\n  # Optional: Resume vacuum manually\n  - service: vacuum.resume\n    data:\n      entity_id: vacuum_entity\n    then:\n      - sensor: phone_call_sensor\n        value_than: 1\n        then:\n          - service: vacuum.pause\n            data:\n              entity_id: vacuum_entity\n```","vacuum_pause-test_blueprint_inputs","Bad","^,AssertionError: Blueprint was not valid yaml: expected '<document start>', but found '<block mapping start>'   in '<unicode string>', line 8, column 1:     automation:     ^"
"vacuum_pause_vacuum_pause-vacuum_pause-3","qwen3-1.7b","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\n## Vacuum Pause Automation\n\n## Overview\nThis automation pauses the vacuum when a phone call is detected, and resumes it manually.\n\n## Configuration\n\nautomation:\n  alias: 'Vacuum Pause on Phone Call'\n  triggers:\n    - platform: sensor\n      sensor:\n        platform: binary_sensor\n        sensor_id: phone_call_sensor\n        value_than: 1\n  actions:\n    - service: vacuum.pause\n      data:\n        entity_id: vacuum_entity\n      then:\n        - service: media_player.play_media\n          data:\n            media_content_type: audio\n            media_content_id: 'vacuum_pauses'\n            media_title: 'Vacuum Paused'\n            media_description: 'Vacuum paused due to phone call'\n\n  # Optional: Resume vacuum manually\n  - service: vacuum.resume\n    data:\n      entity_id: vacuum_entity\n    then:\n      - sensor: phone_call_sensor\n        value_than: 1\n        then:\n          - service: vacuum.pause\n            data:\n              entity_id: vacuum_entity\n```","vacuum_pause-test_vacuum_running_and_paused","Bad","AssertionError: Unable to load automation."
"vacuum_pause_vacuum_pause-vacuum_pause-3","qwen3-1.7b","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\n## Vacuum Pause Automation\n\n## Overview\nThis automation pauses the vacuum when a phone call is detected, and resumes it manually.\n\n## Configuration\n\nautomation:\n  alias: 'Vacuum Pause on Phone Call'\n  triggers:\n    - platform: sensor\n      sensor:\n        platform: binary_sensor\n        sensor_id: phone_call_sensor\n        value_than: 1\n  actions:\n    - service: vacuum.pause\n      data:\n        entity_id: vacuum_entity\n      then:\n        - service: media_player.play_media\n          data:\n            media_content_type: audio\n            media_content_id: 'vacuum_pauses'\n            media_title: 'Vacuum Paused'\n            media_description: 'Vacuum paused due to phone call'\n\n  # Optional: Resume vacuum manually\n  - service: vacuum.resume\n    data:\n      entity_id: vacuum_entity\n    then:\n      - sensor: phone_call_sensor\n        value_than: 1\n        then:\n          - service: vacuum.pause\n            data:\n              entity_id: vacuum_entity\n```","vacuum_pause-test_vacuum_not_changed_when_idle","Bad","AssertionError: Unable to load automation."
"vacuum_pause_vacuum_pause-vacuum_pause-4","qwen3-1.7b","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\n## Vacuum Pause Automation\n\n## Overview\nThis automation pauses the vacuum when a phone call is detected, and resumes it manually.\n\n## Configuration\n\n## Automation\nautomation:\n  sequence:\n    - trigger:\n        platform: sensor\n        entity_id: sensors.phone_call_sensor\n    - action:\n        service: vacuum.pause\n        entity_id: vacuum_entity\n\n## Entities\n\n## Binary Sensor\nbinary_sensor:\n  entity_id: sensors.phone_call_sensor\n  name: 'Phone Call Detected'\n  friendly_name: 'Phone Call Sensor'\n  icon: 'mdi:phone'\n\n## Vacuum Entity\nvacuum:\n  entity_id: vacuum_1\n  name: 'Vacuum'\n  friendly_name: 'Vacuum'\n  icon: 'mdi:air-purifier'\n  state: 'running'\n  command: 'start'\n```","vacuum_pause-test_blueprint_inputs","Bad","^,AssertionError: Blueprint was not valid yaml: expected '<document start>', but found '<block mapping start>'   in '<unicode string>', line 9, column 1:     automation:     ^"
"vacuum_pause_vacuum_pause-vacuum_pause-4","qwen3-1.7b","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\n## Vacuum Pause Automation\n\n## Overview\nThis automation pauses the vacuum when a phone call is detected, and resumes it manually.\n\n## Configuration\n\n## Automation\nautomation:\n  sequence:\n    - trigger:\n        platform: sensor\n        entity_id: sensors.phone_call_sensor\n    - action:\n        service: vacuum.pause\n        entity_id: vacuum_entity\n\n## Entities\n\n## Binary Sensor\nbinary_sensor:\n  entity_id: sensors.phone_call_sensor\n  name: 'Phone Call Detected'\n  friendly_name: 'Phone Call Sensor'\n  icon: 'mdi:phone'\n\n## Vacuum Entity\nvacuum:\n  entity_id: vacuum_1\n  name: 'Vacuum'\n  friendly_name: 'Vacuum'\n  icon: 'mdi:air-purifier'\n  state: 'running'\n  command: 'start'\n```","vacuum_pause-test_vacuum_running_and_paused","Bad","AssertionError: Unable to load automation."
"vacuum_pause_vacuum_pause-vacuum_pause-4","qwen3-1.7b","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\n## Vacuum Pause Automation\n\n## Overview\nThis automation pauses the vacuum when a phone call is detected, and resumes it manually.\n\n## Configuration\n\n## Automation\nautomation:\n  sequence:\n    - trigger:\n        platform: sensor\n        entity_id: sensors.phone_call_sensor\n    - action:\n        service: vacuum.pause\n        entity_id: vacuum_entity\n\n## Entities\n\n## Binary Sensor\nbinary_sensor:\n  entity_id: sensors.phone_call_sensor\n  name: 'Phone Call Detected'\n  friendly_name: 'Phone Call Sensor'\n  icon: 'mdi:phone'\n\n## Vacuum Entity\nvacuum:\n  entity_id: vacuum_1\n  name: 'Vacuum'\n  friendly_name: 'Vacuum'\n  icon: 'mdi:air-purifier'\n  state: 'running'\n  command: 'start'\n```","vacuum_pause-test_vacuum_not_changed_when_idle","Bad","AssertionError: Unable to load automation."
"vacuum_pause_vacuum_pause-vacuum_pause-0","qwen3-4b","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\nblueprint:\n  name: Vacuum Pause\n  description: Pause the vacuum when a phone call is received.\n  inputs:\n    phone_call_sensor:\n      friendly_name: Phone Call Sensor\n      type: binary_sensor\n    vacuum_entity:\n      friendly_name: Vacuum Entity\n      type: vacuum\n  steps:\n    - step: Check if the phone call sensor is triggered and the vacuum is running\n      condition:\n        - entity: {{ inputs.phone_call_sensor }}\n          state: 'on'\n        - entity: {{ inputs.vacuum_entity }}\n          state: 'running'\n      action:\n        - service: vacuum.pause\n          target:\n            entity_id: {{ inputs.vacuum_entity }}\n```","vacuum_pause-test_blueprint_inputs","Bad","^,AssertionError: Blueprint was not valid yaml: while constructing a mapping   in '<unicode string>', line 14, column 19:             - entity: {{ inputs.phone_call_sensor }}                       ^ found unhashable key   in '<unicode string>', line 14, column 20:             - entity: {{ inputs.phone_call_sensor }}                        ^"
"vacuum_pause_vacuum_pause-vacuum_pause-0","qwen3-4b","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\nblueprint:\n  name: Vacuum Pause\n  description: Pause the vacuum when a phone call is received.\n  inputs:\n    phone_call_sensor:\n      friendly_name: Phone Call Sensor\n      type: binary_sensor\n    vacuum_entity:\n      friendly_name: Vacuum Entity\n      type: vacuum\n  steps:\n    - step: Check if the phone call sensor is triggered and the vacuum is running\n      condition:\n        - entity: {{ inputs.phone_call_sensor }}\n          state: 'on'\n        - entity: {{ inputs.vacuum_entity }}\n          state: 'running'\n      action:\n        - service: vacuum.pause\n          target:\n            entity_id: {{ inputs.vacuum_entity }}\n```","vacuum_pause-test_vacuum_running_and_paused","Bad","AssertionError: Unable to load automation."
"vacuum_pause_vacuum_pause-vacuum_pause-0","qwen3-4b","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\nblueprint:\n  name: Vacuum Pause\n  description: Pause the vacuum when a phone call is received.\n  inputs:\n    phone_call_sensor:\n      friendly_name: Phone Call Sensor\n      type: binary_sensor\n    vacuum_entity:\n      friendly_name: Vacuum Entity\n      type: vacuum\n  steps:\n    - step: Check if the phone call sensor is triggered and the vacuum is running\n      condition:\n        - entity: {{ inputs.phone_call_sensor }}\n          state: 'on'\n        - entity: {{ inputs.vacuum_entity }}\n          state: 'running'\n      action:\n        - service: vacuum.pause\n          target:\n            entity_id: {{ inputs.vacuum_entity }}\n```","vacuum_pause-test_vacuum_not_changed_when_idle","Bad","AssertionError: Unable to load automation."
"vacuum_pause_vacuum_pause-vacuum_pause-1","qwen3-4b","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\nblueprint:\n  name: Vacuum Pause\n  description: Pause the vacuum when a phone call is received.\n  inputs:\n    phone_call_sensor:\n      friendly_name: Phone Call Sensor\n      type: binary_sensor\n    vacuum_entity:\n      friendly_name: Vacuum Entity\n      type: vacuum\n  steps:\n    - alias: Check if vacuum is running\n      condition: state\n      entity: input_boolean.vacuum_running\n      value: 'on'\n    - alias: Pause the vacuum\n      service: vacuum.pause\n      target:\n        entity: {{ inputs.vacuum_entity }}\n```","vacuum_pause-test_blueprint_inputs","Bad","^,AssertionError: Blueprint was not valid yaml: while constructing a mapping   in '<unicode string>', line 19, column 17:             entity: {{ inputs.vacuum_entity }}                     ^ found unhashable key   in '<unicode string>', line 19, column 18:             entity: {{ inputs.vacuum_entity }}                      ^"
"vacuum_pause_vacuum_pause-vacuum_pause-1","qwen3-4b","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\nblueprint:\n  name: Vacuum Pause\n  description: Pause the vacuum when a phone call is received.\n  inputs:\n    phone_call_sensor:\n      friendly_name: Phone Call Sensor\n      type: binary_sensor\n    vacuum_entity:\n      friendly_name: Vacuum Entity\n      type: vacuum\n  steps:\n    - alias: Check if vacuum is running\n      condition: state\n      entity: input_boolean.vacuum_running\n      value: 'on'\n    - alias: Pause the vacuum\n      service: vacuum.pause\n      target:\n        entity: {{ inputs.vacuum_entity }}\n```","vacuum_pause-test_vacuum_running_and_paused","Bad","AssertionError: Unable to load automation."
"vacuum_pause_vacuum_pause-vacuum_pause-1","qwen3-4b","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\nblueprint:\n  name: Vacuum Pause\n  description: Pause the vacuum when a phone call is received.\n  inputs:\n    phone_call_sensor:\n      friendly_name: Phone Call Sensor\n      type: binary_sensor\n    vacuum_entity:\n      friendly_name: Vacuum Entity\n      type: vacuum\n  steps:\n    - alias: Check if vacuum is running\n      condition: state\n      entity: input_boolean.vacuum_running\n      value: 'on'\n    - alias: Pause the vacuum\n      service: vacuum.pause\n      target:\n        entity: {{ inputs.vacuum_entity }}\n```","vacuum_pause-test_vacuum_not_changed_when_idle","Bad","AssertionError: Unable to load automation."
"vacuum_pause_vacuum_pause-vacuum_pause-2","qwen3-4b","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\nblueprint:\n  name: Vacuum Pause\n  description: Pause the vacuum when a phone call is received.\n  inputs:\n    phone_call_sensor:\n      friendly_name: Phone Call Sensor\n      type: binary_sensor\n    vacuum_entity:\n      friendly_name: Vacuum Entity\n      type: vacuum\n  steps:\n    - alias: Check if vacuum is running\n      condition: state\n      value_template: '{{ is_state('vacuum', 'running') }}'\n      then:\n        - alias: Pause the vacuum\n          service: vacuum.start\n          data:\n            entity_id: '{{ inputs.vacuum_entity }}'\n```","vacuum_pause-test_blueprint_inputs","Bad","AssertionError"
"vacuum_pause_vacuum_pause-vacuum_pause-2","qwen3-4b","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\nblueprint:\n  name: Vacuum Pause\n  description: Pause the vacuum when a phone call is received.\n  inputs:\n    phone_call_sensor:\n      friendly_name: Phone Call Sensor\n      type: binary_sensor\n    vacuum_entity:\n      friendly_name: Vacuum Entity\n      type: vacuum\n  steps:\n    - alias: Check if vacuum is running\n      condition: state\n      value_template: '{{ is_state('vacuum', 'running') }}'\n      then:\n        - alias: Pause the vacuum\n          service: vacuum.start\n          data:\n            entity_id: '{{ inputs.vacuum_entity }}'\n```","vacuum_pause-test_vacuum_running_and_paused","Bad","AssertionError: Unable to load automation."
"vacuum_pause_vacuum_pause-vacuum_pause-2","qwen3-4b","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\nblueprint:\n  name: Vacuum Pause\n  description: Pause the vacuum when a phone call is received.\n  inputs:\n    phone_call_sensor:\n      friendly_name: Phone Call Sensor\n      type: binary_sensor\n    vacuum_entity:\n      friendly_name: Vacuum Entity\n      type: vacuum\n  steps:\n    - alias: Check if vacuum is running\n      condition: state\n      value_template: '{{ is_state('vacuum', 'running') }}'\n      then:\n        - alias: Pause the vacuum\n          service: vacuum.start\n          data:\n            entity_id: '{{ inputs.vacuum_entity }}'\n```","vacuum_pause-test_vacuum_not_changed_when_idle","Bad","AssertionError: Unable to load automation."
"vacuum_pause_vacuum_pause-vacuum_pause-3","qwen3-4b","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\nblueprint:\n  name: Vacuum Pause\n  description: Pause the vacuum when a phone call is received.\n  inputs:\n    phone_call_sensor:\n      friendly_name: Phone Call Sensor\n      type: binary_sensor\n    vacuum_entity:\n      friendly_name: Vacuum Entity\n      type: vacuum\n  steps:\n    - step: Check if the phone call sensor is triggered and the vacuum is running\n      condition:\n        - entity: {{ inputs.phone_call_sensor }}\n          state: 'on'\n        - entity: {{ inputs.vacuum_entity }}\n          state: 'running'\n      action:\n        - service: vacuum.pause\n          target:\n            entity_id: {{ inputs.vacuum_entity }}\n```","vacuum_pause-test_blueprint_inputs","Bad","^,AssertionError: Blueprint was not valid yaml: while constructing a mapping   in '<unicode string>', line 14, column 19:             - entity: {{ inputs.phone_call_sensor }}                       ^ found unhashable key   in '<unicode string>', line 14, column 20:             - entity: {{ inputs.phone_call_sensor }}                        ^"
"vacuum_pause_vacuum_pause-vacuum_pause-3","qwen3-4b","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\nblueprint:\n  name: Vacuum Pause\n  description: Pause the vacuum when a phone call is received.\n  inputs:\n    phone_call_sensor:\n      friendly_name: Phone Call Sensor\n      type: binary_sensor\n    vacuum_entity:\n      friendly_name: Vacuum Entity\n      type: vacuum\n  steps:\n    - step: Check if the phone call sensor is triggered and the vacuum is running\n      condition:\n        - entity: {{ inputs.phone_call_sensor }}\n          state: 'on'\n        - entity: {{ inputs.vacuum_entity }}\n          state: 'running'\n      action:\n        - service: vacuum.pause\n          target:\n            entity_id: {{ inputs.vacuum_entity }}\n```","vacuum_pause-test_vacuum_running_and_paused","Bad","AssertionError: Unable to load automation."
"vacuum_pause_vacuum_pause-vacuum_pause-3","qwen3-4b","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\nblueprint:\n  name: Vacuum Pause\n  description: Pause the vacuum when a phone call is received.\n  inputs:\n    phone_call_sensor:\n      friendly_name: Phone Call Sensor\n      type: binary_sensor\n    vacuum_entity:\n      friendly_name: Vacuum Entity\n      type: vacuum\n  steps:\n    - step: Check if the phone call sensor is triggered and the vacuum is running\n      condition:\n        - entity: {{ inputs.phone_call_sensor }}\n          state: 'on'\n        - entity: {{ inputs.vacuum_entity }}\n          state: 'running'\n      action:\n        - service: vacuum.pause\n          target:\n            entity_id: {{ inputs.vacuum_entity }}\n```","vacuum_pause-test_vacuum_not_changed_when_idle","Bad","AssertionError: Unable to load automation."
"vacuum_pause_vacuum_pause-vacuum_pause-4","qwen3-4b","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\nblueprint:\n  name: Vacuum Pause\n  description: Pause the vacuum when a phone call is received.\n  inputs:\n    phone_call_sensor:\n      friendly_name: Phone Call Sensor\n      type: binary_sensor\n    vacuum_entity:\n      friendly_name: Vacuum Entity\n      type: vacuum\n  steps:\n    - step: Check if the phone call sensor is triggered and the vacuum is running\n      condition:\n        - entity: {{ inputs.phone_call_sensor }}\n          state: 'on'\n        - entity: {{ inputs.vacuum_entity }}\n          state: 'running'\n      action: \n        - service: vacuum.pause\n          target:\n            entity_id: {{ inputs.vacuum_entity }}\n```","vacuum_pause-test_blueprint_inputs","Bad","^,AssertionError: Blueprint was not valid yaml: while constructing a mapping   in '<unicode string>', line 14, column 19:             - entity: {{ inputs.phone_call_sensor }}                       ^ found unhashable key   in '<unicode string>', line 14, column 20:             - entity: {{ inputs.phone_call_sensor }}                        ^"
"vacuum_pause_vacuum_pause-vacuum_pause-4","qwen3-4b","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\nblueprint:\n  name: Vacuum Pause\n  description: Pause the vacuum when a phone call is received.\n  inputs:\n    phone_call_sensor:\n      friendly_name: Phone Call Sensor\n      type: binary_sensor\n    vacuum_entity:\n      friendly_name: Vacuum Entity\n      type: vacuum\n  steps:\n    - step: Check if the phone call sensor is triggered and the vacuum is running\n      condition:\n        - entity: {{ inputs.phone_call_sensor }}\n          state: 'on'\n        - entity: {{ inputs.vacuum_entity }}\n          state: 'running'\n      action: \n        - service: vacuum.pause\n          target:\n            entity_id: {{ inputs.vacuum_entity }}\n```","vacuum_pause-test_vacuum_running_and_paused","Bad","AssertionError: Unable to load automation."
"vacuum_pause_vacuum_pause-vacuum_pause-4","qwen3-4b","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\nblueprint:\n  name: Vacuum Pause\n  description: Pause the vacuum when a phone call is received.\n  inputs:\n    phone_call_sensor:\n      friendly_name: Phone Call Sensor\n      type: binary_sensor\n    vacuum_entity:\n      friendly_name: Vacuum Entity\n      type: vacuum\n  steps:\n    - step: Check if the phone call sensor is triggered and the vacuum is running\n      condition:\n        - entity: {{ inputs.phone_call_sensor }}\n          state: 'on'\n        - entity: {{ inputs.vacuum_entity }}\n          state: 'running'\n      action: \n        - service: vacuum.pause\n          target:\n            entity_id: {{ inputs.vacuum_entity }}\n```","vacuum_pause-test_vacuum_not_changed_when_idle","Bad","AssertionError: Unable to load automation."
"vacuum_pause_vacuum_pause-vacuum_pause-0","qwen3-8b","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\nblueprint:\n  name: Vacuum Pause on Phone Call\n  description: Pauses the vacuum when a phone call is received.\n  domain: automation\n\n  inputs:\n    phone_call_sensor:\n      description: A binary sensor that triggers when a phone call is received.\n      type: entity\n      default: binary_sensor.phone_call\n    vacuum_entity:\n      description: A vacuum entity to pause when the automation fires.\n      type: entity\n      default: vacuum.robot_vacuum\n\n  sensors:\n    vacuum_is_running:\n      description: Tracks whether the vacuum is currently running.\n      type: template\n      unit_of_measurement: ''\n      value_template: >\n        {{ states_attr('vacuum.robot_vacuum', 'state') == 'cleaning' }}\n      icon: 'mdi:robot-vacuum'\n\n  automation:\n    - alias: Pause Vacuum on Phone Call\n      trigger:\n        - platform: state\n          entity_id: >-\n            {{ phone_call_sensor }}\n          to: 'on'\n      condition:\n        - condition: template\n          value_template: >\n            {{ states('vacuum.robot_vacuum') == 'cleaning' }}\n      action:\n        - service: vacuum.pause\n          data:\n            entity_id: '{{ vacuum_entity }}'\n```","vacuum_pause-test_blueprint_inputs","Bad","AssertionError"
"vacuum_pause_vacuum_pause-vacuum_pause-0","qwen3-8b","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\nblueprint:\n  name: Vacuum Pause on Phone Call\n  description: Pauses the vacuum when a phone call is received.\n  domain: automation\n\n  inputs:\n    phone_call_sensor:\n      description: A binary sensor that triggers when a phone call is received.\n      type: entity\n      default: binary_sensor.phone_call\n    vacuum_entity:\n      description: A vacuum entity to pause when the automation fires.\n      type: entity\n      default: vacuum.robot_vacuum\n\n  sensors:\n    vacuum_is_running:\n      description: Tracks whether the vacuum is currently running.\n      type: template\n      unit_of_measurement: ''\n      value_template: >\n        {{ states_attr('vacuum.robot_vacuum', 'state') == 'cleaning' }}\n      icon: 'mdi:robot-vacuum'\n\n  automation:\n    - alias: Pause Vacuum on Phone Call\n      trigger:\n        - platform: state\n          entity_id: >-\n            {{ phone_call_sensor }}\n          to: 'on'\n      condition:\n        - condition: template\n          value_template: >\n            {{ states('vacuum.robot_vacuum') == 'cleaning' }}\n      action:\n        - service: vacuum.pause\n          data:\n            entity_id: '{{ vacuum_entity }}'\n```","vacuum_pause-test_vacuum_running_and_paused","Bad","AssertionError: Unable to load automation."
"vacuum_pause_vacuum_pause-vacuum_pause-0","qwen3-8b","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\nblueprint:\n  name: Vacuum Pause on Phone Call\n  description: Pauses the vacuum when a phone call is received.\n  domain: automation\n\n  inputs:\n    phone_call_sensor:\n      description: A binary sensor that triggers when a phone call is received.\n      type: entity\n      default: binary_sensor.phone_call\n    vacuum_entity:\n      description: A vacuum entity to pause when the automation fires.\n      type: entity\n      default: vacuum.robot_vacuum\n\n  sensors:\n    vacuum_is_running:\n      description: Tracks whether the vacuum is currently running.\n      type: template\n      unit_of_measurement: ''\n      value_template: >\n        {{ states_attr('vacuum.robot_vacuum', 'state') == 'cleaning' }}\n      icon: 'mdi:robot-vacuum'\n\n  automation:\n    - alias: Pause Vacuum on Phone Call\n      trigger:\n        - platform: state\n          entity_id: >-\n            {{ phone_call_sensor }}\n          to: 'on'\n      condition:\n        - condition: template\n          value_template: >\n            {{ states('vacuum.robot_vacuum') == 'cleaning' }}\n      action:\n        - service: vacuum.pause\n          data:\n            entity_id: '{{ vacuum_entity }}'\n```","vacuum_pause-test_vacuum_not_changed_when_idle","Bad","AssertionError: Unable to load automation."
"vacuum_pause_vacuum_pause-vacuum_pause-1","qwen3-8b","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\nblueprint:\n  name: Vacuum Pause on Phone Call\n  description: Pauses the vacuum when a phone call is detected.\n  domain: automation\n\n  inputs:\n    phone_call_sensor:\n      description: A binary_sensor entity that triggers when a phone call is received.\n      default: binary_sensor.phone_call\n      type: sensor.binary_sensor\n    vacuum_entity:\n      description: A vacuum entity to pause when the automation fires.\n      default: vacuum.robot_vacuum\n      type: device.vacuum\n\n  automation:\n    - alias: Pause Vacuum on Phone Call\n      trigger:\n        - platform: state\n          entity_id: >-\n            {{ phone_call_sensor }}\n          to: 'on'\n      condition:\n        - condition: state\n          entity_id: {{ vacuum_entity }}\n          state: 'cleaning'\n      action:\n        - service: vacuum.pause\n          data:\n            entity_id: {{ vacuum_entity }}\n```","vacuum_pause-test_blueprint_inputs","Bad","^,AssertionError: Blueprint was not valid yaml: while constructing a mapping   in '<unicode string>', line 25, column 22:               entity_id: {{ vacuum_entity }}                          ^ found unhashable key   in '<unicode string>', line 25, column 23:               entity_id: {{ vacuum_entity }}                           ^"
"vacuum_pause_vacuum_pause-vacuum_pause-1","qwen3-8b","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\nblueprint:\n  name: Vacuum Pause on Phone Call\n  description: Pauses the vacuum when a phone call is detected.\n  domain: automation\n\n  inputs:\n    phone_call_sensor:\n      description: A binary_sensor entity that triggers when a phone call is received.\n      default: binary_sensor.phone_call\n      type: sensor.binary_sensor\n    vacuum_entity:\n      description: A vacuum entity to pause when the automation fires.\n      default: vacuum.robot_vacuum\n      type: device.vacuum\n\n  automation:\n    - alias: Pause Vacuum on Phone Call\n      trigger:\n        - platform: state\n          entity_id: >-\n            {{ phone_call_sensor }}\n          to: 'on'\n      condition:\n        - condition: state\n          entity_id: {{ vacuum_entity }}\n          state: 'cleaning'\n      action:\n        - service: vacuum.pause\n          data:\n            entity_id: {{ vacuum_entity }}\n```","vacuum_pause-test_vacuum_running_and_paused","Bad","AssertionError: Unable to load automation."
"vacuum_pause_vacuum_pause-vacuum_pause-1","qwen3-8b","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\nblueprint:\n  name: Vacuum Pause on Phone Call\n  description: Pauses the vacuum when a phone call is detected.\n  domain: automation\n\n  inputs:\n    phone_call_sensor:\n      description: A binary_sensor entity that triggers when a phone call is received.\n      default: binary_sensor.phone_call\n      type: sensor.binary_sensor\n    vacuum_entity:\n      description: A vacuum entity to pause when the automation fires.\n      default: vacuum.robot_vacuum\n      type: device.vacuum\n\n  automation:\n    - alias: Pause Vacuum on Phone Call\n      trigger:\n        - platform: state\n          entity_id: >-\n            {{ phone_call_sensor }}\n          to: 'on'\n      condition:\n        - condition: state\n          entity_id: {{ vacuum_entity }}\n          state: 'cleaning'\n      action:\n        - service: vacuum.pause\n          data:\n            entity_id: {{ vacuum_entity }}\n```","vacuum_pause-test_vacuum_not_changed_when_idle","Bad","AssertionError: Unable to load automation."
"vacuum_pause_vacuum_pause-vacuum_pause-2","qwen3-8b","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\nblueprint:\n  name: Vacuum Pause on Phone Call\n  description: Pauses the vacuum when a phone call is received.\n  domain: automation\n  inputs:\n    phone_call_sensor:\n      description: A binary sensor that triggers when a phone call is received.\n      default: binary_sensor.phone_call\n      type: template\n    vacuum_entity:\n      description: A vacuum entity to pause when the automation fires.\n      default: vacuum.robot_vacuum\n      type: template\n  sensors:\n    vacuum_running:\n      description: Checks if the vacuum is currently running.\n      type: template\n      unit_of_measurement: ''\n      value_template: >\n        {% if states('vacuum.robot_vacuum') is not none and\n           states('vacuum.robot_vacuum').state == 'cleaning' or\n           states('vacuum.robot_vacuum').state == 'returning' %}\n          true\n        {% else %}\n          false\n        {% endif %}\n  triggers:\n    - platform: state\n      entity_id: '{{ phone_call_sensor }}'\n      to: 'on'\n  conditions:\n    - condition: template\n      value_template: >\n        {% if is_state(vacuum_entity, 'cleaning') or\n           is_state(vacuum_entity, 'returning') %}\n          true\n        {% else %}\n          false\n        {% endif %}\n  actions:\n    - service: vacuum.pause\n      data:\n        entity_id: '{{ vacuum_entity }}'\n```","vacuum_pause-test_blueprint_inputs","Bad","AssertionError"
"vacuum_pause_vacuum_pause-vacuum_pause-2","qwen3-8b","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\nblueprint:\n  name: Vacuum Pause on Phone Call\n  description: Pauses the vacuum when a phone call is received.\n  domain: automation\n  inputs:\n    phone_call_sensor:\n      description: A binary sensor that triggers when a phone call is received.\n      default: binary_sensor.phone_call\n      type: template\n    vacuum_entity:\n      description: A vacuum entity to pause when the automation fires.\n      default: vacuum.robot_vacuum\n      type: template\n  sensors:\n    vacuum_running:\n      description: Checks if the vacuum is currently running.\n      type: template\n      unit_of_measurement: ''\n      value_template: >\n        {% if states('vacuum.robot_vacuum') is not none and\n           states('vacuum.robot_vacuum').state == 'cleaning' or\n           states('vacuum.robot_vacuum').state == 'returning' %}\n          true\n        {% else %}\n          false\n        {% endif %}\n  triggers:\n    - platform: state\n      entity_id: '{{ phone_call_sensor }}'\n      to: 'on'\n  conditions:\n    - condition: template\n      value_template: >\n        {% if is_state(vacuum_entity, 'cleaning') or\n           is_state(vacuum_entity, 'returning') %}\n          true\n        {% else %}\n          false\n        {% endif %}\n  actions:\n    - service: vacuum.pause\n      data:\n        entity_id: '{{ vacuum_entity }}'\n```","vacuum_pause-test_vacuum_running_and_paused","Bad","AssertionError: Unable to load automation."
"vacuum_pause_vacuum_pause-vacuum_pause-2","qwen3-8b","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\nblueprint:\n  name: Vacuum Pause on Phone Call\n  description: Pauses the vacuum when a phone call is received.\n  domain: automation\n  inputs:\n    phone_call_sensor:\n      description: A binary sensor that triggers when a phone call is received.\n      default: binary_sensor.phone_call\n      type: template\n    vacuum_entity:\n      description: A vacuum entity to pause when the automation fires.\n      default: vacuum.robot_vacuum\n      type: template\n  sensors:\n    vacuum_running:\n      description: Checks if the vacuum is currently running.\n      type: template\n      unit_of_measurement: ''\n      value_template: >\n        {% if states('vacuum.robot_vacuum') is not none and\n           states('vacuum.robot_vacuum').state == 'cleaning' or\n           states('vacuum.robot_vacuum').state == 'returning' %}\n          true\n        {% else %}\n          false\n        {% endif %}\n  triggers:\n    - platform: state\n      entity_id: '{{ phone_call_sensor }}'\n      to: 'on'\n  conditions:\n    - condition: template\n      value_template: >\n        {% if is_state(vacuum_entity, 'cleaning') or\n           is_state(vacuum_entity, 'returning') %}\n          true\n        {% else %}\n          false\n        {% endif %}\n  actions:\n    - service: vacuum.pause\n      data:\n        entity_id: '{{ vacuum_entity }}'\n```","vacuum_pause-test_vacuum_not_changed_when_idle","Bad","AssertionError: Unable to load automation."
"vacuum_pause_vacuum_pause-vacuum_pause-3","qwen3-8b","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\nblueprint:\n  name: Vacuum Pause on Phone Call\n  description: Pauses the vacuum when a phone call is received.\n  domain: automation\n\n  inputs:\n    phone_call_sensor:\n      description: A binary_sensor entity that triggers when a phone call is received.\n      type: sensor.binary_sensor\n      default: binary_sensor.phone_call\n    vacuum_entity:\n      description: A vacuum entity to pause when the automation fires.\n      type: device.vacuum\n      default: vacuum.robot_vacuum\n\n  sensors:\n    vacuum_state:\n      description: Tracks the current state of the vacuum.\n      type: template\n      unit_of_measurement: ''\n      value_template: >\n        {% if states('vacuum.robot_vacuum') is not none and\n          states('vacuum.robot_vacuum') != 'unknown' and\n          states('vacuum.robot_vacuum') != 'docked' and\n          states('vacuum.robot_vacuum') != 'returning' and\n          states('vacuum.robot_vacuum') != 'paused' %}\n          {{ states('vacuum.robot_vacuum') }}\n        {% else %}\n          offline\n        {% endif %}\n      icon: mdi:robot-vacuum\n\n  automation:\n    - alias: Pause Vacuum on Phone Call\n      trigger:\n        - platform: state\n          entity_id: >-\n            {{ phone_call_sensor }}\n          to: 'on'\n      condition:\n        - condition: template\n          value_template: >\n            {% if states('vacuum.robot_vacuum') is not none and\n              states('vacuum.robot_vacuum') != 'unknown' and\n              states('vacuum.robot_vacuum') != 'docked' and\n              states('vacuum.robot_vacuum') != 'returning' and\n              states('vacuum.robot_vacuum') != 'paused' %}\n              true\n            {% else %}\n              false\n            {% endif %}\n      action:\n        - service: vacuum.pause\n          data:\n            entity_id: >-\n              {{ vacuum_entity }}\n```","vacuum_pause-test_blueprint_inputs","Bad","AssertionError"
"vacuum_pause_vacuum_pause-vacuum_pause-3","qwen3-8b","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\nblueprint:\n  name: Vacuum Pause on Phone Call\n  description: Pauses the vacuum when a phone call is received.\n  domain: automation\n\n  inputs:\n    phone_call_sensor:\n      description: A binary_sensor entity that triggers when a phone call is received.\n      type: sensor.binary_sensor\n      default: binary_sensor.phone_call\n    vacuum_entity:\n      description: A vacuum entity to pause when the automation fires.\n      type: device.vacuum\n      default: vacuum.robot_vacuum\n\n  sensors:\n    vacuum_state:\n      description: Tracks the current state of the vacuum.\n      type: template\n      unit_of_measurement: ''\n      value_template: >\n        {% if states('vacuum.robot_vacuum') is not none and\n          states('vacuum.robot_vacuum') != 'unknown' and\n          states('vacuum.robot_vacuum') != 'docked' and\n          states('vacuum.robot_vacuum') != 'returning' and\n          states('vacuum.robot_vacuum') != 'paused' %}\n          {{ states('vacuum.robot_vacuum') }}\n        {% else %}\n          offline\n        {% endif %}\n      icon: mdi:robot-vacuum\n\n  automation:\n    - alias: Pause Vacuum on Phone Call\n      trigger:\n        - platform: state\n          entity_id: >-\n            {{ phone_call_sensor }}\n          to: 'on'\n      condition:\n        - condition: template\n          value_template: >\n            {% if states('vacuum.robot_vacuum') is not none and\n              states('vacuum.robot_vacuum') != 'unknown' and\n              states('vacuum.robot_vacuum') != 'docked' and\n              states('vacuum.robot_vacuum') != 'returning' and\n              states('vacuum.robot_vacuum') != 'paused' %}\n              true\n            {% else %}\n              false\n            {% endif %}\n      action:\n        - service: vacuum.pause\n          data:\n            entity_id: >-\n              {{ vacuum_entity }}\n```","vacuum_pause-test_vacuum_running_and_paused","Bad","AssertionError: Unable to load automation."
"vacuum_pause_vacuum_pause-vacuum_pause-3","qwen3-8b","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\nblueprint:\n  name: Vacuum Pause on Phone Call\n  description: Pauses the vacuum when a phone call is received.\n  domain: automation\n\n  inputs:\n    phone_call_sensor:\n      description: A binary_sensor entity that triggers when a phone call is received.\n      type: sensor.binary_sensor\n      default: binary_sensor.phone_call\n    vacuum_entity:\n      description: A vacuum entity to pause when the automation fires.\n      type: device.vacuum\n      default: vacuum.robot_vacuum\n\n  sensors:\n    vacuum_state:\n      description: Tracks the current state of the vacuum.\n      type: template\n      unit_of_measurement: ''\n      value_template: >\n        {% if states('vacuum.robot_vacuum') is not none and\n          states('vacuum.robot_vacuum') != 'unknown' and\n          states('vacuum.robot_vacuum') != 'docked' and\n          states('vacuum.robot_vacuum') != 'returning' and\n          states('vacuum.robot_vacuum') != 'paused' %}\n          {{ states('vacuum.robot_vacuum') }}\n        {% else %}\n          offline\n        {% endif %}\n      icon: mdi:robot-vacuum\n\n  automation:\n    - alias: Pause Vacuum on Phone Call\n      trigger:\n        - platform: state\n          entity_id: >-\n            {{ phone_call_sensor }}\n          to: 'on'\n      condition:\n        - condition: template\n          value_template: >\n            {% if states('vacuum.robot_vacuum') is not none and\n              states('vacuum.robot_vacuum') != 'unknown' and\n              states('vacuum.robot_vacuum') != 'docked' and\n              states('vacuum.robot_vacuum') != 'returning' and\n              states('vacuum.robot_vacuum') != 'paused' %}\n              true\n            {% else %}\n              false\n            {% endif %}\n      action:\n        - service: vacuum.pause\n          data:\n            entity_id: >-\n              {{ vacuum_entity }}\n```","vacuum_pause-test_vacuum_not_changed_when_idle","Bad","AssertionError: Unable to load automation."
"vacuum_pause_vacuum_pause-vacuum_pause-4","qwen3-8b","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\nblueprint:\n  name: Vacuum Pause on Phone Call\n  description: Pauses the vacuum when a phone call is detected.\n  domain: automation\n\n  inputs:\n    phone_call_sensor:\n      description: A binary_sensor entity that triggers when a phone call is received.\n      default: binary_sensor.phone_call\n      type: entity_id\n    vacuum_entity:\n      description: A vacuum entity to pause when the automation fires.\n      default: vacuum.robot_vacuum\n      type: entity_id\n\n  sensors:\n    vacuum_is_running:\n      description: Tracks whether the vacuum is currently running.\n      unit_of_measurement: %\n      value_template: >\n        {% if states('vacuum.robot_vacuum') is not none and\n             states('vacuum.robot_vacuum') | int >= 10 and\n             states('vacuum.robot_vacuum') | int <= 100 %}\n          {{ states('vacuum.robot_vacuum') | int }}\n        {% else %}\n          0\n        {% endif %}\n      icon: mdi:robot-vacuum\n\n  automation:\n    - alias: Pause Vacuum on Phone Call\n      trigger:\n        - platform: state\n          entity_id: >-\n            {{ phone_call_sensor }}\n          to: 'on'\n      condition:\n        - condition: state\n          entity_id: {{ vacuum_entity }}\n          state: 'docked'\n          operator: not\n      action:\n        - service: vacuum.pause\n          data:\n            entity_id: {{ vacuum_entity }}\n```","vacuum_pause-test_blueprint_inputs","Bad","^,AssertionError: Blueprint was not valid yaml: while scanning for the next token found character '%' that cannot start any token   in '<unicode string>', line 19, column 28:           unit_of_measurement: %                                ^"
"vacuum_pause_vacuum_pause-vacuum_pause-4","qwen3-8b","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\nblueprint:\n  name: Vacuum Pause on Phone Call\n  description: Pauses the vacuum when a phone call is detected.\n  domain: automation\n\n  inputs:\n    phone_call_sensor:\n      description: A binary_sensor entity that triggers when a phone call is received.\n      default: binary_sensor.phone_call\n      type: entity_id\n    vacuum_entity:\n      description: A vacuum entity to pause when the automation fires.\n      default: vacuum.robot_vacuum\n      type: entity_id\n\n  sensors:\n    vacuum_is_running:\n      description: Tracks whether the vacuum is currently running.\n      unit_of_measurement: %\n      value_template: >\n        {% if states('vacuum.robot_vacuum') is not none and\n             states('vacuum.robot_vacuum') | int >= 10 and\n             states('vacuum.robot_vacuum') | int <= 100 %}\n          {{ states('vacuum.robot_vacuum') | int }}\n        {% else %}\n          0\n        {% endif %}\n      icon: mdi:robot-vacuum\n\n  automation:\n    - alias: Pause Vacuum on Phone Call\n      trigger:\n        - platform: state\n          entity_id: >-\n            {{ phone_call_sensor }}\n          to: 'on'\n      condition:\n        - condition: state\n          entity_id: {{ vacuum_entity }}\n          state: 'docked'\n          operator: not\n      action:\n        - service: vacuum.pause\n          data:\n            entity_id: {{ vacuum_entity }}\n```","vacuum_pause-test_vacuum_running_and_paused","Bad","AssertionError: Unable to load automation."
"vacuum_pause_vacuum_pause-vacuum_pause-4","qwen3-8b","vacuum","# Vacuum Pause\n\n## Problem statement\n\nCreate a blueprint automation to pause the vacuum when I receive a phone call.\n\n## Example use cases\n\nThese are example use cases that could be used with the blueprint:\n\n- Pause the vacuum when I get a phone call from my relatives\n- Don't interrupt my work video convererence call with vacuum noise by pausing it when the call starts\n\n## Detailed Description\n\nThe blueprint should accept two inputs:\n\n| Input               | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `phone_call_sensor` | A `binary_sensor` entity that triggers when a phone call is received. |\n| `vacuum_entity`     | A `vacuum` entity to pause when the automation fires.                 |\n\nThe automation should trigger when the binary sensor fires and the vacuum is running. The vacuum\nshould be paused (not stopped) and can be resumed manually.\n","","```yaml\nblueprint:\n  name: Vacuum Pause on Phone Call\n  description: Pauses the vacuum when a phone call is detected.\n  domain: automation\n\n  inputs:\n    phone_call_sensor:\n      description: A binary_sensor entity that triggers when a phone call is received.\n      default: binary_sensor.phone_call\n      type: entity_id\n    vacuum_entity:\n      description: A vacuum entity to pause when the automation fires.\n      default: vacuum.robot_vacuum\n      type: entity_id\n\n  sensors:\n    vacuum_is_running:\n      description: Tracks whether the vacuum is currently running.\n      unit_of_measurement: %\n      value_template: >\n        {% if states('vacuum.robot_vacuum') is not none and\n             states('vacuum.robot_vacuum') | int >= 10 and\n             states('vacuum.robot_vacuum') | int <= 100 %}\n          {{ states('vacuum.robot_vacuum') | int }}\n        {% else %}\n          0\n        {% endif %}\n      icon: mdi:robot-vacuum\n\n  automation:\n    - alias: Pause Vacuum on Phone Call\n      trigger:\n        - platform: state\n          entity_id: >-\n            {{ phone_call_sensor }}\n          to: 'on'\n      condition:\n        - condition: state\n          entity_id: {{ vacuum_entity }}\n          state: 'docked'\n          operator: not\n      action:\n        - service: vacuum.pause\n          data:\n            entity_id: {{ vacuum_entity }}\n```","vacuum_pause-test_vacuum_not_changed_when_idle","Bad","AssertionError: Unable to load automation."
