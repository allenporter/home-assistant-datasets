---
uuid: 8b243854-fe3a-4601-a78a-483d50ea1a34
task_id: humidity_fan_humidity_fan-humidity_fan-1
model_id: gpt-oss-20b
category: fan
task:
  input_text: |
    # Humidity Fan

    ## Problem statement

    Create a blueprint automation to turn on the fan based on the value of the humidity sensor.

    ## Example use cases

    These are example use cases that could be used with the blueprint:

    - Turn on the bathroom exhaust fan when the bathroom humidty is above 60%
    - Make sure the garage does not get too humid

    ## Detailed Description

    The blueprint should accept two inputs:

    | Input               | Description                                                           |
    | ------------------- | --------------------------------------------------------------------- |
    | `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |
    | `humidity_level` | A `number` selector to set the value used as the trigger. |
    | `fan_entity`     | A `fan` entity to turn on when the automation fires. |

    The automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When
    triggered, the fan should be turned off. The fan should also be stopped when the
    sensor goes back down below the desired level. The automation should not try to
    turn the fan on if it is already on, and should not turn the fan off when it is
    already off.
response: "Below is a complete Home‑Assistant blueprint you can drop into `config/blueprints/automation/humidity_fan.yaml`.\
  \  \nSave it, then create a new automation using this blueprint and pick the entities\
  \ that belong to your house.\n\n```yaml\nblueprint:\n  name: Humidity‑Controlled\
  \ Fan\n  domain: automation\n  author: Your Name\n  description: |\n    Turn a fan\
  \ on when the humidity sensor rises above a threshold\n    and turn it off again\
  \ when the humidity falls below that threshold.\n    The automation only changes\
  \ the fan state when it needs to.\n  source_url: https://github.com/your-repo/humidity‑fan\n\
  \  version: 1.0.0\n\n  #-------------------------------------------------------------------\n\
  \  # Input variables that the user will set when creating the automation\n  #-------------------------------------------------------------------\n\
  \  input:\n    humidity_sensor:\n      name: Humidity sensor\n      selector:\n\
  \        entity:\n          domain: sensor\n    humidity_level:\n      name: Humidity\
  \ threshold\n      selector:\n        number:\n          min: 0\n          max:\
  \ 100\n          unit_of_measurement: \"%\"\n    fan_entity:\n      name: Fan to\
  \ control\n      selector:\n        entity:\n          domain: fan\n\n#---------------------------------------------------------------------\n\
  # Triggers:  one for turning on, one for turning off\n#---------------------------------------------------------------------\n\
  trigger:\n  - platform: numeric_state\n    entity_id: !input humidity_sensor\n \
  \   above: !input humidity_level\n    id: turn_on\n  - platform: numeric_state\n\
  \    entity_id: !input humidity_sensor\n    below: !input humidity_level\n    id:\
  \ turn_off\n\n#---------------------------------------------------------------------\n\
  # Condition: only act if the fan actually needs to change state\n#---------------------------------------------------------------------\n\
  condition:\n  - condition: template\n    value_template: >\n      {% if trigger.id\
  \ == 'turn_on' %}\n        {{ is_state(input.fan_entity, 'off') }}\n      {% elif\
  \ trigger.id == 'turn_off' %}\n        {{ is_state(input.fan_entity, 'on') }}\n\
  \      {% endif %}\n\n#---------------------------------------------------------------------\n\
  # Action: turn the fan on or off depending on which trigger fired\n#---------------------------------------------------------------------\n\
  action:\n  - service_template: >\n      {% if trigger.id == 'turn_on' %}\n     \
  \   fan.turn_on\n      {% elif trigger.id == 'turn_off' %}\n        fan.turn_off\n\
  \      {% endif %}\n    data:\n      entity_id: !input fan_entity\n\n#---------------------------------------------------------------------\n\
  # Optional: Prevent overlapping executions\n#---------------------------------------------------------------------\n\
  mode: restart\n```\n\n### How to use\n\n1. Put the file in `config/blueprints/automation/`.\
  \  \n2. Reload blueprints (Configuration → Server Controls → Reload Blueprints).\
  \  \n3. Create a new automation → Browse → Your “Humidity‑Controlled Fan” blueprint.\
  \  \n4. Pick your humidity sensor, the desired threshold, and the fan entity.\n\n\
  The automation will now turn the fan on when the humidity rises above the set level\
  \ and turn it off again when it falls below that level, while avoiding redundant\
  \ on/off commands."
context:
  conversation_trace:
  - event_type: async_process
    data:
      text: |
        # Humidity Fan

        ## Problem statement

        Create a blueprint automation to turn on the fan based on the value of the humidity sensor.

        ## Example use cases

        These are example use cases that could be used with the blueprint:

        - Turn on the bathroom exhaust fan when the bathroom humidty is above 60%
        - Make sure the garage does not get too humid

        ## Detailed Description

        The blueprint should accept two inputs:

        | Input               | Description                                                           |
        | ------------------- | --------------------------------------------------------------------- |
        | `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |
        | `humidity_level` | A `number` selector to set the value used as the trigger. |
        | `fan_entity`     | A `fan` entity to turn on when the automation fires. |

        The automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When
        triggered, the fan should be turned off. The fan should also be stopped when the
        sensor goes back down below the desired level. The automation should not try to
        turn the fan on if it is already on, and should not turn the fan off when it is
        already off.
      context:
        id: 01KF8QYYGQRVZPS3MFVX9D5J4E
        parent_id: null
        user_id: null
      conversation_id: null
      device_id: null
      satellite_id: null
      language: en
      agent_id: conversation.mock_title
      extra_system_prompt: null
    timestamp: 2026-01-18 14:25:51.127101+00:00
  - event_type: agent_detail
    data:
      messages:
      - role: system
        content: |-
          You are a voice assistant for Home Assistant.
          Answer questions about the world truthfully.
          Answer in plain text. Keep it simple and to the point.
          Current time is 06:25:51. Today's date is 2026-01-18.
        created: 2026-01-18 14:25:51.128210+00:00
      - role: user
        content: |
          # Humidity Fan

          ## Problem statement

          Create a blueprint automation to turn on the fan based on the value of the humidity sensor.

          ## Example use cases

          These are example use cases that could be used with the blueprint:

          - Turn on the bathroom exhaust fan when the bathroom humidty is above 60%
          - Make sure the garage does not get too humid

          ## Detailed Description

          The blueprint should accept two inputs:

          | Input               | Description                                                           |
          | ------------------- | --------------------------------------------------------------------- |
          | `humidity_sensor` | A `sensor` entity that is a humidty sensor that triggers the automation. |
          | `humidity_level` | A `number` selector to set the value used as the trigger. |
          | `fan_entity`     | A `fan` entity to turn on when the automation fires. |

          The automation should trigger when the `humidity_sensor` level goes above `humidity_level`. When
          triggered, the fan should be turned off. The fan should also be stopped when the
          sensor goes back down below the desired level. The automation should not try to
          turn the fan on if it is already on, and should not turn the fan off when it is
          already off.
        attachments: null
        created: 2026-01-18 14:25:51.127150+00:00
      - role: assistant
        agent_id: conversation.mock_title
        content: "Below is a complete Home‑Assistant blueprint you can drop into `config/blueprints/automation/humidity_fan.yaml`.\
          \  \nSave it, then create a new automation using this blueprint and pick\
          \ the entities that belong to your house.\n\n```yaml\nblueprint:\n  name:\
          \ Humidity‑Controlled Fan\n  domain: automation\n  author: Your Name\n \
          \ description: |\n    Turn a fan on when the humidity sensor rises above\
          \ a threshold\n    and turn it off again when the humidity falls below that\
          \ threshold.\n    The automation only changes the fan state when it needs\
          \ to.\n  source_url: https://github.com/your-repo/humidity‑fan\n  version:\
          \ 1.0.0\n\n  #-------------------------------------------------------------------\n\
          \  # Input variables that the user will set when creating the automation\n\
          \  #-------------------------------------------------------------------\n\
          \  input:\n    humidity_sensor:\n      name: Humidity sensor\n      selector:\n\
          \        entity:\n          domain: sensor\n    humidity_level:\n      name:\
          \ Humidity threshold\n      selector:\n        number:\n          min: 0\n\
          \          max: 100\n          unit_of_measurement: \"%\"\n    fan_entity:\n\
          \      name: Fan to control\n      selector:\n        entity:\n        \
          \  domain: fan\n\n#---------------------------------------------------------------------\n\
          # Triggers:  one for turning on, one for turning off\n#---------------------------------------------------------------------\n\
          trigger:\n  - platform: numeric_state\n    entity_id: !input humidity_sensor\n\
          \    above: !input humidity_level\n    id: turn_on\n  - platform: numeric_state\n\
          \    entity_id: !input humidity_sensor\n    below: !input humidity_level\n\
          \    id: turn_off\n\n#---------------------------------------------------------------------\n\
          # Condition: only act if the fan actually needs to change state\n#---------------------------------------------------------------------\n\
          condition:\n  - condition: template\n    value_template: >\n      {% if\
          \ trigger.id == 'turn_on' %}\n        {{ is_state(input.fan_entity, 'off')\
          \ }}\n      {% elif trigger.id == 'turn_off' %}\n        {{ is_state(input.fan_entity,\
          \ 'on') }}\n      {% endif %}\n\n#---------------------------------------------------------------------\n\
          # Action: turn the fan on or off depending on which trigger fired\n#---------------------------------------------------------------------\n\
          action:\n  - service_template: >\n      {% if trigger.id == 'turn_on' %}\n\
          \        fan.turn_on\n      {% elif trigger.id == 'turn_off' %}\n      \
          \  fan.turn_off\n      {% endif %}\n    data:\n      entity_id: !input fan_entity\n\
          \n#---------------------------------------------------------------------\n\
          # Optional: Prevent overlapping executions\n#---------------------------------------------------------------------\n\
          mode: restart\n```\n\n### How to use\n\n1. Put the file in `config/blueprints/automation/`.\
          \  \n2. Reload blueprints (Configuration → Server Controls → Reload Blueprints).\
          \  \n3. Create a new automation → Browse → Your “Humidity‑Controlled Fan”\
          \ blueprint.  \n4. Pick your humidity sensor, the desired threshold, and\
          \ the fan entity.\n\nThe automation will now turn the fan on when the humidity\
          \ rises above the set level and turn it off again when it falls below that\
          \ level, while avoiding redundant on/off commands."
        thinking_content: |-
          The user wants a blueprint automation. They describe: "turn on the fan based on the value of the humidity sensor". But in detailed description: "When triggered, the fan should be turned off" That seems contradictory. Likely they mean turn on the fan when humidity > level, turn off when below. They said "automation should not try to turn the fan on if it is already on, and should not turn the fan off when it is already off." So typical blueprint with trigger: numeric state of humidity sensor > level. Condition: fan is off. Action: turn fan on. Another trigger: numeric state < level. Condition: fan is on. Action: turn fan off. Use input_select? They want blueprint inputs: humidity_sensor, humidity_level, fan_entity. Provide YAML. Keep plain text. So answer: blueprint YAML. Probably provide blueprint YAML with description and triggers. Use trigger for numeric_state above and below. Provide conditions to check fan state. Provide action. Should set fan mode or "turn_on" "turn_off". Provide a unique_id. Provide title and domain. Provide input variables. So produce blueprint. Use "trigger" and "action". Also "condition" to check fan state. Provide example of condition: condition: state, entity_id: fan_entity, state: "off". Another for on. Provide both triggers in a single blueprint using "trigger" with two conditions. Or separate triggers with "trigger" section: two triggers. But easier: use one trigger type: numeric_state. Actually two triggers. Or use "trigger" with two types? We can use "trigger" with type numeric_state, below, above. But easier: two separate triggers in the "trigger" list: first with above threshold, second with below threshold. Use "for" maybe. Provide "trigger" for above, "action" to turn on. "trigger" for below, "action" to turn off. Provide "condition" accordingly. Also add "mode: restart" maybe.

          We should include "variables:" if needed. But no, blueprint variables used in triggers. In blueprint, we can use "trigger:" with platform: numeric_state, entity_id: !input humidity_sensor, below: !input humidity_level for below trigger. But the blueprint's triggers support templating? They support variables. So use "platform: numeric_state" with "entity_id" referencing !input. "above:" maybe. For "below" trigger, we can do: numeric_state: below: !input humidity_level. Actually for below, we need "below" param. For above, "above". Provide triggers. Condition: state for fan entity.

          Let's craft blueprint:

          ```
          blueprint:
            name: Humidity Controlled Fan
            domain: automation
            input:
              humidity_sensor:
                name: Humidity Sensor
                selector:
                  entity:
                    domain: sensor
              humidity_level:
                name: Humidity threshold
                selector:
                  number:
                    min: 0
                    max: 100
                    unit_of_measurement: "%"
              fan_entity:
                name: Fan
                selector:
                  entity:
                    domain: fan

          trigger:
            - platform: numeric_state
              entity_id: !input humidity_sensor
              above: !input humidity_level
              id: "turn_on"
            - platform: numeric_state
              entity_id: !input humidity_sensor
              below: !input humidity_level
              id: "turn_off"

          condition:
            - condition: or
              conditions:
                - condition: state
                  entity_id: !input fan_entity
                  state: "off"
                - condition: state
                  entity_id: !input fan_entity
                  state: "on"

          action:
            - service_template: >-
                {% if trigger.id == 'turn_on' %}
                fan.turn_on
                {% elif trigger.id == 'turn_off' %}
                fan.turn_off
                {% endif %}
              entity_id: !input fan_entity
          ```

          But need separate conditions: if turn_on, only if fan off. If turn_off, only if fan on. We can separate by using two separate automations inside blueprint? Actually blueprint can have a single automation with both triggers. Use "condition" that uses templating to check correct state. Use "service_template" with conditional. Use "trigger.for" maybe.

          Alternate: use single trigger numeric_state with condition: above threshold. Use "action" to turn on if fan off. Then use second trigger below threshold to turn off if fan on. So two triggers each with its own conditions and action. We can do in blueprint:

          ```
          trigger:
            - platform: numeric_state
              entity_id: !input humidity_sensor
              above: !input humidity_level
              id: turn_on
              for: "0"
            - platform: numeric_state
              entity_id: !input humidity_sensor
              below: !input humidity_level
              id: turn_off
              for: "0"
          condition:
            - condition: or
              conditions:
                - condition: and
                  conditions:
                    - condition: trigger
                      id: turn_on
                    - condition: state
                      entity_id: !input fan_entity
                      state: "off"
                - condition: and
                  conditions:
                    - condition: trigger
                      id: turn_off
                    - condition: state
                      entity_id: !input fan_entity
                      state: "on"
          action:
            - service: fan.turn_on
              data:
                entity_id: !input fan_entity
            - service: fan.turn_off
              data:
                entity_id: !input fan_entity
          ```

          But this doesn't separate actions; we might need to use conditional service call.

          Better: use service_template inside action: e.g.,

          ```
          action:
            - service_template: >
                {% if trigger.id == 'turn_on' %}
                fan.turn_on
                {% elif trigger.id == 'turn_off' %}
                fan.turn_off
                {% endif %}
              data:
                entity_id: !input fan_entity
          ```

          Also ensure condition checks fan state accordingly. But we can combine condition with service_template: if trigger is turn_on and fan off, then service turn_on. else if turn_off and fan on, service turn_off. Actually service_template handles that. But we still need to avoid calling turn_on when fan is already on. But service_template will only call turn_on when trigger is turn_on; but fan might be already on. We can add condition to check fan off. Use condition before action: condition: state of fan accordingly. But separate conditions per trigger? We can use `condition` that uses templating: e.g.,

          ```
          condition:
            - condition: template
              value_template: >-
                {% if trigger.id == 'turn_on' %}
                  {{ is_state(!input fan_entity, 'off') }}
                {% elif trigger.id == 'turn_off' %}
                  {{ is_state(!input fan_entity, 'on') }}
                {% endif %}
          ```

          But templating inside condition uses Jinja. Use `is_state` function.

          Simplify: use two triggers each with own `condition` and `action`. Actually blueprint supports multiple triggers but you can't have separate conditions for each. But you can use `trigger` and `condition` with templating.

          Let's produce simpler blueprint: Use numeric_state trigger above and below threshold. Then use a single condition to check fan state. Use `action` with conditional service call. That covers.

          But we need to ensure fan only turns on if off. So condition: state fan is off for above threshold. Condition: state fan is on for below threshold. That can be done with templating inside condition referencing trigger.id.

          So blueprint:

          ```
          condition:
            - condition: template
              value_template: >-
                {% if trigger.id == 'turn_on' %}
                  {{ is_state('!input fan_entity', 'off') }}
                {% elif trigger.id == 'turn_off' %}
                  {{ is_state('!input fan_entity', 'on') }}
                {% endif %}
          ```

          But is_state uses entity id string, can't use `!input` inside string. Should use variable interpolation: `{{ is_state(fan_entity, 'off') }}` where fan_entity is defined variable? But blueprint variables: `!input fan_entity` is replaced by entity id at runtime, not as string. In templates, we can use `{{ is_state(input.fan_entity, 'off') }}`? Actually the variable for input is `!input fan_entity`. In templating, we can refer to `input.fan_entity`? I think we use `{{ is_state('input.fan_entity', 'off') }}`? Not sure. In blueprint docs, you use `!input fan_entity` to inject into YAML, but in templates you use `input.fan_entity`. Actually I recall you refer to input via `input.fan_entity` or `input.fan_entity`? Checking memory: In Home Assistant templating, to reference blueprint input variables you use `input.fan_entity`. Yes, it's like that. So condition:

          ```
          condition:
            - condition: template
              value_template: >
                {% if trigger.id == 'turn_on' %}
                  {{ is_state(input.fan_entity, 'off') }}
                {% elif trigger.id == 'turn_off' %}
                  {{ is_state(input.fan_entity, 'on') }}
                {% endif %}
          ```

          Then action:

          ```
          action:
            - service_template: >
                {% if trigger.id == 'turn_on' %}
                  fan.turn_on
                {% elif trigger.id == 'turn_off' %}
                  fan.turn_off
                {% endif %}
              data:
                entity_id: !input fan_entity
          ```

          But service_template expects string for service name. Good.

          Also maybe add for: "0" to trigger immediately.

          So blueprint:

          ```
          blueprint:
            name: Humidity Controlled Fan
            domain: automation
            input:
              humidity_sensor:
                name: Humidity Sensor
                selector:
                  entity:
                    domain: sensor
              humidity_level:
                name: Humidity Threshold
                selector:
                  number:
                    min: 0
                    max: 100
                    unit_of_measurement: "%"
              fan_entity:
                name: Fan
                selector:
                  entity:
                    domain: fan

          trigger:
            - platform: numeric_state
              entity_id: !input humidity_sensor
              above: !input humidity_level
              id: turn_on
            - platform: numeric_state
              entity_id: !input humidity_sensor
              below: !input humidity_level
              id: turn_off

          condition:
            - condition: template
              value_template: >
                {% if trigger.id == 'turn_on' %}
                  {{ is_state(input.fan_entity, 'off') }}
                {% elif trigger.id == 'turn_off' %}
                  {{ is_state(input.fan_entity, 'on') }}
                {% endif %}

          action:
            - service_template: >
                {% if trigger.id == 'turn_on' %}
                  fan.turn_on
                {% elif trigger.id == 'turn_off' %}
                  fan.turn_off
                {% endif %}
              data:
                entity_id: !input fan_entity
          ```

          Add `mode: restart` to ensure no overlapping triggers. Add `trigger_variables`? Not necessary.

          So final answer: blueprint YAML.

          Let's produce that.
        tool_calls: null
        native: null
        created: 2026-01-18 14:26:12.333482+00:00
      tools: null
    timestamp: 2026-01-18 14:25:51.128217+00:00
  duration_ms: 21206.522
  tries: 1
