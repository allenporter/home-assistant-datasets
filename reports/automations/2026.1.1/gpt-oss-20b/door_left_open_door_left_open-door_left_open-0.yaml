---
uuid: 83144aec-44d8-4316-b5f7-939de3bbde1a
task_id: door_left_open_door_left_open-door_left_open-0
model_id: gpt-oss-20b
category: media_player
task:
  input_text: |
    # Door left open

    ## Problem statement

    Create an blueprint automation to play an alert on the speaker when the door is
    left open.

    ## Example use cases

    These are example use cases that could be used with the blueprint:

    - Play an message on the living room speaker if the garage door has been left open for more than 30 minutes
    - When the front door is ajar for 5 minutes, play a sound on the kitchen bluetooth speaker.

    ## Detailed Description

    The blueprint should accept two inputs:

    | Input           | Selector Type | Description                                                                           |
    | --------------- | ------------- | ------------------------------------------------------------------------------------- |
    | `door_sensor`   | `entity`      | A `binary_sensor` entity selector door sensor that is the target of the automation.   |
    | `alert_media`   | `media`       | The target for the `media` selector for the media player and media id with the alter. |
    | `open_duration` | `duration`    | A `duration` selector, the amount of time before playing the alert.                   |

    The automation should play the selected media when the door has been open for the specified duration.
response: |-
  ```yaml
  blueprint:
    name: Door left open alert
    description: |
      Plays a chosen audio message on a media player when a door sensor has been
      in the "on" state for a specified duration.
    domain: automation
    input:
      door_sensor:
        name: Door sensor
        description: Binary sensor that reports the door state.
        selector:
          entity:
            domain: binary_sensor
      alert_media:
        name: Alert media
        description: Media to play on the chosen media player.
        selector:
          media:
      open_duration:
        name: Open duration
        description: Time the door must remain open before the alert is triggered.
        selector:
          duration:

  trigger:
    # Trigger when the door stays open for the specified duration
    - platform: state
      entity_id: !input door_sensor
      to: "on"
      for: !input open_duration

  action:
    - service: media_player.play_media
      data_template:
        # The media selector returns an object that contains the media_player
        # entity and the media content to play.  The template pulls those
        # values out of the selector.
        entity_id: "{{ alert_media.media_player.entity_id }}"
        media_content_id: "{{ alert_media.media_id }}"
        media_content_type: "{{ alert_media.media_type }}"
  ```
context:
  conversation_trace:
  - event_type: async_process
    data:
      text: |
        # Door left open

        ## Problem statement

        Create an blueprint automation to play an alert on the speaker when the door is
        left open.

        ## Example use cases

        These are example use cases that could be used with the blueprint:

        - Play an message on the living room speaker if the garage door has been left open for more than 30 minutes
        - When the front door is ajar for 5 minutes, play a sound on the kitchen bluetooth speaker.

        ## Detailed Description

        The blueprint should accept two inputs:

        | Input           | Selector Type | Description                                                                           |
        | --------------- | ------------- | ------------------------------------------------------------------------------------- |
        | `door_sensor`   | `entity`      | A `binary_sensor` entity selector door sensor that is the target of the automation.   |
        | `alert_media`   | `media`       | The target for the `media` selector for the media player and media id with the alter. |
        | `open_duration` | `duration`    | A `duration` selector, the amount of time before playing the alert.                   |

        The automation should play the selected media when the door has been open for the specified duration.
      context:
        id: 01KF8QWP7GB0TV1959CE2HCJXD
        parent_id: null
        user_id: null
      conversation_id: null
      device_id: null
      satellite_id: null
      language: en
      agent_id: conversation.mock_title
      extra_system_prompt: null
    timestamp: 2026-01-18 14:24:37.104499+00:00
  - event_type: agent_detail
    data:
      messages:
      - role: system
        content: |-
          You are a voice assistant for Home Assistant.
          Answer questions about the world truthfully.
          Answer in plain text. Keep it simple and to the point.
          Current time is 06:24:37. Today's date is 2026-01-18.
        created: 2026-01-18 14:24:37.106741+00:00
      - role: user
        content: |
          # Door left open

          ## Problem statement

          Create an blueprint automation to play an alert on the speaker when the door is
          left open.

          ## Example use cases

          These are example use cases that could be used with the blueprint:

          - Play an message on the living room speaker if the garage door has been left open for more than 30 minutes
          - When the front door is ajar for 5 minutes, play a sound on the kitchen bluetooth speaker.

          ## Detailed Description

          The blueprint should accept two inputs:

          | Input           | Selector Type | Description                                                                           |
          | --------------- | ------------- | ------------------------------------------------------------------------------------- |
          | `door_sensor`   | `entity`      | A `binary_sensor` entity selector door sensor that is the target of the automation.   |
          | `alert_media`   | `media`       | The target for the `media` selector for the media player and media id with the alter. |
          | `open_duration` | `duration`    | A `duration` selector, the amount of time before playing the alert.                   |

          The automation should play the selected media when the door has been open for the specified duration.
        attachments: null
        created: 2026-01-18 14:24:37.104584+00:00
      - role: assistant
        agent_id: conversation.mock_title
        content: |-
          ```yaml
          blueprint:
            name: Door left open alert
            description: |
              Plays a chosen audio message on a media player when a door sensor has been
              in the "on" state for a specified duration.
            domain: automation
            input:
              door_sensor:
                name: Door sensor
                description: Binary sensor that reports the door state.
                selector:
                  entity:
                    domain: binary_sensor
              alert_media:
                name: Alert media
                description: Media to play on the chosen media player.
                selector:
                  media:
              open_duration:
                name: Open duration
                description: Time the door must remain open before the alert is triggered.
                selector:
                  duration:

          trigger:
            # Trigger when the door stays open for the specified duration
            - platform: state
              entity_id: !input door_sensor
              to: "on"
              for: !input open_duration

          action:
            - service: media_player.play_media
              data_template:
                # The media selector returns an object that contains the media_player
                # entity and the media content to play.  The template pulls those
                # values out of the selector.
                entity_id: "{{ alert_media.media_player.entity_id }}"
                media_content_id: "{{ alert_media.media_id }}"
                media_content_type: "{{ alert_media.media_type }}"
          ```
        thinking_content: "We need to create a blueprint automation. Must be in YAML\
          \ format for Home Assistant. We need to accept inputs: door_sensor (entity\
          \ selector binary_sensor), alert_media (media selector), open_duration (duration).\
          \ The automation should play media when door open for duration. Should probably\
          \ use a trigger for door_sensor going from off to on? Then a delay for open_duration,\
          \ and then check state still open, then call service media_player.play_media\
          \ with entity_id = alert_media.media_player.entity_id and media_content_type=\
          \ etc? The media selector gives media_player and media_id? Actually media\
          \ selector returns entity id of media player, and you can also specify media_id\
          \ via attributes? In Home Assistant, media selector: returns entity_id and\
          \ media_content_id? Need to read docs. The media selector: returns dict\
          \ with entity_id and media_content_id? Usually used in input_text? Let's\
          \ search memory: media selector can have 'media' type? In blueprint, media\
          \ selector is not typical; there is 'media' selector type. It returns entity_id?\
          \ I think for media you can call service 'media_player.play_media' with\
          \ entity_id and media_content_id and media_content_type? For simplicity,\
          \ maybe treat alert_media as a media player entity only. But problem says\
          \ \"target for the media selector for the media player and media id with\
          \ the alert\". So perhaps media selector returns entity_id and media_id\
          \ attribute. Example usage: media: entity_id: media_player.living_room,\
          \ media_content_id: \"https://myserver.com/alert.mp3\". So blueprint should\
          \ allow specifying media_player and media_id. But blueprint selector media\
          \ returns entity_id and media_content_id? Actually in UI, you can specify\
          \ media player and media ID. The media selector allows selecting media content.\
          \ The resulting data structure: {\"entity_id\": \"media_player.living_room\"\
          , \"media_content_id\": \"alert.mp3\"} maybe. So in the automation, call\
          \ service media_player.play_media with entity_id= alert_media.media_player.entity_id?\
          \ Hmm.\n\nLet's design blueprint:\n\nblueprint:\n  name: Door left open\
          \ alert\n  description: Plays an alert on a speaker when a door has been\
          \ open longer than a specified duration.\n  domain: automation\n  input:\n\
          \    door_sensor:\n      name: Door sensor\n      selector:\n        entity:\n\
          \          domain: binary_sensor\n    alert_media:\n      name: Alert media\n\
          \      selector:\n        media:\n    open_duration:\n      name: Open duration\n\
          \      selector:\n        duration:\n  trigger:\n    - platform: state\n\
          \      entity_id: !input door_sensor\n      to: \"on\"\n  condition:\n \
          \   - condition: state\n      entity_id: !input door_sensor\n      state:\
          \ \"on\"\n  action:\n    - wait_for_trigger:\n        - platform: state\n\
          \          entity_id: !input door_sensor\n          to: \"off\"\n      \
          \    for: !input open_duration\n      continue_on_timeout: false\n    -\
          \ service: media_player.play_media\n      data:\n        entity_id: !input\
          \ alert_media.media_player.entity_id? Wait.\n\nBetter: Use 'data_template'\
          \ to extract entity_id and media_content_id. But we need to refer to the\
          \ result of selector: For media selector, I think you can refer as !input\
          \ alert_media.media_player? Let's check typical usage: For example:\n\n\
          ```\ninput:\n  media:\n    selector:\n      media:\n\ntrigger:\n  ...\n\
          action:\n  - service: media_player.play_media\n    target:\n      entity_id:\
          \ !input media.media_player.entity_id\n    data:\n      media_content_id:\
          \ !input media.media_id\n      media_content_type: audio/mp3\n```\n\nBut\
          \ I'm not entirely sure. We can just use data_template referencing attributes:\
          \ \n\n```\n- service: media_player.play_media\n  data_template:\n    entity_id:\
          \ \"{{ alert_media.media_player.entity_id }}\"\n    media_content_id: \"\
          {{ alert_media.media_id }}\"\n    media_content_type: \"{{ alert_media.media_type\
          \ }}\"\n```\n\nBut not sure about attributes names. According to docs: Media\
          \ selector returns: {\"entity_id\":\"media_player.living_room\",\"media_content_id\"\
          :\"https://...\",\"media_content_type\":\"audio/mp3\"} Possibly. So we can\
          \ just set:\n\n```\n- service: media_player.play_media\n  data:\n    entity_id:\
          \ !input alert_media.media_player.entity_id\n    media_content_id: !input\
          \ alert_media.media_id\n    media_content_type: !input alert_media.media_type\n\
          ```\n\nBut the input may directly provide these fields. Perhaps easier:\
          \ use service: !input alert_media.service? Hmm.\n\nWe can circumvent by\
          \ using a template to call the media_player.play_media service with entity_id\
          \ set to the media selector's entity_id, and media_content_id set to the\
          \ media selector's media_id. We'll need to know attribute names: According\
          \ to Home Assistant docs for media selector: It returns \"media_player\"\
          \ entity id and \"media_content_id\" and \"media_content_type\". Let's just\
          \ assume that.\n\nSo:\n\n```\n- service: media_player.play_media\n  data:\n\
          \    entity_id: !input alert_media.media_player.entity_id\n    media_content_id:\
          \ !input alert_media.media_id\n    media_content_type: !input alert_media.media_type\n\
          ```\n\nBut we can also use `data_template` with Jinja.\n\nLet's produce\
          \ blueprint:\n\n```\nblueprint:\n  name: Door left open alert\n  domain:\
          \ automation\n  input:\n    door_sensor:\n      name: Door sensor\n    \
          \  selector:\n        entity:\n          domain: binary_sensor\n    alert_media:\n\
          \      name: Alert media\n      selector:\n        media:\n    open_duration:\n\
          \      name: Open duration\n      selector:\n        duration:\n  trigger:\n\
          \    - platform: state\n      entity_id: !input door_sensor\n      to: \"\
          on\"\n  condition:\n    - condition: state\n      entity_id: !input door_sensor\n\
          \      state: \"on\"\n  action:\n    - wait_for_trigger:\n        - platform:\
          \ state\n          entity_id: !input door_sensor\n          to: \"off\"\n\
          \          for: !input open_duration\n      continue_on_timeout: false\n\
          \    - service: media_player.play_media\n      data:\n        entity_id:\
          \ !input alert_media.media_player.entity_id\n        media_content_id: !input\
          \ alert_media.media_id\n        media_content_type: !input alert_media.media_type\n\
          ```\n\nBut we might need to refer to media selector's fields: Let's check\
          \ an example from docs: In blueprint, we can use:\n\n```\n- service: notify.notify\n\
          \  data:\n    message: !input notification_message\n```\n\nBut for media:\
          \ maybe like:\n\n```\n- service: media_player.play_media\n  target:\n  \
          \  entity_id: !input alert_media.media_player.entity_id\n  data:\n    media_content_id:\
          \ !input alert_media.media_id\n    media_content_type: !input alert_media.media_type\n\
          ```\n\nBut `media` selector may provide an object with keys: entity_id,\
          \ media_content_id, media_content_type. So we can use:\n\n```\ntarget:\n\
          \  entity_id: !input alert_media.media_player.entity_id\n```\n\nBut there\
          \ might not be nested keys. For simplicity, maybe we can just use data_template:\n\
          \n```\n- service: media_player.play_media\n  data_template:\n    entity_id:\
          \ \"{{ alert_media.media_player.entity_id }}\"\n    media_content_id: \"\
          {{ alert_media.media_id }}\"\n    media_content_type: \"{{ alert_media.media_type\
          \ }}\"\n```\n\nBut the blueprint uses YAML; we can use !input referencing\
          \ the whole object and then use .entity_id? I think we can. So final blueprint:\n\
          \n```\nblueprint:\n  name: Door left open alert\n  domain: automation\n\
          \  input:\n    door_sensor:\n      name: Door sensor\n      selector:\n\
          \        entity:\n          domain: binary_sensor\n    alert_media:\n  \
          \    name: Alert media\n      selector:\n        media:\n    open_duration:\n\
          \      name: Open duration\n      selector:\n        duration:\n  trigger:\n\
          \    - platform: state\n      entity_id: !input door_sensor\n      to: \"\
          on\"\n  condition:\n    - condition: state\n      entity_id: !input door_sensor\n\
          \      state: \"on\"\n  action:\n    - wait_for_trigger:\n        - platform:\
          \ state\n          entity_id: !input door_sensor\n          to: \"off\"\n\
          \          for: !input open_duration\n      continue_on_timeout: false\n\
          \    - service: media_player.play_media\n      data_template:\n        entity_id:\
          \ \"{{ alert_media.media_player.entity_id }}\"\n        media_content_id:\
          \ \"{{ alert_media.media_id }}\"\n        media_content_type: \"{{ alert_media.media_type\
          \ }}\"\n```\n\nThis should work.\n\nWe also need to ensure blueprint is\
          \ a YAML file. Provide full content. Also mention that the blueprint will\
          \ trigger when door sensor turns on, wait until it's closed for open_duration?\
          \ Actually we want to play when open for more than open_duration. So we\
          \ should wait for state to be still \"on\" for that duration. We can use\
          \ `wait_for_trigger` with a delay? Another approach: Wait for `for` argument\
          \ on state trigger? The simplest: Use a `wait_for_trigger` that triggers\
          \ when door sensor changes state after open_duration? But the `for` argument\
          \ can be used on the trigger to delay. So we can:\n\n```\ntrigger:\n  -\
          \ platform: state\n    entity_id: !input door_sensor\n    to: \"on\"\n \
          \   for: !input open_duration\n```\n\nBut this triggers when door stays\
          \ open for open_duration. Then we can play. That is simpler: we don't need\
          \ wait_for_trigger. But we also need to ensure door remains open. But the\
          \ trigger for state with `for` will only trigger when state remains \"on\"\
          \ for that duration. So that is good. But we want to play if door has been\
          \ open for more than open_duration, not exactly. The state for will trigger\
          \ at that moment. So we just play. So simpler blueprint:\n\n```\ntrigger:\n\
          \  - platform: state\n    entity_id: !input door_sensor\n    to: \"on\"\n\
          \    for: !input open_duration\n```\n\nThat triggers once when open duration\
          \ reached. Then play. That solves the issue. We don't need conditions. But\
          \ we might want to ensure that it doesn't trigger again if door remains\
          \ open longer. The state trigger will fire only once at that moment. So\
          \ fine.\n\nBut if door is opened, closed, reopened, etc. Each time triggers\
          \ again after open_duration.\n\nSo blueprint:\n\n```\naction:\n  - service:\
          \ media_player.play_media\n    data_template:\n      entity_id: \"{{ alert_media.media_player.entity_id\
          \ }}\"\n      media_content_id: \"{{ alert_media.media_id }}\"\n      media_content_type:\
          \ \"{{ alert_media.media_type }}\"\n```\n\nYes.\n\nLet's produce final blueprint\
          \ YAML accordingly."
        tool_calls: null
        native: null
        created: 2026-01-18 14:24:55.013496+00:00
      tools: null
    timestamp: 2026-01-18 14:24:37.106752+00:00
  duration_ms: 17909.209
  tries: 1
